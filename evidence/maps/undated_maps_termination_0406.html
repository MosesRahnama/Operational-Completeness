<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Termination</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        table td, table th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        strong {
            color: #2c3e50;
        }
        @media print {
            body {
                max-width: none;
                margin: 0;
                padding: 20px;
            }
            h1 {
                page-break-before: always;
            }
            pre {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
import OperatorKernelO6.Kernel<br>
import Init.WF<br>
import Mathlib.Data.Prod.Lex<br>
import Mathlib.Algebra.Order.SuccPred<br>
import Mathlib.Data.Nat.Cast.Order.Basic<br>
import Mathlib.SetTheory.Ordinal.Basic<br>
import Mathlib.SetTheory.Ordinal.Arithmetic<br>
import Mathlib.SetTheory.Ordinal.Exponential<br>
import Mathlib.Algebra.Order.Monoid.Defs<br>
import Mathlib.Tactic.Linarith<br>
import Mathlib.Tactic.NormNum<br>
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.Defs<br>
import Mathlib.Algebra.Order.Monoid.Unbundled.Basic<br>
import Mathlib.Tactic.Ring<br>
import Mathlib.Algebra.Order.Group.Defs<br>
import Mathlib.SetTheory.Ordinal.Principal<br>
import Mathlib.Tactic<br>
set_option linter.unnecessarySimpa false<br>
-- set_option linter.unnecessarySimpa false<br>
universe u<br>
<br>
open Ordinal<br>
open OperatorKernelO6<br>
open Trace<br>
<br>
namespace MetaSN<br>
-- (removed auxiliary succ_succ_eq_add_two' as we keep +2 canonical form)<br>
<br>
/-- Strict-mono of ω-powers in the exponent (base <code>omega0</code>). --/<br>
@[simp] theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :<br>
  omega0 ^ b < omega0 ^ c := by<br>
  simpa using ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)<br>
<br>
<br>
noncomputable def mu : Trace → Ordinal.{0}<br>
| .void        => 0<br>
| .delta t     => (omega0 ^ (5 : Ordinal)) * (mu t + 1) + 1<br>
| .integrate t => (omega0 ^ (4 : Ordinal)) * (mu t + 1) + 1<br>
| .merge a b   =><br>
    (omega0 ^ (3 : Ordinal)) * (MetaSN.mu a + 1) +<br>
    (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 1<br>
| .recΔ b s n  =><br>
    omega0 ^ (MetaSN.mu n + MetaSN.mu s + (6 : Ordinal))<br>
  + omega0 * (MetaSN.mu b + 1) + 1<br>
| .eqW a b     =><br>
    omega0 ^ (MetaSN.mu a + MetaSN.mu b + (9 : Ordinal)) + 1<br>
<br>
/-- Secondary counter: 0 everywhere <strong>except</strong> it counts the<br>
    nesting level inside <code>recΔ</code> so that <code>recΔ succ</code> strictly drops. -/<br>
def kappa : Trace → ℕ<br>
| Trace.recΔ _ _ n => (kappa n).succ<br>
| Trace.void => 0<br>
| Trace.delta _ => 0<br>
| Trace.integrate _ => 0<br>
| Trace.merge _ _ => 0<br>
| Trace.eqW _ _ => 0<br>
<br>
-- combined measure pair (kappa primary, mu secondary)<br>
noncomputable def μκ (t : Trace) : ℕ × Ordinal := (kappa t, mu t)<br>
<br>
-- lexicographic ordering on the pair<br>
def LexNatOrd : (ℕ × Ordinal) → (ℕ × Ordinal) → Prop :=<br>
  Prod.Lex (· < ·) (· < ·)<br>
<br>
<br>
@[simp] lemma kappa_non_rec (t : Trace)<br>
  : (¬ ∃ b s n, t = Trace.recΔ b s n) → kappa t = 0 := by<br>
  cases t with<br>
  | recΔ b s n =><br>
      intro h; exact (False.elim (h ⟨b, s, n, rfl⟩))<br>
  | void => intro _; simp [kappa]<br>
  | delta _ => intro _; simp [kappa]<br>
  | integrate _ => intro _; simp [kappa]<br>
  | merge _ _ => intro _; simp [kappa]<br>
  | eqW _ _ => intro _; simp [kappa]<br>
<br>
theorem mu_lt_merge_void_right (t : Trace) :<br>
  mu t < MetaSN.mu (.merge t .void) := by<br>
  -- μ(merge t void) = ω³*(μ t +1) + ω² + 1 dominates μ t<br>
  have h1 : mu t < mu t + 1 :=<br>
    (Order.lt_add_one_iff (x := mu t) (y := mu t)).2 le_rfl<br>
  have pos3 : 0 < omega0 ^ (3 : Ordinal) :=<br>
    Ordinal.opow_pos (a := omega0) (b := (3 : Ordinal)) omega0_pos<br>
  have hmono : mu t + 1 ≤ omega0 ^ (3 : Ordinal) * (mu t + 1) := by<br>
    simpa using (Ordinal.le_mul_right (a := mu t + 1) (b := omega0 ^ (3 : Ordinal)) pos3)<br>
  have h2 : mu t < omega0 ^ (3 : Ordinal) * (mu t + 1) := lt_of_lt_of_le h1 hmono<br>
  have tail : (0 : Ordinal) ≤ omega0 ^ (2 : Ordinal) * (0 + 1) + 1 := zero_le _<br>
  have h3 : omega0 ^ (3 : Ordinal) * (mu t + 1) ≤<br>
      omega0 ^ (3 : Ordinal) <em> (mu t + 1) + (omega0 ^ (2 : Ordinal) </em> (0 + 1) + 1) :=<br>
    le_add_of_nonneg_right tail<br>
  have h4 : mu t < omega0 ^ (3 : Ordinal) <em> (mu t + 1) + (omega0 ^ (2 : Ordinal) </em> (0 + 1) + 1) :=<br>
    lt_of_lt_of_le h2 h3<br>
  simpa [mu, add_assoc, add_comm, add_left_comm]<br>
    using h4<br>
<br>
theorem zero_lt_add_one (y : Ordinal) : (0 : Ordinal) < y + 1 :=<br>
  (Order.lt_add_one_iff (x := (0 : Ordinal)) (y := y)).2 bot_le<br>
<br>
theorem mu_void_lt_integrate_delta (t : Trace) :<br>
  MetaSN.mu .void < MetaSN.mu (.integrate (.delta t)) := by<br>
  simp [MetaSN.mu]<br>
<br>
theorem mu_void_lt_eq_refl (a : Trace) :<br>
  MetaSN.mu .void < MetaSN.mu (.eqW a a) := by<br>
  simp [MetaSN.mu]<br>
<br>
/-- Cancellation rule: <code>merge t t → t</code> strictly drops <code>μ</code>. -/<br>
theorem mu_lt_merge_cancel (t : Trace) :<br>
  MetaSN.mu t < MetaSN.mu (.merge t t) := by<br>
  have h0 : MetaSN.mu t < MetaSN.mu t + 1 :=<br>
    (Order.lt_add_one_iff (x := MetaSN.mu t) (y := MetaSN.mu t)).2 le_rfl<br>
  have pos3 : 0 < omega0 ^ (3 : Ordinal) :=<br>
    Ordinal.opow_pos (a := omega0) (b := (3 : Ordinal)) omega0_pos<br>
  have hmono : MetaSN.mu t + 1 ≤ omega0 ^ (3 : Ordinal) * (MetaSN.mu t + 1) := by<br>
    simpa using (Ordinal.le_mul_right (a := MetaSN.mu t + 1) (b := omega0 ^ (3 : Ordinal)) pos3)<br>
  have h1 : MetaSN.mu t < omega0 ^ (3 : Ordinal) * (MetaSN.mu t + 1) := lt_of_lt_of_le h0 hmono<br>
  -- add the second ω²-term (same <code>t</code>) and tail +1<br>
  have pad :<br>
      omega0 ^ (3 : Ordinal) * (MetaSN.mu t + 1) ≤<br>
      (omega0 ^ (3 : Ordinal)) * (MetaSN.mu t + 1) +<br>
        (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) :=<br>
    Ordinal.le_add_right _ _<br>
  have pad1 :<br>
      omega0 ^ (3 : Ordinal) * (MetaSN.mu t + 1) + 1 ≤<br>
      ((omega0 ^ (3 : Ordinal)) * (MetaSN.mu t + 1) +<br>
        (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1)) + 1 :=<br>
    add_le_add_right pad 1<br>
  have h2 :<br>
      MetaSN.mu t <<br>
      ((omega0 ^ (3 : Ordinal)) * (MetaSN.mu t + 1) +<br>
        (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1)) + 1 :=<br>
    lt_of_lt_of_le<br>
      (lt_of_lt_of_le h1 (le_add_of_nonneg_right (zero_le _))) pad1<br>
  simpa [MetaSN.mu, add_assoc]<br>
    using h2<br>
-- Diagnostic flag<br>
def debug_mode := true<br>
<br>
<br>
-- set_option trace.Meta.Tactic.simp true<br>
<br>
<br>
<br>
-- set_option diagnostics.threshold 100<br>
-- set_option diagnostics true<br>
-- set_option autoImplicit false<br>
-- set_option maxRecDepth 500<br>
-- set_option pp.explicit true<br>
-- set_option pp.universes true<br>
-- set_option trace.Meta.isDefEq true<br>
-- set_option trace.Meta.debug true<br>
-- set_option trace.Meta.Tactic.simp.rewrite true<br>
-- set_option trace.linarith true<br>
-- set_option trace.compiler.ir.result true<br>
<br>
<br>
<br>
-- (Removed earlier succ_succ_eq_add_two lemma to avoid recursive simp loops.)<br>
lemma succ_succ_eq_add_two (x : Ordinal) :<br>
  Order.succ (Order.succ x) = x + 2 := by<br>
  have hx : Order.succ x = x + 1 := by<br>
    simpa using (Ordinal.add_one_eq_succ (a := x)).symm<br>
  have hx2 : Order.succ (Order.succ x) = (x + 1) + 1 := by<br>
    -- rewrite outer succ<br>
    rw [hx]<br>
    simpa using (Ordinal.add_one_eq_succ (a := x + 1)).symm<br>
  -- assemble via calc to avoid deep simp recursion<br>
  calc<br>
    Order.succ (Order.succ x) = (x + 1) + 1 := hx2<br>
    _ = x + (1 + 1) := by rw [add_assoc]<br>
    _ = x + 2 := by simp<br>
<br>
@[simp] lemma succ_succ_pow2 :<br>
  Order.succ (Order.succ (omega0 ^ (2 : Ordinal))) = omega0 ^ (2 : Ordinal) + 2 := by<br>
  simpa using succ_succ_eq_add_two (omega0 ^ (2 : Ordinal))<br>
<br>
<br>
/-- Special case: both args void. Clean proof staying in +2 form. -/<br>
theorem mu_lt_eq_diff_both_void :<br>
  MetaSN.mu (integrate (merge .void .void)) < MetaSN.mu (eqW .void .void) := by<br>
  -- μ(merge void void)<br>
  have hμm : MetaSN.mu (merge .void .void) =<br>
      omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 1 := by<br>
    simp [MetaSN.mu, add_assoc]<br>
  -- rewrite μ(integrate ...)<br>
  have hL : MetaSN.mu (integrate (merge .void .void)) =<br>
      omega0 ^ (4 : Ordinal) * (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) + 1 := by<br>
    simpa [MetaSN.mu, hμm, add_assoc]<br>
  -- payload pieces < ω^5 via additive principal<br>
  have hα : omega0 ^ (3 : Ordinal) < omega0 ^ (5 : Ordinal) := by<br>
    have : (3 : Ordinal) < 5 := by norm_num<br>
    simpa using opow_lt_opow_right this<br>
  have hβ : omega0 ^ (2 : Ordinal) < omega0 ^ (5 : Ordinal) := by<br>
    have : (2 : Ordinal) < 5 := by norm_num<br>
    simpa using opow_lt_opow_right this<br>
  have hγ : (2 : Ordinal) < omega0 ^ (5 : Ordinal) := by<br>
    have h2ω : (2 : Ordinal) < omega0 := nat_lt_omega0 2<br>
    have ω_le : omega0 ≤ omega0 ^ (5 : Ordinal) := by<br>
      have : (1 : Ordinal) ≤ (5 : Ordinal) := by norm_num<br>
      have hpow := Ordinal.opow_le_opow_right omega0_pos this<br>
      simpa using (le_trans (by simpa using (Ordinal.opow_one omega0).symm.le) hpow)<br>
    exact lt_of_lt_of_le h2ω ω_le<br>
  have hprin := Ordinal.principal_add_omega0_opow (5 : Ordinal)<br>
  have hsum12 : omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) < omega0 ^ (5 : Ordinal) :=<br>
    hprin hα hβ<br>
  have h_payload : omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2 < omega0 ^ (5 : Ordinal) :=<br>
    hprin hsum12 hγ<br>
  -- multiply by ω^4 and collapse exponent<br>
  have pos4 : (0 : Ordinal) < omega0 ^ (4 : Ordinal) :=<br>
    Ordinal.opow_pos (a := omega0) (b := (4 : Ordinal)) omega0_pos<br>
  have hstep : omega0 ^ (4 : Ordinal) *<br>
      (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) <<br>
      omega0 ^ (4 : Ordinal) * omega0 ^ (5 : Ordinal) :=<br>
    Ordinal.mul_lt_mul_of_pos_left h_payload pos4<br>
  have hcollapse : omega0 ^ (4 : Ordinal) * omega0 ^ (5 : Ordinal) =<br>
      omega0 ^ (4 + 5 : Ordinal) := by<br>
    simpa using (Ordinal.opow_add omega0 (4:Ordinal) (5:Ordinal)).symm<br>
  have h45 : (4 : Ordinal) + (5 : Ordinal) = (9 : Ordinal) := by norm_num<br>
  have h_prod :<br>
      omega0 ^ (4 : Ordinal) *<br>
        (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) <<br>
      omega0 ^ (9 : Ordinal) := by<br>
    have htmp2 : omega0 ^ (4 : Ordinal) *<br>
        (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) < omega0 ^ (4 + 5 : Ordinal) :=<br>
      lt_of_lt_of_eq hstep hcollapse<br>
    have hrewrite : omega0 ^ (4 + 5 : Ordinal) = omega0 ^ (9 : Ordinal) := by<br>
      simpa using congrArg (fun e => omega0 ^ e) h45<br>
    exact lt_of_lt_of_eq htmp2 hrewrite<br>
  -- add-one bridge<br>
  have hR : MetaSN.mu (eqW .void .void) = omega0 ^ (9 : Ordinal) + 1 := by<br>
    simp [MetaSN.mu]<br>
  have hA1 : omega0 ^ (4 : Ordinal) *<br>
      (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) + 1 ≤<br>
      omega0 ^ (9 : Ordinal) := Order.add_one_le_of_lt h_prod<br>
  have hfin : omega0 ^ (4 : Ordinal) *<br>
      (omega0 ^ (3 : Ordinal) + omega0 ^ (2 : Ordinal) + 2) + 1 <<br>
      omega0 ^ (9 : Ordinal) + 1 :=<br>
    (Order.lt_add_one_iff (x := _ + 1) (y := omega0 ^ (9 : Ordinal))).2 hA1<br>
  simpa [hL, hR] using hfin<br>
<br>
@[simp] lemma succ_succ_mul_pow2_succ (x : Ordinal) :<br>
  Order.succ (Order.succ (omega0 ^ (2 : Ordinal) * Order.succ x)) =<br>
    omega0 ^ (2 : Ordinal) * Order.succ x + 2 := by<br>
  simpa using succ_succ_eq_add_two (omega0 ^ (2 : Ordinal) * Order.succ x)<br>
<br>
-- (section continues with μ auxiliary lemmas)<br>
lemma mu_recDelta_plus_3_lt (b s n : Trace)<br>
  (h_bound : omega0 ^ (MetaSN.mu n + MetaSN.mu s + (6 : Ordinal)) + omega0 * (MetaSN.mu b + 1) + 1 + 3 <<br>
             (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 + MetaSN.mu s + 6) :<br>
  MetaSN.mu (recΔ b s n) + 3 < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
  -- Expand mu definitions on both sides; structure then matches h_bound directly<br>
  simp only [mu]<br>
  exact h_bound<br>
<br>
<br>
private lemma le_omega_pow (x : Ordinal) : x ≤ omega0 ^ x :=<br>
  Ordinal.right_le_opow (a := omega0) (b := x) one_lt_omega0<br>
<br>
theorem add_one_le_of_lt {x y : Ordinal} (h : x < y) : x + 1 ≤ y := by<br>
  simpa [Ordinal.add_one_eq_succ] using (Order.add_one_le_of_lt h)<br>
<br>
private lemma nat_coeff_le_omega_pow (n : ℕ) :<br>
  (n : Ordinal) + 1 ≤ (omega0 ^ (n : Ordinal)) := by<br>
  classical<br>
  cases' n with n<br>
  · -- <code>n = 0</code>: <code>1 ≤ ω^0 = 1</code><br>
    simp<br>
  · -- <code>n = n.succ</code><br>
<br>
    have hfin : (n.succ : Ordinal) < omega0 := by<br>
<br>
      simpa using (Ordinal.nat_lt_omega0 (n.succ))<br>
    have hleft : (n.succ : Ordinal) + 1 ≤ omega0 :=<br>
      Order.add_one_le_of_lt hfin<br>
<br>
    have hpos : (0 : Ordinal) < (n.succ : Ordinal) := by<br>
      simpa using (Nat.cast_pos.mpr (Nat.succ_pos n))<br>
    have hmono : (omega0 : Ordinal) ≤ (omega0 ^ (n.succ : Ordinal)) := by<br>
      -- <code>left_le_opow</code> has type: <code>0 < b → a ≤ a ^ b</code><br>
      simpa using (Ordinal.left_le_opow (a := omega0) (b := (n.succ : Ordinal)) hpos)<br>
<br>
    exact hleft.trans hmono<br>
<br>
private lemma coeff_fin_le_omega_pow (n : ℕ) :<br>
  (n : Ordinal) + 1 ≤ omega0 ^ (n : Ordinal) := nat_coeff_le_omega_pow n<br>
<br>
@[simp] theorem natCast_le {m n : ℕ} :<br>
  ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le<br>
<br>
@[simp] theorem natCast_lt {m n : ℕ} :<br>
  ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt<br>
<br>
theorem eq_nat_or_omega0_le (p : Ordinal) :<br>
  (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by<br>
  classical<br>
  cases lt_or_ge p omega0 with<br>
  | inl h  =><br>
      rcases (lt_omega0).1 h with ⟨n, rfl⟩<br>
      exact Or.inl ⟨n, rfl⟩<br>
  | inr h  => exact Or.inr h<br>
<br>
theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) :<br>
  (1 : Ordinal) + p = p := by<br>
  simpa using (one_add_of_omega0_le h)<br>
<br>
theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) :<br>
  (n : Ordinal) + p = p := by<br>
  simpa using (natCast_add_of_omega0_le h n)<br>
<br>
@[simp] theorem add_natCast_left (m n : ℕ) :<br>
  (m : Ordinal) + (n : Ordinal) = ((m + n : ℕ) : Ordinal) := by<br>
  induction n with<br>
  | zero =><br>
      simp<br>
  | succ n ih =><br>
      simp [Nat.cast_succ]<br>
<br>
theorem mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :<br>
    a <em> b ≤ c </em> d := by<br>
  have h₁' : a <em> b ≤ c </em> b := by<br>
    simpa using (mul_le_mul_right' h₁ b)        -- mono in left factor<br>
  have h₂' : c <em> b ≤ c </em> d := by<br>
    simpa using (mul_le_mul_left' h₂ c)         -- mono in right factor<br>
  exact le_trans h₁' h₂'<br>
<br>
theorem add4_plus5_le_plus9 (p : Ordinal) :<br>
  (4 : Ordinal) + (p + 5) ≤ p + 9 := by<br>
  classical<br>
  rcases lt_or_ge p omega0 with hfin | hinf<br>
  · -- finite case: <code>p = n : ℕ</code><br>
    rcases (lt_omega0).1 hfin with ⟨n, rfl⟩<br>
    -- compute on ℕ first<br>
    have hEqNat : (4 + (n + 5) : ℕ) = (n + 9 : ℕ) := by<br>
      -- both sides reduce to <code>n + 9</code><br>
      simp [Nat.add_left_comm]<br>
    have hEq :<br>
        (4 : Ordinal) + ((n : Ordinal) + 5) = (n : Ordinal) + 9 := by<br>
      calc<br>
        (4 : Ordinal) + ((n : Ordinal) + 5)<br>
            = (4 : Ordinal) + (((n + 5 : ℕ) : Ordinal)) := by<br>
                simp<br>
        _   = ((4 + (n + 5) : ℕ) : Ordinal) := by<br>
                simp<br>
        _   = ((n + 9 : ℕ) : Ordinal) := by<br>
                simpa using (congrArg (fun k : ℕ => (k : Ordinal)) hEqNat)<br>
        _   = (n : Ordinal) + 9 := by<br>
                simp<br>
    exact le_of_eq hEq<br>
  · -- infinite-or-larger case: the finite prefix on the left collapses<br>
    -- <code>5 ≤ 9</code> as ordinals<br>
    have h59 : (5 : Ordinal) ≤ (9 : Ordinal) := by<br>
      simpa using (natCast_le.mpr (by decide : (5 : ℕ) ≤ 9))<br>
    -- monotonicity in the right argument<br>
    have hR : p + 5 ≤ p + 9 := by<br>
      simpa using add_le_add_left h59 p<br>
    -- collapse <code>4 + p</code> since <code>ω ≤ p</code><br>
    have hcollapse : (4 : Ordinal) + (p + 5) = p + 5 := by<br>
      calc<br>
        (4 : Ordinal) + (p + 5)<br>
            = ((4 : Ordinal) + p) + 5 := by<br>
                simp [add_assoc]<br>
        _   = p + 5 := by<br>
                have h4 : (4 : Ordinal) + p = p := nat_left_add_absorb (n := 4) (p := p) hinf<br>
                rw [h4]<br>
    simpa [hcollapse] using hR<br>
<br>
theorem add_nat_succ_le_plus_succ (k : ℕ) (p : Ordinal) :<br>
  (k : Ordinal) + Order.succ p ≤ p + (k + 1) := by<br>
  rcases lt_or_ge p omega0 with hfin | hinf<br>
  · rcases (lt_omega0).1 hfin with ⟨n, rfl⟩<br>
    have hN : (k + (n + 1) : ℕ) = n + (k + 1) := by<br>
      simp [Nat.add_left_comm]<br>
    have h :<br>
        (k : Ordinal) + ((n : Ordinal) + 1) = (n : Ordinal) + (k + 1) := by<br>
      calc<br>
        (k : Ordinal) + ((n : Ordinal) + 1)<br>
            = ((k + (n + 1) : ℕ) : Ordinal) := by simp<br>
        _   = ((n + (k + 1) : ℕ) : Ordinal) := by<br>
              simpa using (congrArg (fun t : ℕ => (t : Ordinal)) hN)<br>
        _   = (n : Ordinal) + (k + 1) := by simp<br>
    have : (k : Ordinal) + Order.succ (n : Ordinal) = (n : Ordinal) + (k + 1) := by<br>
      simpa [Ordinal.add_one_eq_succ] using h<br>
    exact le_of_eq this<br>
  ·<br>
    have hk : (k : Ordinal) + p = p := nat_left_add_absorb (n := k) hinf<br>
    have hcollapse :<br>
        (k : Ordinal) + Order.succ p = Order.succ p := by<br>
      simpa [Ordinal.add_succ] using congrArg Order.succ hk<br>
    have hkNat : (1 : ℕ) ≤ k + 1 := Nat.succ_le_succ (Nat.zero_le k)<br>
    have h1k : (1 : Ordinal) ≤ (k + 1 : Ordinal) := by<br>
      simpa using (natCast_le.mpr hkNat)<br>
    have hstep0 : p + 1 ≤ p + (k + 1) := add_le_add_left h1k p<br>
    have hstep : Order.succ p ≤ p + (k + 1) := by<br>
      simpa [Ordinal.add_one_eq_succ] using hstep0<br>
    exact (le_of_eq hcollapse).trans hstep<br>
<br>
theorem add_nat_plus1_le_plus_succ (k : ℕ) (p : Ordinal) :<br>
  (k : Ordinal) + (p + 1) ≤ p + (k + 1) := by<br>
  simpa [Ordinal.add_one_eq_succ] using add_nat_succ_le_plus_succ k p<br>
<br>
theorem add3_succ_le_plus4 (p : Ordinal) :<br>
  (3 : Ordinal) + Order.succ p ≤ p + 4 := by<br>
  simpa using add_nat_succ_le_plus_succ 3 p<br>
<br>
theorem add2_succ_le_plus3 (p : Ordinal) :<br>
  (2 : Ordinal) + Order.succ p ≤ p + 3 := by<br>
  simpa using add_nat_succ_le_plus_succ 2 p<br>
<br>
theorem add3_plus1_le_plus4 (p : Ordinal) :<br>
  (3 : Ordinal) + (p + 1) ≤ p + 4 := by<br>
  simpa [Ordinal.add_one_eq_succ] using add3_succ_le_plus4 p<br>
<br>
theorem add2_plus1_le_plus3 (p : Ordinal) :<br>
  (2 : Ordinal) + (p + 1) ≤ p + 3 := by<br>
  simpa [Ordinal.add_one_eq_succ] using add2_succ_le_plus3 p<br>
<br>
theorem termA_le (x : Ordinal) :<br>
  (omega0 ^ (3 : Ordinal)) * (x + 1) ≤ omega0 ^ (x + 4) := by<br>
  have hx : x + 1 ≤ omega0 ^ (x + 1) := le_omega_pow (x := x + 1)<br>
  have hmul :<br>
      (omega0 ^ (3 : Ordinal)) * (x + 1)<br>
        ≤ (omega0 ^ (3 : Ordinal)) * (omega0 ^ (x + 1)) := by<br>
    simpa using (mul_le_mul_left' hx (omega0 ^ (3 : Ordinal)))<br>
  have hpow' :<br>
      (omega0 ^ (3 : Ordinal)) <em> (omega0 ^ x </em> omega0)<br>
        = omega0 ^ (3 + (x + 1)) := by<br>
    simpa [Ordinal.opow_succ, add_comm, add_left_comm, add_assoc] using<br>
      (Ordinal.opow_add omega0 (3 : Ordinal) (x + 1)).symm<br>
  have hmul' :<br>
      (omega0 ^ (3 : Ordinal)) * Order.succ x<br>
        ≤ omega0 ^ (3 + (x + 1)) := by<br>
    simpa [hpow', Ordinal.add_one_eq_succ] using hmul<br>
  have hexp : 3 + (x + 1) ≤ x + 4 := by<br>
    simpa [add_assoc, add_comm, add_left_comm] using add3_plus1_le_plus4 x<br>
  have hmono :<br>
      omega0 ^ (3 + (x + 1)) ≤ omega0 ^ (x + 4) := Ordinal.opow_le_opow_right (a := omega0) Ordinal.omega0_pos hexp<br>
  exact hmul'.trans hmono<br>
<br>
theorem termB_le (x : Ordinal) :<br>
  (omega0 ^ (2 : Ordinal)) * (x + 1) ≤ omega0 ^ (x + 3) := by<br>
  have hx : x + 1 ≤ omega0 ^ (x + 1) := le_omega_pow (x := x + 1)<br>
  have hmul :<br>
      (omega0 ^ (2 : Ordinal)) * (x + 1)<br>
        ≤ (omega0 ^ (2 : Ordinal)) * (omega0 ^ (x + 1)) := by<br>
    simpa using (mul_le_mul_left' hx (omega0 ^ (2 : Ordinal)))<br>
  have hpow' :<br>
      (omega0 ^ (2 : Ordinal)) <em> (omega0 ^ x </em> omega0)<br>
        = omega0 ^ (2 + (x + 1)) := by<br>
    simpa [Ordinal.opow_succ, add_comm, add_left_comm, add_assoc] using<br>
      (Ordinal.opow_add omega0 (2 : Ordinal) (x + 1)).symm<br>
  have hmul' :<br>
      (omega0 ^ (2 : Ordinal)) * Order.succ x<br>
        ≤ omega0 ^ (2 + (x + 1)) := by<br>
    simpa [hpow', Ordinal.add_one_eq_succ] using hmul<br>
  have hexp : 2 + (x + 1) ≤ x + 3 := by<br>
    simpa [add_assoc, add_comm, add_left_comm] using add2_plus1_le_plus3 x<br>
  have hmono :<br>
      omega0 ^ (2 + (x + 1)) ≤ omega0 ^ (x + 3) := Ordinal.opow_le_opow_right (a := omega0) Ordinal.omega0_pos hexp<br>
  exact hmul'.trans hmono<br>
<br>
<br>
theorem payload_bound_merge (x : Ordinal) :<br>
  (omega0 ^ (3 : Ordinal)) <em> (x + 1) + ((omega0 ^ (2 : Ordinal)) </em> (x + 1) + 1)<br>
    ≤ omega0 ^ (x + 5) := by<br>
  have hA : (omega0 ^ (3 : Ordinal)) * (x + 1) ≤ omega0 ^ (x + 4) := termA_le x<br>
  have hB0 : (omega0 ^ (2 : Ordinal)) * (x + 1) ≤ omega0 ^ (x + 3) := termB_le x<br>
  have h34 : (x + 3 : Ordinal) ≤ x + 4 := by<br>
    have : ((3 : ℕ) : Ordinal) ≤ (4 : ℕ) := by<br>
      simpa using (natCast_le.mpr (by decide : (3 : ℕ) ≤ 4))<br>
    simpa [add_comm, add_left_comm, add_assoc] using add_le_add_left this x<br>
  have hB : (omega0 ^ (2 : Ordinal)) * (x + 1) ≤ omega0 ^ (x + 4) :=<br>
    le_trans hB0 (Ordinal.opow_le_opow_right (a := omega0) Ordinal.omega0_pos h34)<br>
  have h1 : (1 : Ordinal) ≤ omega0 ^ (x + 4) := by<br>
    have h0 : (0 : Ordinal) ≤ x + 4 := zero_le _<br>
    have := Ordinal.opow_le_opow_right (a := omega0) Ordinal.omega0_pos h0<br>
    simpa [Ordinal.opow_zero] using this<br>
  have t1 : (omega0 ^ (2 : Ordinal)) * (x + 1) + 1 ≤ omega0 ^ (x + 4) + 1 := add_le_add_right hB 1<br>
  have t2 : omega0 ^ (x + 4) + 1 ≤ omega0 ^ (x + 4) + omega0 ^ (x + 4) := add_le_add_left h1 _<br>
<br>
  have hsum1 :<br>
      (omega0 ^ (2 : Ordinal)) * (x + 1) + 1 ≤ omega0 ^ (x + 4) + omega0 ^ (x + 4) :=<br>
    t1.trans t2<br>
  have hsum2 :<br>
      (omega0 ^ (3 : Ordinal)) <em> (x + 1) + ((omega0 ^ (2 : Ordinal)) </em> (x + 1) + 1)<br>
        ≤ omega0 ^ (x + 4) + (omega0 ^ (x + 4) + omega0 ^ (x + 4)) :=<br>
    add_le_add hA hsum1<br>
<br>
  set a : Ordinal := omega0 ^ (x + 4) with ha<br>
  have h2 : a <em> (2 : Ordinal) = a </em> (1 : Ordinal) + a := by<br>
    simpa using (mul_succ a (1 : Ordinal))<br>
  have h3step : a <em> (3 : Ordinal) = a </em> (2 : Ordinal) + a := by<br>
    simpa using (mul_succ a (2 : Ordinal))<br>
  have hthree' : a * (3 : Ordinal) = a + (a + a) := by<br>
    calc<br>
      a * (3 : Ordinal)<br>
          = a * (2 : Ordinal) + a := by simpa using h3step<br>
      _   = (a * (1 : Ordinal) + a) + a := by simpa [h2]<br>
      _   = (a + a) + a := by simp [mul_one]<br>
      _   = a + (a + a) := by simp [add_assoc]<br>
  have hsum3 :<br>
      omega0 ^ (x + 4) + (omega0 ^ (x + 4) + omega0 ^ (x + 4))<br>
        ≤ (omega0 ^ (x + 4)) * (3 : Ordinal) := by<br>
    have h := hthree'.symm<br>
    simpa [ha] using (le_of_eq h)<br>
<br>
  have h3ω : (3 : Ordinal) ≤ omega0 := by<br>
    exact le_of_lt (by simpa using (lt_omega0.2 ⟨3, rfl⟩))<br>
  have hlift :<br>
      (omega0 ^ (x + 4)) <em> (3 : Ordinal) ≤ (omega0 ^ (x + 4)) </em> omega0 := by<br>
    simpa using mul_le_mul_left' h3ω (omega0 ^ (x + 4))<br>
  have htow : (omega0 ^ (x + 4)) * omega0 = omega0 ^ (x + 5) := by<br>
    simpa [add_comm, add_left_comm, add_assoc]<br>
      using (Ordinal.opow_add omega0 (x + 4) (1 : Ordinal)).symm<br>
<br>
  exact hsum2.trans (hsum3.trans (by simpa [htow] using hlift))<br>
<br>
theorem payload_bound_merge_mu (a : Trace) :<br>
  (omega0 ^ (3 : Ordinal)) <em> (MetaSN.mu a + 1) + ((omega0 ^ (2 : Ordinal)) </em> (MetaSN.mu a + 1) + 1)<br>
    ≤ omega0 ^ (MetaSN.mu a + 5) := by<br>
  simpa using payload_bound_merge (MetaSN.mu a)<br>
<br>
-- (legacy name replaced) ensure single definition only<br>
-- theorem lt_add_one (x : Ordinal) : x < x + 1 := lt_add_one_of_le (le_rfl)<br>
theorem lt_add_one (x : Ordinal) : x < x + 1 :=<br>
  (Order.lt_add_one_iff (x := x) (y := x)).2 le_rfl<br>
<br>
theorem mul_succ (a b : Ordinal) : a <em> (b + 1) = a </em> b + a := by<br>
  simpa [mul_one, add_comm, add_left_comm, add_assoc] using<br>
    (mul_add a b (1 : Ordinal))<br>
<br>
theorem two_lt_mu_delta_add_six (n : Trace) :<br>
  (2 : Ordinal) < MetaSN.mu (.delta n) + 6 := by<br>
  have h2lt6 : (2 : Ordinal) < 6 := by<br>
    have : (2 : ℕ) < 6 := by decide<br>
    simpa using (natCast_lt).2 this<br>
  have h6le : (6 : Ordinal) ≤ MetaSN.mu (.delta n) + 6 := by<br>
    have hμ : (0 : Ordinal) ≤ MetaSN.mu (.delta n) := zero_le _<br>
    simpa [zero_add] using add_le_add_right hμ (6 : Ordinal)<br>
  exact lt_of_lt_of_le h2lt6 h6le<br>
<br>
private theorem pow2_le_A {n : Trace} {A : Ordinal}<br>
    (hA : A = omega0 ^ (MetaSN.mu (Trace.delta n) + 6)) :<br>
    (omega0 ^ (2 : Ordinal)) ≤ A := by<br>
  have h : (2 : Ordinal) ≤ MetaSN.mu (Trace.delta n) + 6 :=<br>
    le_of_lt (two_lt_mu_delta_add_six n)<br>
  simpa [hA] using Ordinal.opow_le_opow_right omega0_pos h<br>
<br>
private theorem omega_le_A {n : Trace} {A : Ordinal}<br>
    (hA : A = omega0 ^ (MetaSN.mu (Trace.delta n) + 6)) :<br>
    (omega0 : Ordinal) ≤ A := by<br>
  have pos : (0 : Ordinal) < MetaSN.mu (Trace.delta n) + 6 :=<br>
    lt_of_le_of_lt (bot_le) (two_lt_mu_delta_add_six n)<br>
  simpa [hA] using Ordinal.left_le_opow (a := omega0) (b := MetaSN.mu (Trace.delta n) + 6) pos<br>
<br>
--- not used---<br>
private theorem head_plus_tail_le {b s n : Trace}<br>
    {A B : Ordinal}<br>
    (tail_le_A :<br>
      (omega0 ^ (2 : Ordinal)) * (MetaSN.mu (Trace.recΔ b s n) + 1) + 1 ≤ A)<br>
    (Apos : 0 < A) :<br>
    B + ((omega0 ^ (2 : Ordinal)) * (MetaSN.mu (Trace.recΔ b s n) + 1) + 1) ≤<br>
      A * (B + 1) := by<br>
  -- 1 ▸ <code>B ≤ A * B</code>  (since <code>A > 0</code>)<br>
  have B_le_AB : B ≤ A * B :=<br>
    le_mul_right (a := B) (b := A) Apos<br>
<br>
  have hsum :<br>
      B + ((omega0 ^ (2 : Ordinal)) * (MetaSN.mu (Trace.recΔ b s n) + 1) + 1) ≤<br>
        A * B + A :=<br>
<br>
    add_le_add B_le_AB tail_le_A<br>
<br>
  have head_dist : A <em> (B + 1) = A </em> B + A := by<br>
    simpa using mul_succ A B       -- <code>a <em> (b+1) = a </em> b + a</code><br>
<br>
  rw [head_dist]; exact hsum<br>
<br>
<br>
/-- <strong>Strict</strong> monotone: <code>b < c → ω^b < ω^c</code>. -/<br>
theorem opow_lt_opow_ω {b c : Ordinal} (h : b < c) :<br>
    omega0 ^ b < omega0 ^ c := by<br>
  simpa using<br>
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)<br>
<br>
theorem opow_le_opow_ω {p q : Ordinal} (h : p ≤ q) :<br>
    omega0 ^ p ≤ omega0 ^ q := by<br>
  exact Ordinal.opow_le_opow_right omega0_pos h   -- library lemma<br>
<br>
theorem three_lt_mu_delta (n : Trace) :<br>
    (3 : Ordinal) < MetaSN.mu (delta n) + 6 := by<br>
  have : (3 : ℕ) < 6 := by decide<br>
  have h₃₆ : (3 : Ordinal) < 6 := by<br>
    simpa using (Nat.cast_lt).2 this<br>
  have hμ : (0 : Ordinal) ≤ MetaSN.mu (delta n) := Ordinal.zero_le _<br>
  have h₆ : (6 : Ordinal) ≤ MetaSN.mu (delta n) + 6 :=<br>
    le_add_of_nonneg_left (a := (6 : Ordinal)) hμ<br>
  exact lt_of_lt_of_le h₃₆ h₆<br>
<br>
theorem w3_lt_A (s n : Trace) :<br>
  omega0 ^ (3 : Ordinal) < omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) := by<br>
<br>
  have h₁ : (3 : Ordinal) < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
    -- 1a  finite part   3 < 6<br>
    have h3_lt_6 : (3 : Ordinal) < 6 := by<br>
      simpa using (natCast_lt).2 (by decide : (3 : ℕ) < 6)<br>
    -- 1b  padding       6 ≤ μ(δ n) + μ s + 6<br>
    have h6_le : (6 : Ordinal) ≤ MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
      -- non-negativity of the middle block<br>
      have hμ : (0 : Ordinal) ≤ MetaSN.mu (delta n) + MetaSN.mu s := by<br>
        have hδ : (0 : Ordinal) ≤ MetaSN.mu (delta n) := Ordinal.zero_le _<br>
        have hs : (0 : Ordinal) ≤ MetaSN.mu s         := Ordinal.zero_le _<br>
        -- 0 + 0 ≤ μ(δ n) + μ s<br>
        simpa [zero_add] using add_le_add hδ hs<br>
      -- 6 ≤ (μ(δ n)+μ s) + 6<br>
      have : (6 : Ordinal) ≤ (MetaSN.mu (delta n) + MetaSN.mu s) + 6 :=<br>
        le_add_of_nonneg_left hμ<br>
      -- reassociate to <code>μ(δ n)+μ s+6</code><br>
      simpa [add_comm, add_left_comm, add_assoc] using this<br>
    exact lt_of_lt_of_le h3_lt_6 h6_le<br>
<br>
  exact opow_lt_opow_right h₁<br>
<br>
theorem coeff_lt_A (s n : Trace) :<br>
    MetaSN.mu s + 1 < omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 3) := by<br>
  have h₁ : MetaSN.mu s + 1 < MetaSN.mu s + 3 := by<br>
    have h_nat : (1 : Ordinal) < 3 := by<br>
      norm_num<br>
    simpa using (add_lt_add_left h_nat (MetaSN.mu s))<br>
<br>
  have h₂ : MetaSN.mu s + 3 ≤ MetaSN.mu (delta n) + MetaSN.mu s + 3 := by<br>
    have hμ : (0 : Ordinal) ≤ MetaSN.mu (delta n) := Ordinal.zero_le _<br>
    have h_le : (MetaSN.mu s) ≤ MetaSN.mu (delta n) + MetaSN.mu s :=<br>
      (le_add_of_nonneg_left hμ)<br>
    simpa [add_comm, add_left_comm, add_assoc]<br>
      using add_le_add_right h_le 3<br>
<br>
  have h_chain : MetaSN.mu s + 1 < MetaSN.mu (delta n) + MetaSN.mu s + 3 :=<br>
    lt_of_lt_of_le h₁ h₂<br>
<br>
  have h_big : MetaSN.mu (delta n) + MetaSN.mu s + 3 ≤<br>
               omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 3) :=<br>
    le_omega_pow (x := MetaSN.mu (delta n) + MetaSN.mu s + 3)<br>
<br>
  exact lt_of_lt_of_le h_chain h_big<br>
<br>
theorem head_lt_A (s n : Trace) :<br>
  let A : Ordinal := omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6);<br>
  omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) < A := by<br>
  intro A<br>
<br>
  have h₁ : omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) ≤<br>
            omega0 ^ (MetaSN.mu s + 4) := termA_le (x := MetaSN.mu s)<br>
<br>
<br>
  have h_left : MetaSN.mu s + 4 < MetaSN.mu s + 6 := by<br>
    have : (4 : Ordinal) < 6 := by<br>
      simpa using (natCast_lt).2 (by decide : (4 : ℕ) < 6)<br>
    simpa using (add_lt_add_left this (MetaSN.mu s))<br>
<br>
  -- 2b  insert <code>μ δ n</code> on the left using monotonicity<br>
  have h_pad : MetaSN.mu s + 6 ≤ MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
    -- 0 ≤ μ δ n<br>
    have hμ : (0 : Ordinal) ≤ MetaSN.mu (delta n) := Ordinal.zero_le _<br>
    -- μ s ≤ μ δ n + μ s<br>
    have h₀ : (MetaSN.mu s) ≤ MetaSN.mu (delta n) + MetaSN.mu s :=<br>
      le_add_of_nonneg_left hμ<br>
    -- add the finite 6 to both sides<br>
    have h₀' : MetaSN.mu s + 6 ≤ (MetaSN.mu (delta n) + MetaSN.mu s) + 6 :=<br>
      add_le_add_right h₀ 6<br>
    simpa [add_comm, add_left_comm, add_assoc] using h₀'<br>
<br>
  -- 2c  combine<br>
  have h_exp : MetaSN.mu s + 4 < MetaSN.mu (delta n) + MetaSN.mu s + 6 :=<br>
    lt_of_lt_of_le h_left h_pad<br>
<br>
<br>
  have h₂ : omega0 ^ (MetaSN.mu s + 4) <<br>
            omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) := opow_lt_opow_right h_exp<br>
<br>
  have h_final :<br>
      omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) <<br>
      omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) := lt_of_le_of_lt h₁ h₂<br>
<br>
  simpa [A] using h_final<br>
<br>
<br>
private lemma two_lt_three : (2 : Ordinal) < 3 := by<br>
  have : (2 : ℕ) < 3 := by decide<br>
  simpa using (Nat.cast_lt).2 this<br>
<br>
<br>
<br>
@[simp] theorem opow_mul_lt_of_exp_lt<br>
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :<br>
    omega0 ^ β * γ < omega0 ^ α := by<br>
<br>
  have hpos : (0 : Ordinal) < omega0 ^ β :=<br>
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos<br>
  have h₁ : omega0 ^ β <em> γ < omega0 ^ β </em> omega0 :=<br>
    Ordinal.mul_lt_mul_of_pos_left hγ hpos<br>
<br>
<br>
  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by<br>
    simpa [Ordinal.opow_add] using (Ordinal.opow_add omega0 β 1).symm<br>
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by<br>
    simpa [h_eq, -opow_succ] using h₁<br>
<br>
<br>
  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead<br>
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=<br>
    opow_le_opow_right (a := omega0) omega0_pos h_exp<br>
<br>
<br>
  exact lt_of_lt_of_le h₁' h₂<br>
<br>
<br>
lemma omega_pow_add_lt<br>
    {κ α β : Ordinal} (_ : 0 < κ)<br>
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :<br>
    α + β < omega0 ^ κ := by<br>
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=<br>
    Ordinal.principal_add_omega0_opow κ<br>
  exact hprin hα hβ<br>
<br>
<br>
lemma omega_pow_add3_lt<br>
    {κ α β γ : Ordinal} (hκ : 0 < κ)<br>
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :<br>
    α + β + γ < omega0 ^ κ := by<br>
  have hsum : α + β < omega0 ^ κ :=<br>
    omega_pow_add_lt hκ hα hβ<br>
  have hsum' : α + β + γ < omega0 ^ κ :=<br>
    omega_pow_add_lt hκ (by simpa using hsum) hγ<br>
  simpa [add_assoc] using hsum'<br>
<br>
<br>
<br>
@[simp] lemma add_one_lt_omega0 (k : ℕ) :<br>
    ((k : Ordinal) + 1) < omega0 := by<br>
  -- <code>k.succ < ω</code><br>
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by<br>
    simpa using (nat_lt_omega0 k.succ)<br>
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,<br>
         add_one_eq_succ] using this<br>
<br>
@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=<br>
  (le_of_lt (by<br>
    have : ((1 : ℕ) : Ordinal) < omega0 := by<br>
      simpa using (nat_lt_omega0 1)<br>
    simpa using this))<br>
<br>
<br>
lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}<br>
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)<br>
    : a + c ≤ b + c :=<br>
  add_le_add_right h c<br>
<br>
@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by<br>
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one<br>
  simpa [Order.succ] using this<br>
<br>
alias le_of_not_gt := le_of_not_lt<br>
<br>
attribute [simp] Ordinal.IsNormal.strictMono<br>
<br>
-- Helper lemma for positivity arguments in ordinal arithmetic<br>
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num<br>
<br>
-- Helper for successor positivity<br>
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by<br>
  -- Order.succ a = a + 1, and we need 0 < a + 1<br>
  -- This is true because 0 < 1 and a ≥ 0<br>
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a<br>
  have h2 : (0 : Ordinal) < 1 := zero_lt_one<br>
  -- Since Order.succ a = a + 1<br>
  rw [Order.succ]<br>
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1<br>
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)<br>
<br>
-- duplicate succ_succ removed (defined earlier)<br>
<br>
<br>
<br>
@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :<br>
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by<br>
  constructor<br>
  · intro hlt<br>
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a<br>
    have hle : b ≤ a := le_of_not_gt hnb<br>
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle<br>
    exact (not_le_of_gt hlt) hle'<br>
  · intro hlt<br>
    exact opow_lt_opow_ω hlt<br>
<br>
@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :<br>
    a ≤ a + c := by<br>
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc<br>
  simpa using (le_add_of_nonneg_right (a := a) hc')<br>
<br>
<br>
/--  The "tail" payload sits strictly below the big tower <code>A</code>. -/<br>
lemma tail_lt_A {b s n : Trace}<br>
  (h_mu_recΔ_bound : omega0 ^ (MetaSN.mu n + MetaSN.mu s + (6 : Ordinal)) + omega0 * (MetaSN.mu b + 1) + 1 + 3 <<br>
                     (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 + MetaSN.mu s + 6) :<br>
    let A : Ordinal := omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6)<br>
    omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) < A := by<br>
  intro A<br>
  -- Don't define α separately - just use the expression directly<br>
<br>
  ---------------------------------------------------------------- 1<br>
  --  ω²·(μ(recΔ)+1) ≤ ω^(μ(recΔ)+3)<br>
  have h₁ : omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) ≤<br>
            omega0 ^ (MetaSN.mu (recΔ b s n) + 3) :=<br>
    termB_le _<br>
<br>
  ---------------------------------------------------------------- 2<br>
  --  μ(recΔ) + 3 < μ(δn) + μs + 6 (key exponent inequality)<br>
  have hμ : MetaSN.mu (recΔ b s n) + 3 < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
    -- Use the parameterized lemma with the ordinal domination assumption<br>
    exact mu_recDelta_plus_3_lt b s n h_mu_recΔ_bound<br>
<br>
  --  Therefore exponent inequality:<br>
  have h₂ : MetaSN.mu (recΔ b s n) + 3 < MetaSN.mu (delta n) + MetaSN.mu s + 6 := hμ<br>
<br>
  --  Now lift through ω-powers using strict monotonicity<br>
  have h₃ : omega0 ^ (MetaSN.mu (recΔ b s n) + 3) < omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) :=<br>
    opow_lt_opow_right h₂<br>
<br>
  ---------------------------------------------------------------- 3<br>
  --  The final chaining: combine termB_le with the exponent inequality<br>
  have h_final : omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) <<br>
                 omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) :=<br>
    lt_of_le_of_lt h₁ h₃<br>
<br>
  ---------------------------------------------------------------- 4<br>
  --  This is exactly what we needed to prove<br>
  exact h_final<br>
<br>
<br>
<br>
lemma mu_merge_lt_rec {b s n : Trace}<br>
  (h_mu_recΔ_bound : omega0 ^ (MetaSN.mu n + MetaSN.mu s + (6 : Ordinal)) + omega0 * (MetaSN.mu b + 1) + 1 + 3 <<br>
                     (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 + MetaSN.mu s + 6) :<br>
  MetaSN.mu (merge s (recΔ b s n)) < MetaSN.mu (recΔ b s (delta n)) := by<br>
  -- rename the dominant tower once and for all<br>
  set A : Ordinal := omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) with hA<br>
  -- ❶  head        (ω³ payload)  < A<br>
  have h_head : omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) < A := by<br>
    simpa [hA] using head_lt_A s n<br>
  -- ❷  tail        (ω² payload)  < A  (new lemma)<br>
  have h_tail : omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) < A := by<br>
    simpa [hA] using tail_lt_A (b := b) (s := s) (n := n) h_mu_recΔ_bound<br>
  -- ❸  sum of head + tail + 1 < A.<br>
  have h_sum :<br>
      omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) +<br>
      (omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) + 1) < A := by<br>
    -- First fold inner <code>tail+1</code> under A.<br>
    have h_tail1 :<br>
        omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) + 1 < A :=<br>
<br>
      omega_pow_add_lt (by<br>
        -- Prove positivity of exponent<br>
        have : (0 : Ordinal) < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
          -- Simple positivity: 0 < 6 ≤ μ(δn) + μs + 6<br>
          have h6_pos : (0 : Ordinal) < 6 := by norm_num<br>
          exact lt_of_lt_of_le h6_pos (le_add_left 6 (MetaSN.mu (delta n) + MetaSN.mu s))<br>
        exact this) h_tail (by<br>
        -- <code>1 < A</code> trivially (tower is non‑zero)<br>
        have : (1 : Ordinal) < A := by<br>
          have hpos : (0 : Ordinal) < A := by<br>
            rw [hA]<br>
            exact Ordinal.opow_pos (b := MetaSN.mu (delta n) + MetaSN.mu s + 6) (a0 := omega0_pos)<br>
          -- We need 1 < A. We have 0 < A and 1 ≤ ω, and we need ω ≤ A<br>
          have omega_le_A : omega0 ≤ A := by<br>
            rw [hA]<br>
            -- Need to show MetaSN.mu (delta n) + MetaSN.mu s + 6 > 0<br>
            have hpos : (0 : Ordinal) < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
              -- Positivity: μ(δn) + μs + 6 ≥ 6 > 0<br>
              have h6_pos : (0 : Ordinal) < 6 := by norm_num<br>
              exact lt_of_lt_of_le h6_pos (le_add_left 6 (MetaSN.mu (delta n) + MetaSN.mu s))<br>
            exact Ordinal.left_le_opow (a := omega0) (b := MetaSN.mu (delta n) + MetaSN.mu s + 6) hpos<br>
          -- Need to show 1 < A. We have 1 ≤ ω ≤ A, so 1 ≤ A. We need strict.<br>
          -- Since A = ω^(μ(δn) + μs + 6) and the exponent > 0, we have ω < A<br>
          have omega_lt_A : omega0 < A := by<br>
            rw [hA]<br>
            -- Use the fact that ω < ω^k when k > 1<br>
            have : (1 : Ordinal) < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
              -- Positivity: μ(δn) + μs + 6 ≥ 6 > 1<br>
              have h6_gt_1 : (1 : Ordinal) < 6 := by norm_num<br>
              exact lt_of_lt_of_le h6_gt_1 (le_add_left 6 (MetaSN.mu (delta n) + MetaSN.mu s))<br>
            have : omega0 ^ (1 : Ordinal) < omega0 ^ (MetaSN.mu (delta n) + MetaSN.mu s + 6) :=<br>
              opow_lt_opow_right this<br>
            simpa using this<br>
          exact lt_of_le_of_lt one_le_omega0 omega_lt_A<br>
        exact this)<br>
    -- Then fold head + (tail+1).<br>
    have h_fold := omega_pow_add_lt (by<br>
        -- Same positivity proof<br>
        have : (0 : Ordinal) < MetaSN.mu (delta n) + MetaSN.mu s + 6 := by<br>
          -- Simple positivity: 0 < 6 ≤ μ(δn) + μs + 6<br>
          have h6_pos : (0 : Ordinal) < 6 := by norm_num<br>
          exact lt_of_lt_of_le h6_pos (le_add_left 6 (MetaSN.mu (delta n) + MetaSN.mu s))<br>
        exact this) h_head h_tail1<br>
    -- Need to massage the associativity to match expected form<br>
    have : omega0 ^ (3 : Ordinal) <em> (MetaSN.mu s + 1) + (omega0 ^ (2 : Ordinal) </em> (MetaSN.mu (recΔ b s n) + 1) + 1) < A := by<br>
      -- h_fold has type: ω^3 <em> (μa + 1) + (ω^2 </em> (μb + 1) + 1) < ω^(μ(δn) + μs + 6)<br>
      -- A = ω^(μ(δn) + μs + 6) by definition<br>
      rw [hA]<br>
      exact h_fold<br>
    exact this<br>
  -- ❹  RHS is   A + ω·… + 1  >  A  >  LHS.<br>
  have h_rhs_gt_A : A < MetaSN.mu (recΔ b s (delta n)) := by<br>
    -- by definition of μ(recΔ … (δ n)) (see new μ)<br>
    have : A < A + omega0 * (MetaSN.mu b + 1) + 1 := by<br>
      have hpos : (0 : Ordinal) < omega0 * (MetaSN.mu b + 1) + 1 := by<br>
        -- ω*(μb + 1) + 1 ≥ 1 > 0<br>
        have h1_pos : (0 : Ordinal) < 1 := by norm_num<br>
        exact lt_of_lt_of_le h1_pos (le_add_left 1 (omega0 * (MetaSN.mu b + 1)))<br>
      -- A + (ω·(μb + 1) + 1) = (A + ω·(μb + 1)) + 1<br>
      have : A + omega0 <em> (MetaSN.mu b + 1) + 1 = A + (omega0 </em> (MetaSN.mu b + 1) + 1) := by<br>
        simp [add_assoc]<br>
      rw [this]<br>
      exact lt_add_of_pos_right A hpos<br>
    rw [hA]<br>
    exact this<br>
  -- ❺  chain inequalities.<br>
  have : MetaSN.mu (merge s (recΔ b s n)) < A := by<br>
    -- rewrite μ(merge …) exactly and apply <code>h_sum</code><br>
    have eq_mu : MetaSN.mu (merge s (recΔ b s n)) =<br>
        omega0 ^ (3 : Ordinal) * (MetaSN.mu s + 1) +<br>
        (omega0 ^ (2 : Ordinal) * (MetaSN.mu (recΔ b s n) + 1) + 1) := by<br>
      -- MetaSN.mu (merge a b) = ω³ <em> (μa + 1) + ω² </em> (μb + 1) + 1<br>
      -- This is the definition of mu for merge, but the pattern matching<br>
      -- makes rfl difficult. The issue is associativity: (a + b) + c vs a + (b + c)<br>
      simp only [mu, add_assoc]<br>
    rw [eq_mu]<br>
    exact h_sum<br>
  exact lt_trans this h_rhs_gt_A<br>
<br>
@[simp] lemma mu_lt_rec_succ (b s n : Trace)<br>
  (h_mu_recΔ_bound : omega0 ^ (MetaSN.mu n + MetaSN.mu s + (6 : Ordinal)) + omega0 * (MetaSN.mu b + 1) + 1 + 3 <<br>
                     (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 + MetaSN.mu s + 6) :<br>
  MetaSN.mu (merge s (recΔ b s n)) < MetaSN.mu (recΔ b s (delta n)) := by<br>
  simpa using mu_merge_lt_rec h_mu_recΔ_bound<br>
<br>
/-- Helper: lift mu-strict decrease to lexicographic order when kappa is unchanged -/<br>
lemma μ_to_μκ {t t' : Trace} (h : mu t' < mu t) (hk : kappa t' = kappa t) :<br>
  LexNatOrd (μκ t') (μκ t) := by<br>
  unfold LexNatOrd μκ<br>
  rw [hk]<br>
  apply Prod.Lex.right<br>
  exact h<br>
<br>
/-- Lexicographic decrease for R_rec_succ: kappa strictly decreases -/<br>
lemma μκ_lt_R_rec_succ (b s n : Trace) :<br>
  LexNatOrd (μκ (merge s (recΔ b s n))) (μκ (recΔ b s (delta n))) := by<br>
  unfold LexNatOrd μκ<br>
  apply Prod.Lex.left<br>
  simp [kappa]<br>
<br>
/-- Any non-void trace has <code>μ ≥ ω</code>.  Exhaustive on constructors. -/<br>
private theorem nonvoid_mu_ge_omega {t : Trace} (h : t ≠ .void) :<br>
    omega0 ≤ MetaSN.mu t := by<br>
  cases t with<br>
  | void        => exact (h rfl).elim<br>
<br>
  | delta s =><br>
      -- ω ≤ ω⁵ ≤ ω⁵·(μ s + 1) + 1<br>
      have hω_pow : omega0 ≤ omega0 ^ (5 : Ordinal) := by<br>
        simpa [Ordinal.opow_one] using<br>
          Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ 5)<br>
      have h_one_le : (1 : Ordinal) ≤ MetaSN.mu s + 1 := by<br>
        have : (0 : Ordinal) ≤ MetaSN.mu s := zero_le _<br>
        simpa [zero_add] using add_le_add_right this 1<br>
      have hmul :<br>
          omega0 ^ (5 : Ordinal) ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu s + 1) := by<br>
        simpa [mul_one] using<br>
          mul_le_mul_left' h_one_le (omega0 ^ (5 : Ordinal))<br>
      have : omega0 ≤ MetaSN.mu (.delta s) := by<br>
        calc<br>
          omega0 ≤ omega0 ^ (5 : Ordinal) := hω_pow<br>
          _      ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu s + 1) := hmul<br>
          _      ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu s + 1) + 1 :=<br>
                   le_add_of_nonneg_right (show (0 : Ordinal) ≤ 1 by<br>
                     simpa using zero_le_one)<br>
          _      = MetaSN.mu (.delta s) := by simp [MetaSN.mu]<br>
      simpa [MetaSN.mu, add_comm, add_left_comm, add_assoc] using this<br>
<br>
  | integrate s =><br>
      -- ω ≤ ω⁴ ≤ ω⁴·(μ s + 1) + 1<br>
      have hω_pow : omega0 ≤ omega0 ^ (4 : Ordinal) := by<br>
        simpa [Ordinal.opow_one] using<br>
          Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ 4)<br>
      have h_one_le : (1 : Ordinal) ≤ MetaSN.mu s + 1 := by<br>
        have : (0 : Ordinal) ≤ MetaSN.mu s := zero_le _<br>
        simpa [zero_add] using add_le_add_right this 1<br>
      have hmul :<br>
          omega0 ^ (4 : Ordinal) ≤ (omega0 ^ (4 : Ordinal)) * (MetaSN.mu s + 1) := by<br>
        simpa [mul_one] using<br>
          mul_le_mul_left' h_one_le (omega0 ^ (4 : Ordinal))<br>
      have : omega0 ≤ MetaSN.mu (.integrate s) := by<br>
        calc<br>
          omega0 ≤ omega0 ^ (4 : Ordinal) := hω_pow<br>
          _      ≤ (omega0 ^ (4 : Ordinal)) * (MetaSN.mu s + 1) := hmul<br>
          _      ≤ (omega0 ^ (4 : Ordinal)) * (MetaSN.mu s + 1) + 1 :=<br>
                   le_add_of_nonneg_right (zero_le _)<br>
          _      = MetaSN.mu (.integrate s) := by simp [MetaSN.mu]<br>
      simpa [MetaSN.mu, add_comm, add_left_comm, add_assoc] using this<br>
<br>
  | merge a b =><br>
      -- ω ≤ ω² ≤ ω²·(μ b + 1) ≤ μ(merge a b)<br>
      have hω_pow : omega0 ≤ omega0 ^ (2 : Ordinal) := by<br>
        simpa [Ordinal.opow_one] using<br>
          Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ 2)<br>
      have h_one_le : (1 : Ordinal) ≤ MetaSN.mu b + 1 := by<br>
        have : (0 : Ordinal) ≤ MetaSN.mu b := zero_le _<br>
        simpa [zero_add] using add_le_add_right this 1<br>
      have hmul :<br>
          omega0 ^ (2 : Ordinal) ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) := by<br>
        simpa [mul_one] using<br>
          mul_le_mul_left' h_one_le (omega0 ^ (2 : Ordinal))<br>
      have h_mid :<br>
          omega0 ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 1 := by<br>
        calc<br>
          omega0 ≤ omega0 ^ (2 : Ordinal) := hω_pow<br>
          _      ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) := hmul<br>
          _      ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 1 :=<br>
                   le_add_of_nonneg_right (zero_le _)<br>
      have : omega0 ≤ MetaSN.mu (.merge a b) := by<br>
        have h_expand : (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 1 ≤<br>
                        (omega0 ^ (3 : Ordinal)) <em> (MetaSN.mu a + 1) + (omega0 ^ (2 : Ordinal)) </em> (MetaSN.mu b + 1) + 1 := by<br>
          -- Goal: ω^2<em>(μb+1)+1 ≤ ω^3</em>(μa+1) + ω^2*(μb+1) + 1<br>
          -- Use add_assoc to change RHS from a+(b+c) to (a+b)+c<br>
          rw [add_assoc]<br>
          exact Ordinal.le_add_left ((omega0 ^ (2 : Ordinal)) <em> (MetaSN.mu b + 1) + 1) ((omega0 ^ (3 : Ordinal)) </em> (MetaSN.mu a + 1))<br>
        calc<br>
          omega0 ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 1 := h_mid<br>
          _      ≤ (omega0 ^ (3 : Ordinal)) <em> (MetaSN.mu a + 1) + (omega0 ^ (2 : Ordinal)) </em> (MetaSN.mu b + 1) + 1 := h_expand<br>
          _      = MetaSN.mu (.merge a b) := by simp [MetaSN.mu]<br>
      simpa [MetaSN.mu, add_comm, add_left_comm, add_assoc] using this<br>
<br>
  | recΔ b s n =><br>
      -- ω ≤ ω^(μ n + μ s + 6) ≤ μ(recΔ b s n)<br>
      have six_le : (6 : Ordinal) ≤ MetaSN.mu n + MetaSN.mu s + 6 := by<br>
        have h1 : (0 : Ordinal) ≤ MetaSN.mu n := zero_le _<br>
        have h2 : (0 : Ordinal) ≤ MetaSN.mu s := zero_le _<br>
        have hsum : (0 : Ordinal) ≤ MetaSN.mu n + MetaSN.mu s := by<br>
          simpa [zero_add] using add_le_add h1 h2<br>
        simpa [add_comm, add_left_comm, add_assoc] using<br>
          add_le_add_right hsum 6<br>
      have one_le : (1 : Ordinal) ≤ MetaSN.mu n + MetaSN.mu s + 6 :=<br>
        le_trans (by norm_num) six_le<br>
      have hω_pow : omega0 ≤ omega0 ^ (MetaSN.mu n + MetaSN.mu s + 6) := by<br>
        simpa [Ordinal.opow_one] using<br>
          Ordinal.opow_le_opow_right omega0_pos one_le<br>
      have : omega0 ≤ MetaSN.mu (.recΔ b s n) := by<br>
        calc<br>
          omega0 ≤ omega0 ^ (MetaSN.mu n + MetaSN.mu s + 6) := hω_pow<br>
          _      ≤ omega0 ^ (MetaSN.mu n + MetaSN.mu s + 6) + omega0 * (MetaSN.mu b + 1) :=<br>
                   le_add_of_nonneg_right (zero_le _)<br>
          _      ≤ omega0 ^ (MetaSN.mu n + MetaSN.mu s + 6) + omega0 * (MetaSN.mu b + 1) + 1 :=<br>
                   le_add_of_nonneg_right (zero_le _)<br>
          _      = MetaSN.mu (.recΔ b s n) := by simp [MetaSN.mu]<br>
      simpa [MetaSN.mu, add_comm, add_left_comm, add_assoc] using this<br>
<br>
  | eqW a b =><br>
      -- ω ≤ ω^(μ a + μ b + 9) ≤ μ(eqW a b)<br>
      have nine_le : (9 : Ordinal) ≤ MetaSN.mu a + MetaSN.mu b + 9 := by<br>
        have h1 : (0 : Ordinal) ≤ MetaSN.mu a := zero_le _<br>
        have h2 : (0 : Ordinal) ≤ MetaSN.mu b := zero_le _<br>
        have hsum : (0 : Ordinal) ≤ MetaSN.mu a + MetaSN.mu b := by<br>
          simpa [zero_add] using add_le_add h1 h2<br>
        simpa [add_comm, add_left_comm, add_assoc] using<br>
          add_le_add_right hsum 9<br>
      have one_le : (1 : Ordinal) ≤ MetaSN.mu a + MetaSN.mu b + 9 :=<br>
        le_trans (by norm_num) nine_le<br>
      have hω_pow : omega0 ≤ omega0 ^ (MetaSN.mu a + MetaSN.mu b + 9) := by<br>
        simpa [Ordinal.opow_one] using<br>
          Ordinal.opow_le_opow_right omega0_pos one_le<br>
      have : omega0 ≤ MetaSN.mu (.eqW a b) := by<br>
        calc<br>
          omega0 ≤ omega0 ^ (MetaSN.mu a + MetaSN.mu b + 9) := hω_pow<br>
          _      ≤ omega0 ^ (MetaSN.mu a + MetaSN.mu b + 9) + 1 :=<br>
                   le_add_of_nonneg_right (zero_le _)<br>
          _      = MetaSN.mu (.eqW a b) := by simp [MetaSN.mu]<br>
      simpa [MetaSN.mu, add_comm, add_left_comm, add_assoc] using this<br>
<br>
<br>
/-- If <code>a</code> and <code>b</code> are <strong>not</strong> both <code>void</code>, then <code>ω ≤ μ a + μ b</code>. -/<br>
theorem mu_sum_ge_omega_of_not_both_void<br>
    {a b : Trace} (h : ¬ (a = .void ∧ b = .void)) :<br>
    omega0 ≤ MetaSN.mu a + MetaSN.mu b := by<br>
  have h_cases : a ≠ .void ∨ b ≠ .void := by<br>
    by_contra hcontra; push_neg at hcontra; exact h hcontra<br>
  cases h_cases with<br>
  | inl ha =><br>
      have : omega0 ≤ MetaSN.mu a := nonvoid_mu_ge_omega ha<br>
      have : omega0 ≤ MetaSN.mu a + MetaSN.mu b :=<br>
        le_trans this (le_add_of_nonneg_right (zero_le _))<br>
      exact this<br>
  | inr hb =><br>
      have : omega0 ≤ MetaSN.mu b := nonvoid_mu_ge_omega hb<br>
      have : omega0 ≤ MetaSN.mu a + MetaSN.mu b :=<br>
        le_trans this (le_add_of_nonneg_left (zero_le _))<br>
      exact this<br>
<br>
/-- Inner bound used by <code>mu_lt_eq_diff</code>. Let <code>C = μ a + μ b</code>. Then <code>μ (merge a b) + 1 < ω^(C + 5)</code>. -/<br>
private theorem merge_inner_bound_simple (a b : Trace) :<br>
  let C : Ordinal.{0} := MetaSN.mu a + MetaSN.mu b;<br>
  MetaSN.mu (merge a b) + 1 < omega0 ^ (C + 5) := by<br>
  intro C<br>
  -- head and tail bounds<br>
  have h_head : (omega0 ^ (3 : Ordinal)) * (MetaSN.mu a + 1) ≤ omega0 ^ (MetaSN.mu a + 4) := MetaSN.termA_le (x := MetaSN.mu a)<br>
  have h_tail : (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) ≤ omega0 ^ (MetaSN.mu b + 3) := MetaSN.termB_le (x := MetaSN.mu b)<br>
  -- each exponent is strictly less than C+5<br>
  have h_exp1 : MetaSN.mu a + 4 < C + 5 := by<br>
    have h1 : MetaSN.mu a ≤ C := Ordinal.le_add_right _ _<br>
    have h2 : MetaSN.mu a + 4 ≤ C + 4 := add_le_add_right h1 4<br>
    have h3 : C + 4 < C + 5 := add_lt_add_left (by norm_num : (4 : Ordinal) < 5) C<br>
    exact lt_of_le_of_lt h2 h3<br>
  have h_exp2 : MetaSN.mu b + 3 < C + 5 := by<br>
    have h1 : MetaSN.mu b ≤ C := Ordinal.le_add_left (MetaSN.mu b) (MetaSN.mu a)<br>
    have h2 : MetaSN.mu b + 3 ≤ C + 3 := add_le_add_right h1 3<br>
    have h3 : C + 3 < C + 5 := add_lt_add_left (by norm_num : (3 : Ordinal) < 5) C<br>
    exact lt_of_le_of_lt h2 h3<br>
  -- use monotonicity of opow<br>
  have h1_pow : omega0 ^ (3 : Ordinal) * (MetaSN.mu a + 1) < omega0 ^ (C + 5) := by<br>
    calc (omega0 ^ (3 : Ordinal)) * (MetaSN.mu a + 1)<br>
        ≤ omega0 ^ (MetaSN.mu a + 4) := h_head<br>
      _ < omega0 ^ (C + 5) := MetaSN.opow_lt_opow_right h_exp1<br>
  have h2_pow : (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) < omega0 ^ (C + 5) := by<br>
    calc (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1)<br>
        ≤ omega0 ^ (MetaSN.mu b + 3) := h_tail<br>
      _ < omega0 ^ (C + 5) := MetaSN.opow_lt_opow_right h_exp2<br>
  -- finite +2 is below ω^(C+5)<br>
  have h_fin : (2 : Ordinal) < omega0 ^ (C + 5) := by<br>
    have two_lt_omega : (2 : Ordinal) < omega0 := nat_lt_omega0 2<br>
    have omega_le : omega0 ≤ omega0 ^ (C + 5) := by<br>
      have one_le_exp : (1 : Ordinal) ≤ C + 5 := by<br>
        have : (1 : Ordinal) ≤ (5 : Ordinal) := by norm_num<br>
        exact le_trans this (le_add_left _ _)<br>
      calc omega0<br>
          = omega0 ^ (1 : Ordinal) := (Ordinal.opow_one omega0).symm<br>
        _ ≤ omega0 ^ (C + 5) := Ordinal.opow_le_opow_right omega0_pos one_le_exp<br>
    exact lt_of_lt_of_le two_lt_omega omega_le<br>
  -- combine pieces directly for μ(merge a b)+1<br>
  have sum_bound : (omega0 ^ (3 : Ordinal)) * (MetaSN.mu a + 1) +<br>
                   (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 2 <<br>
                   omega0 ^ (C + 5) := by<br>
    have k_pos : (0 : Ordinal) < C + 5 := by<br>
      have : (0 : Ordinal) < (5 : Ordinal) := by norm_num<br>
      exact lt_of_lt_of_le this (le_add_left _ _)<br>
    exact omega_pow_add3_lt k_pos h1_pow h2_pow h_fin<br>
  have mu_expand : MetaSN.mu (merge a b) + 1 =<br>
      (omega0 ^ (3 : Ordinal)) * (MetaSN.mu a + 1) +<br>
      (omega0 ^ (2 : Ordinal)) * (MetaSN.mu b + 1) + 2 := by<br>
    simp [MetaSN.mu, add_assoc]<br>
  simpa [mu_expand] using sum_bound<br>
<br>
/-- Total inequality used in <code>R_eq_diff</code>. -/<br>
theorem mu_lt_eq_diff (a b : Trace) :<br>
  MetaSN.mu (integrate (merge a b)) < MetaSN.mu (eqW a b) := by<br>
  by_cases h_both : a = .void ∧ b = .void<br>
  · rcases h_both with ⟨ha, hb⟩<br>
    -- corner case already proven<br>
    simpa [ha, hb] using mu_lt_eq_diff_both_void<br>
  · -- general case<br>
    set C : Ordinal := MetaSN.mu a + MetaSN.mu b with hC<br>
    have hCω : omega0 ≤ C :=<br>
      by<br>
        have := mu_sum_ge_omega_of_not_both_void (a := a) (b := b) h_both<br>
        simpa [hC] using this<br>
<br>
    -- inner bound from <code>merge_inner_bound_simple</code><br>
    have h_inner : MetaSN.mu (merge a b) + 1 < omega0 ^ (C + 5) :=<br>
      by<br>
        simpa [hC] using merge_inner_bound_simple a b<br>
<br>
    -- lift through <code>integrate</code><br>
    have ω4pos : 0 < omega0 ^ (4 : Ordinal) :=<br>
      (Ordinal.opow_pos (b := (4 : Ordinal)) omega0_pos)<br>
    have h_mul :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) <<br>
        omega0 ^ (4 : Ordinal) * omega0 ^ (C + 5) :=<br>
      Ordinal.mul_lt_mul_of_pos_left h_inner ω4pos<br>
<br>
    -- collapse ω⁴·ω^(C+5)  →  ω^(4+(C+5))<br>
    have h_prod :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) <<br>
        omega0 ^ (4 + (C + 5)) :=<br>
      by<br>
        have := (Ordinal.opow_add omega0 (4 : Ordinal) (C + 5)).symm<br>
        simpa [this] using h_mul<br>
<br>
    -- absorb the finite 4 because ω ≤ C<br>
    have absorb4 : (4 : Ordinal) + C = C :=<br>
      nat_left_add_absorb (h := hCω)<br>
    have exp_eq : (4 : Ordinal) + (C + 5) = C + 5 := by<br>
      calc<br>
        (4 : Ordinal) + (C + 5)<br>
            = ((4 : Ordinal) + C) + 5 := by<br>
                simpa [add_assoc]<br>
          _ = C + 5 := by<br>
                simpa [absorb4]<br>
<br>
    -- inequality now at exponent C+5<br>
    have h_prod2 :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) <<br>
        omega0 ^ (C + 5) := by<br>
      simpa [exp_eq] using h_prod<br>
<br>
    -- bump exponent C+5 → C+9<br>
    have exp_lt : omega0 ^ (C + 5) < omega0 ^ (C + 9) :=<br>
      opow_lt_opow_right (add_lt_add_left (by norm_num) C)<br>
<br>
    have h_chain :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) <<br>
        omega0 ^ (C + 9) := lt_trans h_prod2 exp_lt<br>
    -- add +1 on both sides (monotone)<br>
    have hA1 :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) + 1 ≤<br>
        omega0 ^ (C + 9) :=<br>
      Order.add_one_le_of_lt h_chain<br>
    have h_final :<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) + 1 <<br>
        omega0 ^ (C + 9) + 1 :=<br>
      (Order.lt_add_one_iff (x := _ + 1) (y := omega0 ^ (C + 9))).2 hA1<br>
<br>
    -- rewrite both sides in μ-language and conclude<br>
    have hL : MetaSN.mu (integrate (merge a b)) =<br>
        omega0 ^ (4 : Ordinal) * (MetaSN.mu (merge a b) + 1) + 1 := by<br>
      simp [MetaSN.mu]<br>
    have hR : MetaSN.mu (eqW a b) = omega0 ^ (C + 9) + 1 := by<br>
      simp [MetaSN.mu, hC]<br>
    -- final substitution<br>
    simpa [hL, hR]<br>
      using h_final<br>
<br>
<br>
/-- R₂ (left-void): <code>merge void t → t</code> strictly drops <code>μ</code>. -/<br>
theorem mu_lt_merge_void_left (t : Trace) :<br>
  MetaSN.mu t < MetaSN.mu (.merge .void t) := by<br>
  -- start: μ t < ω²*(μ t + 1) + 1<br>
  have h0 : MetaSN.mu t ≤ MetaSN.mu t + 1 :=<br>
    le_of_lt ((Order.lt_add_one_iff (x := MetaSN.mu t) (y := MetaSN.mu t)).2 le_rfl)<br>
  have hpos2 : 0 < (omega0 ^ (2 : Ordinal)) :=<br>
    (Ordinal.opow_pos (b := (2 : Ordinal)) omega0_pos)<br>
  have h1 : MetaSN.mu t + 1 ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) := by<br>
    simpa using<br>
      (Ordinal.le_mul_right (a := MetaSN.mu t + 1) (b := (omega0 ^ (2 : Ordinal))) hpos2)<br>
  have hY : MetaSN.mu t ≤ (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) := le_trans h0 h1<br>
  have hlt : MetaSN.mu t < (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) + 1 :=<br>
    (Order.lt_add_one_iff<br>
      (x := MetaSN.mu t) (y := (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1))).2 hY<br>
<br>
  -- pad on the left with the ω³ "head" of <code>merge</code><br>
  have hpad :<br>
      (omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) + 1 ≤<br>
      (omega0 ^ (3 : Ordinal)) + ((omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) + 1) :=<br>
    Ordinal.le_add_left _ _<br>
<br>
  have hfin :<br>
      MetaSN.mu t <<br>
      (omega0 ^ (3 : Ordinal)) + ((omega0 ^ (2 : Ordinal)) * (MetaSN.mu t + 1) + 1) :=<br>
    lt_of_lt_of_le hlt hpad<br>
<br>
  simpa [MetaSN.mu, add_assoc] using hfin<br>
<br>
<br>
<br>
/-- R₅ (rec base): <code>recΔ b s void → b</code> strictly drops <code>μ</code>. -/<br>
theorem mu_lt_rec_base (b s : Trace) :<br>
  MetaSN.mu b < MetaSN.mu (.recΔ b s .void) := by<br>
  -- μ b < μ b + 1<br>
  have h1 : MetaSN.mu b < MetaSN.mu b + 1 :=<br>
    by simpa using (lt_add_one (MetaSN.mu b))<br>
  -- μ b + 1 ≤ ω * (μ b + 1)<br>
  have h2 : MetaSN.mu b + 1 ≤ omega0 * (MetaSN.mu b + 1) :=<br>
    le_mul_right (a := MetaSN.mu b + 1) (b := omega0) omega0_pos<br>
  have h3 : MetaSN.mu b < omega0 * (MetaSN.mu b + 1) :=<br>
    lt_of_lt_of_le h1 h2<br>
<br>
  -- ω * (μ b + 1) ≤ μ(recΔ b s void)<br>
  have step1 :<br>
      omega0 <em> (MetaSN.mu b + 1) ≤ omega0 </em> (MetaSN.mu b + 1) + 1 :=<br>
    le_add_of_nonneg_right (show (0 : Ordinal) ≤ (1 : Ordinal) by exact zero_le _)<br>
<br>
  -- pad the tower on the left:  X ≤ (A + X), then add +1<br>
  have step2 :<br>
      omega0 * (MetaSN.mu b + 1) + 1 ≤<br>
      omega0 ^ (MetaSN.mu .void + MetaSN.mu s + (6 : Ordinal))<br>
        + omega0 * (MetaSN.mu b + 1) + 1 := by<br>
    have hpad :<br>
        omega0 * (MetaSN.mu b + 1) ≤<br>
        omega0 ^ (MetaSN.mu .void + MetaSN.mu s + (6 : Ordinal))<br>
          + omega0 * (MetaSN.mu b + 1) :=<br>
      Ordinal.le_add_left _ _<br>
    exact add_le_add_right hpad 1<br>
<br>
<br>
  have h4 :<br>
      omega0 * (MetaSN.mu b + 1) ≤<br>
      omega0 ^ (MetaSN.mu .void + MetaSN.mu s + (6 : Ordinal))<br>
        + omega0 * (MetaSN.mu b + 1) + 1 :=<br>
    le_trans step1 step2<br>
<br>
  -- chain the inequalities and unfold μ<br>
  have : MetaSN.mu b <<br>
      omega0 ^ (MetaSN.mu .void + MetaSN.mu s + (6 : Ordinal))<br>
        + omega0 * (MetaSN.mu b + 1) + 1 :=<br>
    lt_of_lt_of_le h3 h4<br>
<br>
  simpa [MetaSN.mu] using this<br>
<br>
<br>
<br>
/-! ### Combined termination measure<br>
<br>
We avoid the currently unproven domination inequality needed for a direct<br>
<code>μ</code> drop on the <code>recΔ</code> successor rule by introducing a primary counter that<br>
counts <code>delta</code> constructors. The <code>recΔ</code> successor rule removes exactly one<br>
outer <code>delta</code>, so the primary component strictly decreases there. For all<br>
other rules the <code>delta</code> count is unchanged or decreases; when unchanged we<br>
use the existing strict μ drop lemmas. This yields a lexicographic decrease<br>
without new ordinal theory. -/<br>
<br>
/-! ### Unconditional μ decrease for recΔ successor and SN via μ -/<br>
<br>
/-- μ n + 2 ≤ μ (delta n). -/<br>
lemma mu_n_add_two_le_mu_delta (n : Trace) : MetaSN.mu n + 2 ≤ MetaSN.mu (.delta n) := by<br>
  -- μ(δ n) = ω^5<em>(μ n + 1) + 1; obviously μ n + 2 ≤ ω^5</em>(μ n + 1) + 1 since ω^5*(μ n +1) dominates μ n +1.<br>
  have h0 : MetaSN.mu n + 1 ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) := by<br>
    -- Establish 1 ≤ ω^5 via ω ≤ ω^5 and 1 ≤ ω<br>
    have hone : (1 : Ordinal) ≤ omega0 := by simpa using one_le_omega0<br>
    have hωle : omega0 ≤ omega0 ^ (5 : Ordinal) := by<br>
      simpa [Ordinal.opow_one] using<br>
        (Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ (5 : Ordinal)))<br>
    have hge : (1 : Ordinal) ≤ omega0 ^ (5 : Ordinal) := le_trans hone hωle<br>
    -- multiply on the right by (μ n + 1)<br>
    simpa [one_mul] using (mul_le_mul_right' hge (MetaSN.mu n + 1))<br>
  -- Step 2: add one on both sides and close by definition of μ (delta n)<br>
  have h1 : MetaSN.mu n + 2 ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 := by<br>
    have := add_le_add_right h0 (1 : Ordinal)<br>
    simpa [add_assoc, succ_succ_eq_add_two, Ordinal.add_one_eq_succ] using this<br>
  simpa [MetaSN.mu, add_assoc] using h1<br>
<br>
/-! #### New auxiliary lemmas for unconditional rec successor -/<br>
<br>
/-- Strict inequality <code>μ n < μ (delta n)</code> (immediate from the δ-case of <code>mu</code>). -/<br>
lemma mu_lt_mu_delta (n : Trace) : MetaSN.mu n < MetaSN.mu (.delta n) := by<br>
  -- μ n < μ n +1 ≤ ω^5*(μ n +1) +1<br>
  have h0 : MetaSN.mu n < MetaSN.mu n + 1 :=<br>
    (Order.lt_add_one_iff (x := MetaSN.mu n) (y := MetaSN.mu n)).2 le_rfl<br>
  have hdom : MetaSN.mu n + 1 ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 := by<br>
    have hbase : MetaSN.mu n + 1 ≤ (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) := by<br>
      -- as above: 1 ≤ ω^5<br>
      have hone : (1 : Ordinal) ≤ omega0 := by simpa using one_le_omega0<br>
      have hωle : omega0 ≤ omega0 ^ (5 : Ordinal) := by<br>
        simpa [Ordinal.opow_one] using<br>
          (Ordinal.opow_le_opow_right omega0_pos (by norm_num : (1 : Ordinal) ≤ (5 : Ordinal)))<br>
      have hge : (1 : Ordinal) ≤ omega0 ^ (5 : Ordinal) := le_trans hone hωle<br>
      -- multiply on the right by (μ n + 1)<br>
      simpa [one_mul] using (mul_le_mul_right' hge (MetaSN.mu n + 1))<br>
    exact le_trans hbase (le_add_of_nonneg_right (zero_le _))<br>
  have : MetaSN.mu n < (omega0 ^ (5 : Ordinal)) * (MetaSN.mu n + 1) + 1 :=<br>
    lt_of_lt_of_le h0 hdom<br>
  -- Rewrite RHS into μ (delta n) then close<br>
  have h' : MetaSN.mu n < MetaSN.mu (.delta n) := by<br>
    simpa [MetaSN.mu, add_assoc, add_comm, add_left_comm] using this<br>
  exact h'<br>
<br>
-- Exponent bump comment: aiming at <code>μ n + μ s + 6 < μ (delta n) + μ s + 6</code> is<br>
-- invalid without extra hypotheses; right-add strict monotonicity fails in ordinals.<br>
-- We avoid any unconditional version here.<br>
<br>
/-- Generic product absorption: if <code>X < ω^α</code> and <code>(k:Ordinal)+α ≤ β</code> then <code>ω^k * X < ω^β</code>.<br>
    (Finite <code>k</code>, used with k=2.) -/<br>
lemma omega_pow_fin_mul_cnf_lt {k : ℕ} {α β X : Ordinal}<br>
  (_hk : 0 < k) (hX : X < omega0 ^ α) (hExp : (k : Ordinal) + α ≤ β) :<br>
  omega0 ^ (k : Ordinal) * X < omega0 ^ β := by<br>
  have hpos : (0 : Ordinal) < omega0 ^ (k : Ordinal) :=<br>
    Ordinal.opow_pos (a := omega0) (b := (k : Ordinal)) omega0_pos<br>
  -- step 1: multiply inequality on right factor<br>
  have h1 : omega0 ^ (k : Ordinal) <em> X < omega0 ^ (k : Ordinal) </em> (omega0 ^ α) :=<br>
    Ordinal.mul_lt_mul_of_pos_left hX hpos<br>
  -- collapse product of towers<br>
  have h2 : omega0 ^ (k : Ordinal) * X < omega0 ^ ((k : Ordinal) + α) := by<br>
    -- rewrite product of towers via opow_add<br>
    simpa [Ordinal.opow_add, mul_comm, mul_left_comm, mul_assoc]<br>
      using h1<br>
  -- monotone in exponent<br>
  have hmono : omega0 ^ ((k : Ordinal) + α) ≤ omega0 ^ β :=<br>
    Ordinal.opow_le_opow_right omega0_pos hExp<br>
  exact lt_of_lt_of_le h2 hmono<br>
<br>
<br>
def StepRev (R : Trace → Trace → Prop) : Trace → Trace → Prop := fun a b => R b a<br>
<br>
theorem strong_normalization_forward_trace<br>
  (R : Trace → Trace → Prop)<br>
  (hdec : ∀ {a b : Trace}, R a b → mu b < mu a) :<br>
  WellFounded (StepRev R) := by<br>
  have hwf : WellFounded (fun x y : Trace => mu x < mu y) :=<br>
    InvImage.wf (f := mu) (h := Ordinal.lt_wf)<br>
  have hsub : Subrelation (StepRev R) (fun x y : Trace => mu x < mu y) := by<br>
    intro x y h; exact hdec (a := y) (b := x) h<br>
  exact Subrelation.wf hsub hwf<br>
<br>
theorem strong_normalization_backward<br>
  (R : Trace → Trace → Prop)<br>
  (hinc : ∀ {a b : Trace}, R a b → mu a < mu b) :<br>
  WellFounded R := by<br>
  have hwf : WellFounded (fun x y : Trace => mu x < mu y) :=<br>
    InvImage.wf (f := mu) (h := Ordinal.lt_wf)<br>
  have hsub : Subrelation R (fun x y : Trace => mu x < mu y) := by<br>
    intro x y h<br>
    exact hinc h<br>
  exact Subrelation.wf hsub hwf<br>
<br>
def KernelStep : Trace → Trace → Prop := fun a b => OperatorKernelO6.Step a b<br>
<br>
/-! ### Strong normalization via lexicographic (κ, μ) measure -/<br>
<br>
-- A simple top-level κ that marks only top-level <code>recΔ</code> constructors<br>
def kappaTop : Trace → Nat<br>
| Trace.recΔ _ _ _ => 1<br>
| _ => 0<br>
<br>
noncomputable def μκTop (t : Trace) : Nat × Ordinal := (kappaTop t, mu t)<br>
<br>
def LexNatOrdTop : (Nat × Ordinal) → (Nat × Ordinal) → Prop :=<br>
  Prod.Lex (· < ·) (· < ·)<br>
<br>
lemma wf_LexNatOrdTop : WellFounded LexNatOrdTop := by<br>
  -- lex well-foundedness for (Nat,<) × (Ordinal,<)<br>
  refine WellFounded.prod_lex (r := (· < ·)) (s := fun _ => (· < ·)) Nat.lt_wfRel.wf ?_;<br>
  intro _; exact Ordinal.lt_wf<br>
<br>
lemma μ_to_μκ_top {t t' : Trace} (h : mu t' < mu t) (hk : kappaTop t' = kappaTop t) :<br>
  LexNatOrdTop (μκTop t') (μκTop t) := by<br>
  unfold LexNatOrdTop μκTop<br>
  -- First components propositionally equal, supply proof for right branch<br>
  exact Prod.Lex.right hk h<br>
<br>
theorem mu_kappaTop_decreases :<br>
  ∀ {a b : Trace}, Step a b → LexNatOrdTop (μκTop b) (μκTop a) := by<br>
  intro a b h<br>
  cases h with<br>
  | @R_int_delta t =><br>
      have hμ : mu Trace.void < mu (integrate (delta t)) := mu_void_lt_integrate_delta t<br>
      have hk : kappaTop Trace.void = kappaTop (integrate (delta t)) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | R_merge_void_left =><br>
      have hμ : mu b < mu (merge Trace.void b) := mu_lt_merge_void_left b<br>
      have hk : kappaTop b = kappaTop (merge Trace.void b) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | R_merge_void_right =><br>
      have hμ : mu b < mu (merge b Trace.void) := mu_lt_merge_void_right b<br>
      have hk : kappaTop b = kappaTop (merge b Trace.void) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | R_merge_cancel =><br>
      have hμ : mu b < mu (merge b b) := mu_lt_merge_cancel b<br>
      have hk : kappaTop b = kappaTop (merge b b) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | @R_rec_zero b s =><br>
      -- Either κ drops (non-rec b), or κ equal (rec b) and μ decreases<br>
      have hμ : mu b < mu (recΔ b s Trace.void) := mu_lt_rec_base b s<br>
      cases b with<br>
      | recΔ b' s' n' =><br>
          have hk : kappaTop (recΔ b' s' n') = kappaTop (recΔ b s Trace.void) := by simp [kappaTop]<br>
          exact μ_to_μκ_top hμ hk<br>
      | void =><br>
          unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
      | delta _ =><br>
          unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
      | integrate _ =><br>
          unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
      | merge _ _ =><br>
          unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
      | eqW _ _ =><br>
          unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
  | @R_eq_refl a =><br>
      have hμ : mu Trace.void < mu (eqW a a) := mu_void_lt_eq_refl a<br>
      have hk : kappaTop Trace.void = kappaTop (eqW a a) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | @R_eq_diff a b _ =><br>
      have hμ : mu (integrate (merge a b)) < mu (eqW a b) := mu_lt_eq_diff a b<br>
      have hk : kappaTop (integrate (merge a b)) = kappaTop (eqW a b) := by simp [kappaTop]<br>
      exact μ_to_μκ_top hμ hk<br>
  | R_rec_succ b s n =><br>
      -- κ strictly drops at top-level in rec successor<br>
      unfold LexNatOrdTop μκTop; apply Prod.Lex.left; simpa [kappaTop] using (Nat.succ_pos 0)<br>
<br>
theorem step_strong_normalization : WellFounded (StepRev KernelStep) := by<br>
  refine Subrelation.wf ?hsub (InvImage.wf (f := μκTop) wf_LexNatOrdTop)<br>
  intro x y hxy<br>
  have hk : KernelStep y x := hxy<br>
  exact mu_kappaTop_decreases hk<br>

</body>
</html>
