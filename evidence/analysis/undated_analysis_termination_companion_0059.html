<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Termination_Companion</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        table td, table th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        strong {
            color: #2c3e50;
        }
        @media print {
            body {
                max-width: none;
                margin: 0;
                padding: 20px;
            }
            h1 {
                page-break-before: always;
            }
            pre {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
# Termination Companion — Full Mathematical & Algorithmic Dossier<br>
<br>
Version: 2025-08-09 (POST-LEX SN GREEN)  <br>
Scope: Strong Normalization (SN) + structural termination strategy for the OperatorKernelO6 rewrite system.  <br>
Audience: Authors, reviewers, automated agents.  <br>
Prime Directive: No kernel alteration. All reasoning meta-level, axiom‑free (no <code>sorry</code>).<br>
<br>
---<br>
<br>
## 0. Executive Abstract<br>
<br>
We study strong normalization of the rewrite system generated by the 8 kernel rules on the inductive type <code>Trace</code>. We aim to construct a <em>single</em>, well‑founded, ordinal‑valued measure <code>μ : Trace → Ordinal</code> such that for every rewrite step <code>t → u</code> we have <code>μ u < μ t</code>. This ensures termination via <code>InvImage.wf</code>. Confluence (normalize–join) and higher constructions (arithmetic, equality, provability encodings) depend on a canonical normalizing <em>geometry</em>, hence SN is foundational.<br>
<br>
Current status: Strong Normalization is <strong>proved</strong> in <code>Termination.lean</code> via a <em>shallow</em> lexicographic measure <code>(kappaTop, μ)</code> where <code>kappaTop : Trace → Nat</code> detects only whether the root constructor is <code>recΔ</code> (value <code>1</code>) or not (value <code>0</code>). All non‑<code>recΔ</code> rules strictly decrease <code>μ</code> while preserving <code>kappaTop</code>; the <code>recΔ</code> successor rule strictly decreases <code>kappaTop</code> (dropping from <code>1</code> to <code>0</code>). The pure single‑measure (<code>μ</code> only) decrease for the successor rule remains an <strong>open research target</strong>; the bottleneck inequality is documented below. Downstream work (confluence, arithmetic, equality) can proceed on the established well‑foundedness.<br>
<br>
---<br>
<br>
## 1. Kernel Recap (Immutable Substrate)<br>
<br>
Constructors of <code>Trace</code>:<br>
1. <code>void</code><br>
2. <code>delta t</code><br>
3. <code>integrate t</code><br>
4. <code>merge a b</code><br>
5. <code>recΔ b s n</code><br>
6. <code>eqW a b</code><br>
<br>
Rewrite rules (<code>Step</code>):<br>
- (Int‑Δ) <code>integrate (delta t) → void</code><br>
- (M‑0L) <code>merge void t → t</code><br>
- (M‑0R) <code>merge t void → t</code><br>
- (M‑C)  <code>merge t t → t</code><br>
- (Rec‑0) <code>recΔ b s void → b</code><br>
- (Rec‑S) <code>recΔ b s (delta n) → merge s (recΔ b s n)</code><br>
- (Eq‑Refl) <code>eqW a a → void</code><br>
- (Eq‑Diff) <code>eqW a b → integrate (merge a b)</code> (always fires; reflexive case already catches equality)<br>
<br>
<code>StepStar</code> is the reflexive–transitive closure used for normalization and confluence arguments.<br>
<br>
---<br>
<br>
## 2. Strategic Design of the Ordinal Measure μ<br>
<br>
### 2.1 Architecture Principles<br>
We build <code>μ</code> as a <em>Cantor normal form inspired</em> composite whose leading exponents isolate constructor <em>strata</em>. The ordinal growth tiers strictly separate constructors, ensuring no ambiguity in dominance comparisons:<br>
<br>
<pre><code><br>
μ void              := 0<br>
μ (delta t)         := ω^(5) * (μ t + 1) + 1<br>
μ (integrate t)     := ω^(4) * (μ t + 1) + 1<br>
μ (merge a b)       := ω^(3) <em> (μ a + 1) + ω^(2) </em> (μ b + 1) + 1<br>
μ (recΔ b s n)      := ω^( μ n + μ s + 6 ) + ω * (μ b + 1) + 1<br>
μ (eqW a b)         := ω^( μ a + μ b + 9 ) + 1<br>
</code></pre><br>
<br>
### 2.2 Rationale for Exponent Slots<br>
| Constructor | Leading Component | Justification |<br>
|-------------|-------------------|---------------|<br>
| <code>delta</code>     | <code>ω^5</code>             | Fixed high finite exponent reserved for unary growth steps |<br>
| <code>integrate</code> | <code>ω^4</code>             | Below delta to ensure integrate∘delta collapses massively |<br>
| <code>merge</code>     | <code>ω^3</code>, <code>ω^2</code>      | Binary layering; left operand prioritized over right |<br>
| <code>recΔ</code>      | <code>ω^(μ n + μ s + 6)</code> | Dynamic tower capturing recursive depth parameter interplay |<br>
| <code>eqW</code>       | <code>ω^(μ a + μ b + 9)</code> | High tier bounding combination before reduction via merge/integrate |<br>
<br>
Finite offsets (<code>+1</code>, <code>+6</code>, <code>+9</code>) ensure separation margins and space for arithmetic safety lemmas (e.g., successor bridging and exponent bumping).<br>
<br>
### 2.3 Design Invariants<br>
1. <strong>Constructor Stratification:</strong> Any dynamic exponent (<code>μ n + μ s + 6</code>) strictly dominates all <em>fixed finite</em> exponent shells (≤ 5) whenever either <code>μ n</code> or <code>μ s</code> grows beyond finite ranges, thereby giving room for recursion descent.<br>
2. <strong>Additive Principal Usage:</strong> <code>ω^κ</code> with <code>κ ≥ 1</code> is additive principal. Used to absorb finite and lower‑order sums and maintain canonical dominance ordering.<br>
3. <strong>Payload Normalization:</strong> Each non-leading summand is controlled (e.g., <code>ω*(μ b + 1)</code> subordinate to preceding tower) ensuring additive absorption lemmas apply uniformly.<br>
<br>
---<br>
<br>
## 3. Proof Skeleton for Strong Normalization<br>
<br>
### 3.1 Goal<br>
Show: <code>∀ t u, Step t u → μ u < μ t</code>. Then <code>WellFounded (StepRev)</code> where <code>StepRev a b := Step b a</code> follows from <code>InvImage.wf</code> of <code><</code> on ordinals.<br>
<br>
### 3.2 Rule‑By‑Rule Decrease Concepts<br>
| Rule | Structural Effect | Decrease Mechanism Sketch |<br>
|------|-------------------|---------------------------|<br>
| Int‑Δ | Eliminates a full <code>delta</code> layer via <code>integrate</code> | <code>ω^4 * (...) + 1</code> vs <code>0</code> ⇒ trivial large drop |<br>
| Merge‑Void (L/R) | Erases leading merge shell | Removes entire <code>ω^3/ω^2</code> frame |<br>
| Merge‑Cancel | Collapses duplicate symmetric merge | Strictly fewer large blocks |<br>
| Rec‑0 | Base case of recursion | Drops dynamic exponent tower to underlying base <code>b</code> |<br>
| Rec‑S | Moves one delta inward, reorganizes as merge | Requires bounding merge payload under the <em>larger</em> dynamic tower of successor state |<br>
| Eq‑Refl | Eliminates equality wrapper | Removes <code>ω^(...) + 1</code> tower |<br>
| Eq‑Diff | Converts equality to integrate(merge …) | <code>ω^(exp+9)+1</code> outclasses integrate + merge composite |<br>
<br>
### 3.3 Typical Lemma Pattern<br>
1. <strong>Local Growth Fact:</strong> Show payload subcomponents <code>< ω^κ</code> individually.<br>
2. <strong>Principal Absorption:</strong> Use additive principal property to fold finite or subordinate sums into <code>ω^κ</code>.<br>
3. <strong>Exponent Lift:</strong> Convert product of towers via <code>opow_add</code> to unify exponent arithmetic.<br>
4. <strong>Strict Gap:</strong> Use arithmetic offset (e.g., <code>+4</code>, <code>+6</code>, <code>+9</code>) to secure strict inequality on exponents.<br>
<br>
---<br>
<br>
## 4. Established Lemmas & SN Proof Components (Updated)<br>
<br>
All items below refer to declarations now consolidated in <code>Termination.lean</code> (the former <code>Termination_C.lean</code> work has been merged; the extra file was removed).<br>
<br>
| Lemma / Component | Intent | Current Status |<br>
|-------------------|--------|----------------|<br>
| <code>mu_void_lt_integrate_delta</code> | Int‑Δ decrease | Proven & used |<br>
| <code>mu_void_lt_eq_refl</code> | Eq‑Refl decrease | Proven & used |<br>
| <code>mu_lt_merge_void_left/right</code> | Merge‑Void (L/R) decreases | Proven & used |<br>
| <code>mu_lt_merge_cancel</code> | Merge‑Cancel decrease | Proven & used |<br>
| <code>mu_lt_rec_base</code> | Rec‑Zero decrease | Proven & used |<br>
| <code>mu_lt_eq_diff_both_void</code> | Eq‑Diff corner case | Proven & used |<br>
| <code>mu_lt_eq_diff</code> | General Eq‑Diff decrease | Proven & used |<br>
| <code>mu_n_add_two_le_mu_delta</code> | Padding below δ tower | Proven (orientation normalized) |<br>
| <code>mu_lt_mu_delta</code> | Strict growth <code>μ n < μ (delta n)</code> | Proven |<br>
| <code>termA_le</code>, <code>termB_le</code> | Payload growth controls | Proven & reused |<br>
| <code>payload_bound_merge_mu</code> / <code>merge_inner_bound_simple</code> | Merge payload < tower | Proven (one canonical retained) |<br>
| <code>omega_pow_fin_mul_cnf_lt</code> | Finite factor absorption | Available (not central to lex proof) |<br>
| <code>head_lt_A</code>, <code>tail_lt_A</code> | Rec‑Succ payload < successor tower (conditional) | Proven (under domination hypothesis) |<br>
| <code>mu_merge_lt_rec</code> | Parametric Rec‑Succ μ decrease (conditional) | Proven (needs bound; not used in final SN) |<br>
| <code>μ_to_μκ_top</code> | Lift μ decrease when <code>kappaTop</code> equal | Proven & used |<br>
| <code>μκTop</code> / <code>LexNatOrdTop</code> | Lex pair + ordering | Defined |<br>
| <code>wf_LexNatOrdTop</code> | Well‑foundedness of lex order | Proven |<br>
| <code>mu_kappaTop_decreases</code> | Case analysis over all 8 rules | Proven |<br>
| <code>step_strong_normalization</code> | Final SN theorem (lexicographic) | Proven |<br>
| Pure μ Rec‑Succ inequality <code>(⋆)</code> | Needed for single‑measure SN | OPEN |<br>
<br>
Notes:<br>
1. The active SN proof does <strong>not</strong> rely on the conditional <code>mu_merge_lt_rec</code>; instead it uses the structural drop in <code>kappaTop</code> for Rec‑Succ.<br>
2. The current <code>kappaTop</code> is intentionally minimal (binary 0/1). It suffices because each Rec‑Succ step removes a top‑level <code>recΔ</code> root. Deeply nested <code>recΔ</code> occurrences are still governed by subsequent steps: once they surface at the root they again trigger a <code>kappaTop</code> = 1 state, ensuring overall descent.<br>
3. A richer spine‑depth measure is unnecessary for correctness but may be introduced later to support more granular complexity analyses or potential optimization heuristics.<br>
<br>
---<br>
<br>
## 5. The Rec‑Successor Bottleneck (Pure μ Track)<br>
<br>
### 5.1 Desired Inequality<br>
Need: <code>μ (merge s (recΔ b s n)) < μ (recΔ b s (delta n))</code>.<br>
<br>
Expansions (RHS vs LHS major parts):<br>
<br>
<pre><code><br>
μ (recΔ b s (delta n)) = ω^( μ (delta n) + μ s + 6 ) + ω*(μ b + 1) + 1<br>
μ (recΔ b s n)         = ω^( μ n + μ s + 6 ) + ω*(μ b + 1) + 1<br>
μ (merge s (recΔ b s n))<br>
	= ω^3<em>(μ s + 1) + ω^2</em>(μ (recΔ b s n) + 1) + 1<br>
</code></pre><br>
<br>
So it suffices to place both <code>ω^3<em>(μ s + 1)</code> and <code>ω^2</em>(μ (recΔ b s n) + 1)</code> <em>strictly below</em> the dominant tower <code>A := ω^( μ (delta n) + μ s + 6 )</code>, then show RHS adds a <em>new positive tail</em> after <code>A</code>, giving strict growth.<br>
<br>
### 5.2 Obstruction (Unchanged)<br>
To prove <code>ω^2*(μ (recΔ b s n) + 1) < A</code>, we reduce to showing <code>μ (recΔ b s n) + 1 < A</code>. By additive principal normality of <code>ω^(...)</code>, we need the leading part <code>ω^( μ n + μ s + 6 )</code> strictly below <code>A</code>. That reduces to the exponent inequality:<br>
<br>
<pre><code><br>
μ n + μ s + 6 < μ (delta n) + μ s + 6  (⋆)<br>
</code></pre><br>
<br>
But <code>(⋆)</code> is <em>not derivable just from</em> <code>μ n < μ (delta n)</code> because ordinal right addition can erase strictness if the right summand eclipses the left difference. Without constraints on <code>μ s</code>, <code>(⋆)</code> may fail—hence attempts using <code>add_lt_add_right</code> or syntactic shift tactics are invalid.<br>
<br>
### 5.3 Standard Workarounds Considered (Historical)<br>
1. <strong>Lexicographic Pair <code>(kappa, μ)</code>:</strong> Works (kappa counts <code>delta</code> height so <code>Rec‑S</code> strictly decreases first component) but sacrifices the elegance of pure ordinal synthesis.<br>
2. <strong>Strengthen μ’s δ Layer:</strong> Modify δ exponent (e.g., escalate to an inaccessible offset) to dominate any <code>μ s</code>. Disruptive: forces sweeping revalidation of previously proved decreases.<br>
3. <strong>Structural Restriction:</strong> Enforce semantic relation tying <code>s</code> to <code>n</code> (not allowed; kernel semantics treat them independent parameters).<br>
4. <strong>Tail‑Dominance Lemma (Option A Chosen):</strong> Explicit side conditions capturing that the <em>specific</em> tail we add is finite / controlled relative to new leading tower. Requires a <em>provable</em> bound on <code>μ s</code> in terms of <code>μ n</code>—not available; thus we must encode a <em>conditional</em> lemma with a domination hypothesis.<br>
<br>
### 5.4 Formal Shape for the Needed New Lemma<br>
We propose introducing a <em>conditional</em> transport lemma:<br>
<br>
<pre><code><br>
lemma add_tail_strict<br>
	{a b t : Ordinal}<br>
	(h : a < b)<br>
	(finite_tail : t < ω^(5) * (a + 1)) : a + t < b + t<br>
</code></pre><br>
<br>
Then instantiate with <code>a := μ n</code>, <code>b := μ (delta n)</code> and <code>t := μ s + 6</code> <strong>if</strong> we can ensure <code>μ s + 6 < ω^5*(μ n + 1)</code>. This is exactly the missing domination hypothesis.<br>
<br>
### 5.5 Why Domination Hypothesis is Non‑Trivial<br>
<code>μ s</code> can itself contain a <code>recΔ</code> term with exponent <code>ω^( μ n' + μ s' + 6 )</code>, potentially arbitrarily large; there is no a priori bound by a fixed finite tower over <code>μ n</code> unless we track <code>delta</code> depth separately.<br>
<br>
Thus unconditional Option A fails unless we augment the measure or reintroduce an auxiliary component capturing a well‑founded <em>delta depth bound</em> to ensure finite transport safety.<br>
<br>
---<br>
<br>
## 6. Current Mathematical Blocker — Precise Statement (Still Open)<br>
<br>
We cannot (presently) prove, <em>for arbitrary traces</em>, the strict inequality:<br>
<br>
<code>μ n + μ s + 6 < μ (delta n) + μ s + 6</code>.<br>
<br>
Reason: Need <code>μ s</code> constrained to avoid swallowing the δ‑bump. Ordinal arithmetic only guarantees left‑addition strictness (<code>add_lt_add_left</code>), not right‑addition strictness in general. Right summand may be a limit dominating the added difference.<br>
<br>
---<br>
<br>
## 7. Resolution Paths & Tradeoffs (Updated Assessments)<br>
<br>
| Path | Action | Pros | Cons | Current Disposition |<br>
|------|--------|------|------|---------------------|<br>
| P1 | Lexicographic <code>(kappaTop, μ)</code> | Achieved SN quickly | Shallow first component | ADOPTED (implemented) |<br>
| P2 | Redesign μ to force Rec‑Succ drop | Single measure elegance | Global re‑proof overhead | Research backlog |<br>
| P3 | Semantic constraints on params | Minimal coding | Breaks kernel generality | Rejected |<br>
| P4 | Richer auxiliary ordinal / multiset | Stronger structural control | Added complexity | Deferred (may revisit if P2 stalls) |<br>
<br>
Current stance: P1 locked in for baseline correctness; P2 pursued only if single‑measure minimalism yields tangible downstream simplifications.<br>
<br>
---<br>
<br>
## 8. Tactics & Ordinal API Usage (Meta Layer)<br>
<br>
| Category | Tool / Lemma | Role |<br>
|----------|--------------|------|<br>
| Positivity | <code>Ordinal.opow_pos</code> | Show tower > 0 for multiplicative monotonicity |<br>
| Exponent Monotone | <code>Ordinal.opow_le_opow_right</code>, local <code>opow_lt_opow_right</code> | Lift (≤ / <) through ω‑powers |<br>
| Additive Principal | <code>Ordinal.principal_add_omega0_opow</code> | Absorb subordinate finite / smaller tower sums |<br>
| Finite Absorption | <code>omega_pow_fin_mul_cnf_lt</code> (project lemma) | Embed <code>ω^k * X</code> under higher tower |<br>
| Structural Rewrites | <code>opow_add</code> | Collapse tower products |<br>
| Successor Bridge | <code>Order.lt_add_one_iff</code>, <code>Order.add_one_le_of_lt</code> | Normalize +1 / succ manipulations |<br>
<br>
Simp strategy: restrict to associativity/commutativity and the μ definition expansions; avoid aggressive normalization that could collapse intended ordinal stratification.<br>
<br>
---<br>
<br>
## 9. Implemented Lexicographic SN Proof (Summary)<br>
<br>
Execution recap now present in <code>Termination.lean</code>:<br>
1. Define <code>kappaTop</code> marking root <code>recΔ</code> with <code>1</code> else <code>0</code>.<br>
2. Pair with <code>μ</code> to form <code>μκTop</code> and order via <code>LexNatOrdTop := Prod.Lex (<) (<)</code>.<br>
3. Supply <code>wf_LexNatOrdTop</code> using the product lex well‑foundedness of <code><</code> on <code>Nat</code> and <code><</code> on <code>Ordinal</code>.<br>
4. For each rule:<br>
	- If root constructor is unchanged and not <code>recΔ</code>, use an existing strict μ drop (<code>μ_to_μκ_top</code>).<br>
	- Rec‑Zero: either κ drops immediately (if base not a <code>recΔ</code>) or μ handles the decrease when κ stays 1 (handled by case split on <code>b</code>).<br>
	- Rec‑Succ: root changes from <code>recΔ</code> (κ=1) to <code>merge</code> (κ=0) giving an immediate lex decrease, avoiding the blocked pure μ inequality.<br>
5. Conclude <code>step_strong_normalization : WellFounded (StepRev KernelStep)</code> by composing subrelation with <code>InvImage.wf</code> on <code>μκTop</code>.<br>
<br>
Rationale for sufficiency: While <code>kappaTop</code> ignores deeper <code>recΔ</code> nodes, every inner recursion eventually bubbles to the root after finitely many successor steps, each of which strictly lowers the top‑level κ when encountered. Hence no infinite sequence can sustain κ=1 indefinitely, and κ=0 phases must strictly drop μ to continue, forbidding infinite descent.<br>
<br>
---<br>
<br>
## 10. Future Pure‑μ Research Track (P2)<br>
<br>
Objective: Refactor μ so that δ promotion produces a <em>guaranteed</em> exponent jump dominating any context <code>μ s</code> that could appear simultaneously in a <code>recΔ</code>. Candidate strategies:<br>
<br>
1. <strong>Introduce Tier Parameter:</strong> Replace <code>ω^(5)</code> with <code>ω^(Ω · (μ t + 1) + c)</code> for some higher‑order ordinal <code>Ω = ω^(ω)</code> to isolate δ growth.<br>
2. <strong>Use Multiplicative Tower Elevation:</strong> Encode constructor levels as iterated exponent layers (<code>ω^(ω^(level + payload))</code>) ensuring that δ always injects a higher tower tier than any merge/rec composition using previous payloads.<br>
3. <strong>Ordinal Collapsing Function:</strong> Apply a collapsing function <code>ψ</code> to shape complexity; heavy machinery—may exceed project minimalism goals.<br>
<br>
Risks: Each redesign demands re‑establishing all monotonicity and strictness lemmas with expanded algebraic overhead.<br>
<br>
---<br>
<br>
## 11. Confluence & Downstream Dependencies<br>
<br>
Once SN is secured (via lex pair if necessary), confluence follows the normalize–join plan:<br>
1. Define deterministic normalizer <code>normalize : Trace → Trace</code> folding by exhaustive Step reduction guided by the well‑founded measure.<br>
2. Show every trace reduces to its normal form.<br>
3. Show uniqueness of normal forms ⇒ Church–Rosser (confluent rewrite system).<br>
<br>
Subsequent arithmetic & equality developments assume canonical evaluation, so expediting SN (even via lexicographic fallback) unlocks progress in those modules without waiting for a perfected one‑measure architecture.<br>
<br>
---<br>
<br>
## 12. Summary of Components (Post-SN)<br>
<br>
| Component | Status | Next Action |<br>
|-----------|--------|-------------|<br>
| Non‑rec rules μ decrease | Stable | Keep for reuse in pure μ research |<br>
| Rec‑Zero μ decrease | Stable | None |<br>
| Rec‑Succ (lex path) | Resolved via κ drop | Optional: strengthen κ or remove if pure μ solved |<br>
| Rec‑Succ (pure μ) | OPEN | Research dominance redesign |<br>
| Lexicographic SN theorem | COMPLETE | Leverage for normalize–join |<br>
| Confluence pipeline | Pending | Implement normalization function next |<br>
| Arithmetic layer | Unblocked | Begin after normalization skeleton |<br>
| Equality canonicalization | Unblocked | Can proceed in parallel |<br>
| Fuzz / stress tests | Planned | Add after normalization to test measure monotonicity |<br>
| Pure μ research branch | Planned | Start once confluence landed |<br>
<br>
---<br>
<br>
## 13. Actionable Next Steps (Post-SN Roadmap)<br>
<br>
1. Implement deterministic <code>normalize : Trace → Trace</code> using well‑founded recursion on <code>μκTop</code>.<br>
2. Prove <code>to_norm : StepStar t (normalize t)</code> and <code>norm_nf : NormalForm (normalize t)</code>.<br>
3. Derive confluence via normalize–join (<code>Step</code> confluent since every divergent peak joins at common normal form).<br>
4. Add fuzz harness: generate random traces / random rewrite sequences; assert measure strictly decreases (<code>μκTop</code>) each step (meta correctness sanity).<br>
5. Begin arithmetic layer formalization referencing normalization for canonical evaluation semantics.<br>
6. Spin off <code>pure_mu_experiment</code> branch to attempt μ redesign eliminating <code>kappaTop</code>.<br>
<br>
---<br>
<br>
## 14. Appendix: Notational & Lemma Glossary<br>
<br>
| Symbol | Meaning |<br>
|--------|---------|<br>
| <code>μ t</code> | Ordinal measure of trace <code>t</code> |<br>
| <code>κ t</code> (<code>kappa</code>) | Delta depth (number of nested <code>recΔ</code> argument deltas peeled) |<br>
| <code>Step</code> | One-step rewrite relation |<br>
| <code>StepStar</code> | Reflexive–transitive closure of <code>Step</code> |<br>
| <code>A</code> | Shorthand <code>ω^( μ (delta n) + μ s + 6 )</code> in rec successor reasoning |<br>
| <code>principal_add_omega0_opow</code> | Additive principal lemma for <code>ω^κ</code> |<br>
| <code>opow_lt_opow_right</code> | Strict monotonicity of exponentiation in exponent |<br>
| <code>termA_le</code>, <code>termB_le</code> | Bounding lemmas raising fixed tower tiers |<br>
<br>
---<br>
<br>
## 15. Precise Mathematical Blocker Statement (For Tracking)<br>
<br>
> Open Problem (Pure μ SN Rec‑Succ): Prove for arbitrary traces <code>n s</code>:<br>
> <code>μ n + μ s + 6 < μ (delta n) + μ s + 6</code>.<br>
><br>
> This is equivalent to demonstrating that the ordinal difference <code>μ (delta n) − μ n</code> remains observable after right addition of <code>μ s + 6</code>. Ordinal arithmetic shows counterexamples unless a structural dominance on the added right summand is imposed.<br>
<br>
Mitigation: Lexicographic fallback <code>(kappa, μ)</code> avoids needing this inequality.<br>
<br>
---<br>
<br>
## 16. Roadmap Milestones Table (Updated)<br>
<br>
| Milestone | Description | Status |<br>
|-----------|-------------|--------|<br>
| M1 | Lexicographic SN proof green | DONE |<br>
| M2 | Confluence (normalize–join) | Next |<br>
| M3 | Arithmetic layer (addition/multiplication via traces) | Pending |<br>
| M4 | Equality canonicalization & decision (via normalization) | Pending |<br>
| M5 | Pure μ research branch (μ redesign / dominance) | Planned |<br>
| M6 | Fuzz / stress test suite | Planned |<br>
| M7 | Gödel / provability encoding layer | Downstream |<br>
<br>
---<br>
<br>
## 17. Closing<br>
<br>
This companion now records the <em>completed</em> lexicographic termination proof while preserving the precise obstruction to a monolithic <code>μ</code> argument. Downstream development should proceed (confluence, arithmetic, equality). Pure <code>μ</code> refinement remains an orthogonal, non‑blocking research activity.<br>
<br>
End of Document.<br>
<br>
---<br>
<br>
## 18. Catalogue of Unsuccessful / Abandoned SN Approaches (For Avoidance)<br>
<br>
This section records concrete strategies that were attempted and <em>why</em> they failed, to prevent rerunning the same dead ends.<br>
<br>
| Attempt Code | Short Name | Core Idea | Failure Mode | Lesson |<br>
|--------------|------------|----------|--------------|--------|<br>
| A1 | Raw Right-Add Transport | Derive <code>(μ n < μ (delta n)) ⇒ μ n + μ s + c < μ (delta n) + μ s + c</code> for arbitrary <code>s</code> | Ordinal right addition not strictly monotone; counterexamples where <code>μ s</code> is large limit obliterate strictness | Cannot recover strictness on the left by adding an uncontrolled right tail. Need dominance or lex tier |<br>
| A2 | <code>add_lt_add_right</code> Overuse | Force strictness by rewriting goals to fit <code>add_lt_add_right</code> | Lemma requires <em>same</em> addend; we have differing complex tails; attempted coercions produced ill-typed or circular goals | Do not coerce goal shapes into generic lemmas when structural asymmetry exists |<br>
| A3 | Finite Padding Escalation | Increase finite offsets (<code>+6</code>, <code>+9</code>, etc.) hoping gaps survive right-add | Finite bumps drown under large limit <code>μ s</code>; does not influence principal part absorption | Finite offsets only help inside already bounded contexts, not against arbitrary large added summands |<br>
| A4 | Tower Multiplication Reorientation | Swap ordering <code>(ω^k)<em>(μ n + 1)</code> vs <code>(μ n + 1)</em>ω^k</code> to mine monotonicity | Ordinal multiplication non‑commutative; reorientation invalid; required unsupported equalities | Respect directionality; avoid heuristic commutations not justified by lemmas |<br>
| A5 | Collapsing via <code>simp</code> Aggression | Heavy <code>simp</code> hoping to expose trivial inequalities | Over-simplification erased stratification markers, generating harder mixed goals or timeouts | Keep controlled rewriting; preserve tower structure for principal lemmas |<br>
| A6 | Inject Synthetic Bound <code>μ s ≤ μ (delta n)</code> | Assume (false) ordering to push inequality through sum | Demonstrably false (constructed counterexample with deeper <code>s</code>) | Never posit cross‑parameter bounds without structural invariants |<br>
| A7 | Unconditional Tail Domination Lemma | Propose <code>μ s + c < ω^5*(μ n + 1)</code> universally | Fails when <code>μ s</code> itself introduces higher dynamic tower (e.g. nested recΔ) | Tail domination must be conditional or tracked via auxiliary measure |<br>
| A8 | Recursive Unfolding Loop | Expand both sides of Rec‑S repeatedly to compare exponents | Leads to infinite expansion pattern; no well‑founded metric for closure | Avoid unfolding that increases syntactic size without pathway to principal comparison |<br>
| A9 | Mixed Tactic Brute Force (<code>linarith</code>, <code>ring</code>) | Numeric tactic attempts on ordinal goals | Tactics tuned for semirings over ℕ/ℤ; ordinal non‑commutativity & non‑cancellation defeat them | Use ordinal‑specific lemmas; numeric tactics only for finite sub‑arithmetics |<br>
| A10 | Direct Exponent Difference Encoding | Introduce δΔ := <code>(μ (delta n) + μ s + 6) - (μ n + μ s + 6)</code> and show δΔ > 0 | Ordinals lack subtraction behaving like naturals; difference not constructive for strictness under addition | Avoid pseudo‑subtractive encodings; rely on monotonicity lemmas |<br>
<br>
### Consolidated Lessons<br>
1. <strong>Right Addition Hazard:</strong> Strict inequalities cannot be safely transported to the left of an uncontrolled right addend in ordinals.<br>
2. <strong>Finite Offsets Are Insufficient:</strong> Offsets help only within dominated segments; they do not enforce global dominance.<br>
3. <strong>Structure Preservation:</strong> Over-aggressive simplification obscures the hierarchical tower layout essential for principal absorption.<br>
4. <strong>Auxiliary Measures Are Legitimate:</strong> Lexicographic augmentation (e.g., <code>(κ, μ)</code>) is not a defeat but a structured encapsulation of hidden complexity.<br>
5. <strong>Local vs Global:</strong> Lemmas must state explicit domination hypotheses; assuming universality where only locality holds leads to unsalvageable proof branches.<br>
<br>
### Positive Guidance (Do Instead)<br>
* Use lexicographic <code>(κ, μ)</code> to conclude SN, then refactor measure architecture offline.<br>
<em> When seeking pure μ refinements, design δ exponent tiers so their </em>constructor level* cannot be matched by any <code>s</code> appearing in the same rule instance.<br>
* Encapsulate any future domination assumption as a clearly parameterized lemma, never inline.<br>
<br>
---<br>
<br>
<br>

</body>
</html>
