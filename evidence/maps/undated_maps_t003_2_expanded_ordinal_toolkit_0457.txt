CONSOLIDATED GROUP: 2_expanded_ordinal_toolkit
GROUP ID: T003
FILES: 3

BEGIN FILE: C:\Users\Moses\OpComp\MUST_Review\2.Expanded_Ordinal_Toolkit.md
LAST WRITE UTC: 2025-08-18T04:09:47.7884982Z
SIZE BYTES: 50828


# EXECUTION CONTRACT (STRICT)

**Read this first. Obey it exactly. If you can’t, say so.**

## A+. Branch-by-branch rfl Gate (operational)

Before asserting any equation about a pattern-matched function `f`:
1) Enumerate each defining clause (constructors).
2) For each clause, attempt `rfl`. Record success/failure.
3) If any branch fails, you MUST:
   - Name the failing branch (constructor pattern).
   - State the correct per-branch equality or inequality.
   - Forbid any “global” rewrite of `f` unless it is rfl in all branches.

You MUST provide a minimal counterexample if you believe a global law holds but a branch fails (e.g., `n = delta m` for `kappa (recΔ b s n)`).

## B+. Duplication Stress-Test Protocol

If a rule duplicates a subterm `S`:
1) Exhibit the additive failure: for your measure `M`,
   `M(after) = M(before) − 1 + M(S)` (or stronger), and explain why this does not strictly drop when `M(S) ≥ 1`.
2) Only then propose a robust fix:
   - Either Dershowitz–Manna multiset extension over a well-founded base `<`.
   - Or MPO/RPO with an explicit precedence and status.
3) State and check the key premise: every RHS element is strictly `<` the removed LHS redex under the chosen base. If you cannot establish this, ADMIT FAILURE (CONSTRAINT BLOCKER).

## C+. Ordinal Hazard Checklist (must cite hypotheses)

You MUST state the hypotheses whenever you use:
- Right-add monotonicity: DO NOT use `<` transport over `x + c` without a lemma and its hypotheses.
- Absorption: `(n : Ordinal) + p = p` only after `omega0 ≤ p`.
- Exponent monotonicity: use base `ω` normality for `opow`, and specify direction (exponent-side).
- Mul monotonicity: specify side and positivity.

## D+. NameGate + TypeGate (prove existence & arity)

- NameGate: Before using any lemma/symbol, provide `SEARCH(name) → k hits` with file paths. If 0 hits, define it or raise a CONSTRAINT BLOCKER.
- TypeGate: Show the intended type/arity (e.g., “expects Nat → Nat, gave 2 args”) before applying.

## E+. Lexicographic Proof Gate

To conclude `(κ, μ)` lex decrease, present:
- Left-drop: `κ(after) < κ(before)`, or
- Tie+right: `κ(after) = κ(before)` (branchwise rfl-checked) and `μ(after) < μ(before)`.
If κ equality is not rfl per-branch, DO NOT claim a global tie.

## F. Stop-the-line Triggers (hard)

Immediately raise a CONSTRAINT BLOCKER if:
- Any branch fails rfl for a claimed equality and you need that equality globally.
- A rule duplicates `S` and you have only an additive measure.
- You rely on right-add or absorption on ordinals without stated proofs.
- You propose “κ + k” for a fixed k; you must first give the nested-delta tie counterexample.

## G. Deliverables (tightened)

- Taxonomy of failures (observed).
- Two minimal examples:
  1) Case-split failure (e.g., `kappa recΔ` delta vs non-delta).
  2) Duplication failure (`ρ` on `merge`) + the DM multiset premise.
- Guardrails you applied (which gates passed/blocked).
- Self-audit: at least two repo-specific failure modes (e.g., κ differs across files; lemma not exported/private) and a detection plan (SEARCH=0; rfl-branch mismatch).




# Expanded Ordinal Toolkit - Complete Reference

This document consolidates all information on ordinal tactics, syntax, lemma construction, patterns, best practices, and failed attempts. All content is presented verbatim from source documents.

---

## 1. IMPORT & LIBRARY AUDIT (Authoritative)

> Use exactly these modules; the right‑hand column clarifies *what is found where*. Generic ordered‑monoid lemmas must **not** be used for ordinal multiplication unless explicitly noted.

| Area                          | Correct import                                   | Contains / Notes                                                                                                                                                 |
| ----------------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| WF/Acc                        | `Init.WF`                                        | `WellFounded`, `Acc`, `InvImage.wf`, `Subrelation.wf`                                                                                                            |
| Prod lex orders               | `Mathlib.Data.Prod.Lex`                          | `Prod.Lex` for lexicographic measures                                                                                                                            |
| Ordinal basics                | `Mathlib.SetTheory.Ordinal.Basic`                | `omega0_pos`, `one_lt_omega0`, `lt_omega0`, `nat_lt_omega0`                                                                                                      |
| Ordinal arithmetic            | `Mathlib.SetTheory.Ordinal.Arithmetic`           | `Ordinal.add_*`, `Ordinal.mul_*`, `Ordinal.mul_lt_mul_of_pos_left`, `Ordinal.mul_le_mul_iff_left`, primed `mul_le_mul_left'`/`mul_le_mul_right'`, `le_mul_right` |
| Ordinal exponentiation        | `Mathlib.SetTheory.Ordinal.Exponential`          | `opow`, `opow_add`, `Ordinal.opow_le_opow_right`, `isNormal_opow`                                                                                                |
| Successor helpers             | `Mathlib.Algebra.Order.SuccPred`                 | `Order.lt_add_one_iff`, `Order.add_one_le_of_lt`                                                                                                                 |
| ℕ‑casts (order bridges)       | `Mathlib.Data.Nat.Cast.Order.Basic`              | `Nat.cast_le`, `Nat.cast_lt`                                                                                                                                     |
| Tactics                       | `Mathlib.Tactic.Linarith`, `Mathlib.Tactic.Ring` | `linarith`, `ring` (both whitelisted)                                                                                                                            |
| **Generic monoid inequality** | `Mathlib.Algebra.Order.Monoid.Defs`              | **Generic** `mul_le_mul_left` — do **not** use it for ordinal products.                                                                                          |

**Minimal import prelude (copy‑paste):**

```lean
import Init.WF
import Mathlib.Data.Prod.Lex
import Mathlib.SetTheory.Ordinal.Basic
import Mathlib.SetTheory.Ordinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Exponential
import Mathlib.Algebra.Order.SuccPred
import Mathlib.Data.Nat.Cast.Order.Basic
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Ring
open Ordinal
```

**Additional Import (for additive principal ordinals):**
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

## 2. QUALIFICATION RULES (Must appear verbatim at call‑sites)

- **Exponent (≤‑mono):** call `Ordinal.opow_le_opow_right` (never the bare name).
- **Exponent (<‑monotone at base ω):** use the **local** theorem `opow_lt_opow_right` defined in §5.
- **Products:** prefer `Ordinal.mul_lt_mul_of_pos_left` and `Ordinal.mul_le_mul_iff_left` (or `mul_le_mul_left'`/`mul_le_mul_right'`) — these are the **ordinal** APIs.
- **Successor bridge:** call `Order.lt_add_one_iff` / `Order.add_one_le_of_lt` with the `Order.` prefix.

## 3. LEMMA CATALOGUE (Names, Signatures, Modules)

### 3.1 Basics & Positivity

- `omega0_pos : 0 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `one_lt_omega0 : 1 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `lt_omega0 : o < omega0 ↔ ∃ n : ℕ, o = n`  — *module:* `SetTheory.Ordinal.Basic`
- `nat_lt_omega0 : ∀ n : ℕ, (n : Ordinal) < omega0`  — *module:* `SetTheory.Ordinal.Basic`

### 3.2 Addition & Successor

- `add_lt_add_left  : a < b → c + a < c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_lt_add_right : a < b → a + c < b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_left  : a ≤ b → c + a ≤ c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_right : a ≤ b → a + c ≤ b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`  — *module:* `Algebra.Order.SuccPred`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`  — *module:* `Algebra.Order.SuccPred`

**Absorption on infinite right addends:**
- `Ordinal.one_add_of_omega_le : omega0 ≤ p → (1 : Ordinal) + p = p`
- `Ordinal.natCast_add_of_omega_le : omega0 ≤ p → (n : Ordinal) + p = p`

**Absorption shorthands:**
```lean
theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) : (1 : Ordinal) + p = p :=
  by simpa using (Ordinal.one_add_of_omega_le (p := p) h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) : (n : Ordinal) + p = p :=
  by simpa using (Ordinal.nat_add_of_omega_le (p := p) (n := n) h)
```

### 3.3 Multiplication (Ordinal‑specific)

- `Ordinal.mul_lt_mul_of_pos_left : a < b → 0 < c → c * a < c * b`
- `Ordinal.mul_le_mul_iff_left   : c * a ≤ c * b ↔ a ≤ b`
- Primed monotone helpers: `mul_le_mul_left'`, `mul_le_mul_right'` (convenient rewriting forms).
- `le_mul_right : 0 < b → a ≤ b * a`.


> **Note:** `mul_le_mul_left` without a trailing apostrophe comes from `Algebra.Order.Monoid.Defs` and is **generic** (ordered monoids). Do **not** use it to reason about ordinal multiplication.

**Two‑sided product monotonicity (derived helper):**
```lean
/-- Two–sided monotonicity of `(*)` for ordinals, built from one–sided lemmas. -/
 theorem ord_mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left'  h₂ c)
  exact le_trans h₁' h₂'
```

### 3.4 Exponentiation (ω‑powers & normality)

- `opow_add : a ^ (b + c) = a ^ b * a ^ c` — split exponents.
- `opow_pos : 0 < a → 0 < a ^ b` — positivity of powers.
- `Ordinal.opow_le_opow_right : 0 < a → b ≤ c → a ^ b ≤ a ^ c` — **use fully‑qualified**.
- DOES NOT EXIST: `opow_mul_lt_of_exp_lt`
- The closest theorem in mathlib is `Ordinal.opow_mul_add_lt_opow_succ`: {b u v w : Ordinal} (hvb : v < b) (hw : w < b^u) : b^u * v + w < b^(Order.succ u)

### 3.5 Cast bridges (ℕ ↔ Ordinal)

```lean
@[simp] theorem natCast_le {m n : ℕ} : ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le
@[simp] theorem natCast_lt {m n : ℕ} : ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt
```

### 3.6 Finite vs. infinite split helper

```lean
theorem eq_nat_or_omega0_le (p : Ordinal) : (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  => rcases (lt_omega0).1 h with ⟨n, rfl⟩; exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h
```

### 3.7 Additive Principal Ordinals

```lean
lemma omega_pow_add3_lt {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  have h1 := hprin hα hβ  -- α + β < ω^κ
  exact hprin h1 hγ       -- (α + β) + γ < ω^κ
```

## 4. TRAFFIC LIGHT SYSTEM FOR LEMMAS

| Colour    | Rule of thumb                                           | Examples                                                                             |
| --------- | ------------------------------------------------------- | -------------------------------------------------------------------------------------|
| **Green** | Ordinal-specific or left-monotone lemmas                | `add_lt_add_left`, `mul_lt_mul_of_pos_left`, `le_mul_right`                          |
| **Amber** | Generic lemmas that satisfy the 4-point rule            | `mul_le_mul_left'`, `add_lt_add_of_lt_of_le`                                         |
| **Red**   | Breaks rule 2 (needs right-strict mono / commutativity) | `add_lt_add_right`, `mul_lt_mul_of_pos_right`                                        |

## 5. LOCAL BRIDGES & PATTERNS

**Local strict‑mono for ω‑powers (replacement for deprecated upstream lemma):**
```lean
/-- Strict‑mono of ω‑powers in the exponent (base `omega0`). --/
@[simp] theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
  omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)
```

*Why this is correct:* `isNormal_opow` states that, for `a > 1`, the map `b ↦ a ^ b` is normal (continuous, strictly increasing). With `a := omega0` and `one_lt_omega0`, `strictMono` yields exactly `<` from `<` in the exponent, which is what we need in μ‑decrease proofs.

## 6. μ‑MEASURE PLAYBOOK (Used across all rule proofs)

**Goal form:** for each kernel rule `Step t u`, show `mu u < mu t`. Typical shape reduces to chains like:

```
ω^κ * (x + 1) ≤ ω^(x + κ')
```

**Standard ladder (repeatable):**

1. **Assert base positivity:** `have ωpos : 0 < omega0 := omega0_pos`.
2. **Lift inequalities through exponents:** use `Ordinal.opow_le_opow_right ωpos h` for `≤`, and the local `opow_lt_opow_right` for `<`.
3. **Split exponents/products:** `rw [opow_add]` to turn exponent sums into products so product monotonicity applies cleanly.
4. **Move (≤) across products:** use `Ordinal.mul_le_mul_iff_left`, `mul_le_mul_left'`, `mul_le_mul_right'`; for `<` use `Ordinal.mul_lt_mul_of_pos_left` with a positive left factor.
5. **Absorb finite addends:** once `omega0 ≤ p`, rewrite `(n:Ordinal) + p = p` (or `1 + p = p`).
6. **Bridge successor:** convert `x < y + 1` ↔ `x ≤ y` via `Order.lt_add_one_iff`; introduce `x + 1 ≤ y` via `Order.add_one_le_of_lt` when chaining.
7. **Clean arithmetic noise:** `simp` for associativity/neutral elements; `ring` or `linarith` only for integer‑arithmetic side‑conditions (both tactics are whitelisted).

## 7. CRITICAL CORRECTION FOR `recΔ b s n` (μ‑rules)

Do **not** try to relate `mu s` and `mu (delta n)`. They are **independent parameters**; the inequality `mu s ≤ mu (delta n)` is **false in general**. A simple counterexample (compiles in this codebase):

```lean
def s : Trace := delta (delta void)      -- μ s begins with a higher ω‑tower
def n : Trace := void                     -- μ (delta n) is strictly smaller
-- here: mu s > mu (delta n) - assumption is FALSE
```

Structure μ‑decrease proofs without assuming any structural relation between `s` and `n` beyond what the rule's right‑hand side entails.

## 8. UNIVERSE LEVEL INFERENCE FIXES

**Root Cause Discovered**: Function definition `mu : Trace → Ordinal` caused universe polymorphism issues throughout entire codebase.

**Solution**: Change to `mu : Trace → Ordinal.{0}` → ALL universe errors eliminated

**Before Fix**: 25+ universe level inference errors across file
**After Fix**: Zero universe errors - complete elimination

```lean
-- Root cause solution:
mu : Trace → Ordinal.{0}  -- NOT mu : Trace → Ordinal

-- Additional pattern when needed:
have κ_pos : (0 : Ordinal) < mu a + mu b + 4 := by
  apply Ordinal.pos_iff_ne_zero.mpr
  intro h
  have : (4 : Ordinal) = 0 := by
    rw [← add_zero (4 : Ordinal), ← h]
    simp [add_assoc]
  norm_num at this
```

## 9. WORKING PROOF PATTERNS

**Universe Level Resolution**:
```lean
-- Pattern from lines 866-867 (WORKING):
have κ_pos : (0 : Ordinal) < A := by
  rw [hA]  -- where A := ω^(μ(δn) + μs + 6)
  exact Ordinal.opow_pos (b := mu (delta n) + mu s + 6) (a0 := omega0_pos)
```

**Omega Power Positivity**:
```lean
-- Pattern from lines 52, 67, 127, 151, 867 (WORKING):
have hb : 0 < (omega0 ^ (5 : Ordinal)) :=
  (Ordinal.opow_pos (b := (5 : Ordinal)) (a0 := omega0_pos))
```

**Power Monotonicity**:
```lean
-- Pattern from line 565 (WORKING):
exact Ordinal.opow_le_opow_right omega0_pos h

-- Pattern from line 693 (WORKING):
exact opow_lt_opow_right h_exp
```

**Ordinal Arithmetic**:
```lean
-- Pattern from lines 400, 407, 422 (WORKING):
simp [add_assoc, add_comm, add_left_comm]
```

**Ordinal Commutativity Solutions**:
```lean
-- Direct monotonicity approach (avoids commutativity):
have h_bound : mu b + 3 ≤ mu a + mu b + 3 := by
  apply add_le_add_right; exact zero_le _ 
have h_final : mu a + mu b + 3 < mu a + mu b + 4 := by
  apply add_lt_add_left; norm_num
exact le_trans h_bound (le_of_lt h_final)
```

## 10. ORDER.succ vs `+ 1` (Bridge & Hygiene)

Lean will often rewrite `p + 1` to `Order.succ p` in goals. Work with the `Order` lemmas:

- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`

Keep the `Order.` prefix to avoid name resolution issues. Avoid inventing `succ_eq_add_one`—rely on these bridges instead.

## 11. Additive Principal Ordinals (Extended)

Verbatim consolidation (Additive_Principal_Ordinals report):

Required import:
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

Authoritative lemma:
```lean
theorem Ordinal.principal_add_omega0_opow (o : Ordinal) :
  Principal (fun (x1 x2 : Ordinal) => x1 + x2) (omega0 ^ o)
```

Meaning:
```
Principal (fun x1 x2 => x1 + x2) (omega0 ^ κ)
≡ ∀ {a b}, a < omega0 ^ κ → b < omega0 ^ κ → a + b < omega0 ^ κ
```

Direct usage pattern:
```lean
lemma omega_pow_add_lt {κ α β : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ
```

Three‑term chaining (already in §3.7): leverages closure of additive principal ordinal under repeated application.

Related absorption lemmas (Mathlib; ensure import present):
`Ordinal.add_absorp`, `Ordinal.principal_add_omega0` (ω itself is additive principal).

## 12. Failure & Anti‑Pattern Catalogue

| Category | Bad Pattern | Why Invalid / Fix |
|----------|-------------|-------------------|
| Generic mul | `mul_le_mul_left` (unqualified) | Generic ordered monoid; use `mul_le_mul_left'` or ordinal‑specific lemmas |
| Missing qual | `opow_le_opow_right` (bare) | Must use `Ordinal.opow_le_opow_right` for clarity & rule adherence |
| Deprecated | `Ordinal.opow_lt_opow_right` (old upstream) | Replaced by local `opow_lt_opow_right` bridging `isNormal_opow` |
| Right monotonicity | `a < b → a + c < b + c` (strict) | Ordinal addition not strictly right‑monotone; restructure via left additions or exponent lift |
| Hidden assumption | `μ s ≤ μ (delta n)` | False (see §7 counterexample); remove from reasoning |
| Universe drift | `mu : Trace → Ordinal` | Causes polymorphism cascade; fix to `Ordinal.{0}` |
| Name hallucination | `Ordinal.isAdditivePrincipal_omega_pow` | Correct name: `Ordinal.principal_add_omega0_opow` |
| Silent absorption | Using `(n : Ordinal) + p = p` without `omega0 ≤ p` | Must establish infinitude precondition, often via exponent bound |

## 13. Extended Red / Amber Lists

Red (forbidden):
- Unqualified critical lemmas (`opow_add`, `mul_lt_mul_of_pos_left` without `Ordinal.`)
- Generic right‑monotone additive inequalities
- Any unsourced new lemma (absent from search & toolkit)
- Introduction of `sorry` to bypass ordinal arithmetic.

Amber (caution):
- `add_lt_add_right` (allowed but watch right‑add context precedence)
- `add_comm` / `add_left_comm` (use only where commutativity is mathematically harmless; ordinal addition non‑commutativity at higher structure remains)

Green (preferred patterns):
- Qualified exponent/multiplication lemmas
- Local `opow_lt_opow_right`
- Additive principal chaining with `principal_add_omega0_opow`
- Structured μ‑ladder (see §6) with explicit positivity & absorption steps.

## 14. Lexicographic Measure Interfaces (Preview Pointer)

While full termination chronology belongs to the termination consolidation, ordinal tooling must support lexicographic measures `(κ, μ)`:

```lean
def LexNatOrd : (ℕ × Ordinal) → (ℕ × Ordinal) → Prop :=
  Prod.Lex (· < ·) ((· < ·) : Ordinal → Ordinal → Prop)

lemma μ_to_μκ {t t'} (hμ : mu t' < mu t) (hk : kappa t' = kappa t) :
  LexNatOrd (μκ t') (μκ t) := by
  unfold LexNatOrd μκ
  apply Prod.Lex.right
  simpa [hk]
```

Key constructor patterns (must copy verbatim): `Prod.Lex.left` and `Prod.Lex.right`.

## 15. Provenance Index

| Section | Sources |
|---------|---------|
| 1–6 | ordinal-toolkit.md; agent.md; Project Bible |
| 7 | ordinal-toolkit.md; termination companion notes |
| 8 | Project Bible universe fix section |
| 9 | TerminationBase / Termination_C pattern extraction logs |
| 10 | ordinal-toolkit.md |
| 11 | Additive_Principal_Ordinals (1).txt |
| 12 | Mathematical_Lemma_Usage_Analysis.md; Additive_Principal_Ordinals report |
| 13 | Consolidated red/amber lists (project docs) |
| 14 | Termination_Companion*.md (lexicographic snippets) |
| 15 | Aggregated mapping |

## 16. Open Ordinal Tasks / Research Threads

| Topic | Description | Status |
|-------|-------------|--------|
| Pure μ rec_succ strict decrease | Replace lexicographic fallback with single ordinal measure | Research (blocked by right-add strictness) |
| Automation DSL (`OrdinalDominates`) | Early proposal to catch impossible inequalities | Design stage (Termination_Companion) |
| Additive principal generalization | Broader principal families beyond ω^κ usage | Optional enhancement |
| Absorption lemma catalog | Systematic capture of all `add_absorp` variants | Pending |


## 11. ADMISSIBLE LEMMA RULE-SET ("Green channel")

**Completeness note** — The lemma catalogue is intentionally minimal.  
- Any mathlib lemma that satisfies the **four-point rule-set below** *may* be used **even if** not yet listed, as long as the first use appends a one-liner to `ordinal-toolkit.md`.

1. **No new axioms:** the file introducing it adds no axioms (`#print axioms` CI-check).
2. **Correct structures:** its type-class constraints are satisfied by `Ordinal`
   (⇝ no hidden commutativity / `AddRightStrictMono`, etc.).
3. **Tidy import footprint:** the file pulls in ≤ 100 new declarations, or is
   already in the project dep-graph.
4. **Kernel-safe proof:** the lemma is not `unsafe` and contains no `meta`
   code.

The first use of an admissible lemma **must** append it (one-liner) to
*ordinal-toolkit.md*; later uses need no paperwork.

## 12. DO‑NOT‑USE / DEPRECATED IN THIS PROJECT

- **Generic** `mul_le_mul_left` (from `Algebra.Order.Monoid.Defs`) on ordinal goals. Use `Ordinal.mul_*` APIs instead.
- Old paths `Mathlib.Data.Ordinal.*` — replaced by `Mathlib.SetTheory.Ordinal.*`.
- `Ordinal.opow_lt_opow_right` (upstream removed). Use the **local** `opow_lt_opow_right` defined in §5.
- `le_of_not_lt` (deprecated) — use `le_of_not_gt`.

## 13. READY‑MADE SNIPPETS

**Nat‑sized measure (optional helper):**
```lean
@[simp] def size : Trace → Nat
| void => 1
| delta t => size t + 1
| integrate t => size t + 1
| merge a b => size a + size b + 1
| recΔ b s n => size b + size s + size n + 1
| eqW a b => size a + size b + 1

theorem step_size_decrease {t u : Trace} (h : Step t u) : size u < size t := by
  cases h <;> simp [size]; linarith
```

**WF via ordinal μ:**
```lean
def StepRev : Trace → Trace → Prop := fun a b => Step b a

theorem strong_normalization_forward
  (dec : ∀ {a b}, Step a b → mu b < mu a) : WellFounded (StepRev Step) := by
  have wfμ : WellFounded (fun x y : Trace => mu x < mu y) := InvImage.wf (f := mu) Ordinal.lt_wf
  have sub : Subrelation (StepRev Step) (fun x y => mu x < mu y) := by intro x y h; exact dec h
  exact Subrelation.wf sub wfμ
```

## 14. HELPER LEMMAS FROM TERMINATION_LEGACY.LEAN

```lean
theorem lt_add_one_of_le {x y : Ordinal} (h : x ≤ y) : x < y + 1 :=
  (Order.lt_add_one_iff (x := x) (y := y)).2 h

theorem le_of_lt_add_one {x y : Ordinal} (h : x < y + 1) : x ≤ y :=
  (Order.lt_add_one_iff (x := x) (y := y)).1 h

private lemma le_omega_pow (x : Ordinal) : x ≤ omega0 ^ x :=
  right_le_opow (a := omega0) (b := x) one_lt_omega0

theorem add_one_le_of_lt {x y : Ordinal} (h : x < y) : x + 1 ≤ y := by
  simpa [Ordinal.add_one_eq_succ] using (Order.add_one_le_of_lt h)

private lemma nat_coeff_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ (omega0 ^ (n : Ordinal)) := by
  classical
  cases' n with n
  · -- `n = 0`: `1 ≤ ω^0 = 1`
    simp
  · -- `n = n.succ`

    have hfin : (n.succ : Ordinal) < omega0 := by

      simpa using (Ordinal.nat_lt_omega0 (n.succ))
    have hleft : (n.succ : Ordinal) + 1 ≤ omega0 :=
      Order.add_one_le_of_lt hfin

    have hpos : (0 : Ordinal) < (n.succ : Ordinal) := by
      simpa using (Nat.cast_pos.mpr (Nat.succ_pos n))
    have hmono : (omega0 : Ordinal) ≤ (omega0 ^ (n.succ : Ordinal)) := by
      -- `left_le_opow` has type: `0 < b → a ≤ a ^ b`
      simpa using (Ordinal.left_le_opow (a := omega0) (b := (n.succ : Ordinal)) hpos)

    exact hleft.trans hmono

private lemma coeff_fin_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ omega0 ^ (n : Ordinal) := nat_coeff_le_omega_pow n

@[simp] theorem natCast_le {m n : ℕ} :
  ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le

@[simp] theorem natCast_lt {m n : ℕ} :
  ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt

theorem eq_nat_or_omega0_le (p : Ordinal) :
  (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  =>
      rcases (lt_omega0).1 h with ⟨n, rfl⟩
      exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h

theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) :
  (1 : Ordinal) + p = p := by
  simpa using (Ordinal.one_add_of_omega0_le h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) :
  (n : Ordinal) + p = p := by
  simpa using (Ordinal.natCast_add_of_omega0_le (n := n) h)

@[simp] theorem add_natCast_left (m n : ℕ) :
  (m : Ordinal) + (n : Ordinal) = ((m + n : ℕ) : Ordinal) := by
  induction n with
  | zero =>
      simp
  | succ n ih =>
      simp [Nat.cast_succ]

theorem mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)        -- mono in left factor
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left' h₂ c)         -- mono in right factor
  exact le_trans h₁' h₂'

theorem add4_plus5_le_plus9 (p : Ordinal) :
  (4 : Ordinal) + (p + 5) ≤ p + 9 := by
  classical
  rcases lt_or_ge p omega0 with hfin | hinf
  · -- finite case: `p = n : ℕ`
    rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    -- compute on ℕ first
    have hEqNat : (4 + (n + 5) : ℕ) = (n + 9 : ℕ) := by
      -- both sides reduce to `n + 9`
      simp [Nat.add_left_comm]
    have hEq :
        (4 : Ordinal) + ((n : Ordinal) + 5) = (n : Ordinal) + 9 := by
      calc
        (4 : Ordinal) + ((n : Ordinal) + 5)
            = (4 : Ordinal) + (((n + 5 : ℕ) : Ordinal)) := by
                simp
        _   = ((4 + (n + 5) : ℕ) : Ordinal) := by
                simp
        _   = ((n + 9 : ℕ) : Ordinal) := by
                simpa using (congrArg (fun k : ℕ => (k : Ordinal)) hEqNat)
        _   = (n : Ordinal) + 9 := by
                simp
    exact le_of_eq hEq
  · -- infinite-or-larger case: the finite prefix on the left collapses
    -- `5 ≤ 9` as ordinals
    have h59 : (5 : Ordinal) ≤ (9 : Ordinal) := by
      simpa using (natCast_le.mpr (by decide : (5 : ℕ) ≤ 9))
    -- monotonicity in the right argument
    have hR : p + 5 ≤ p + 9 := by
      simpa using add_le_add_left h59 p
    -- collapse `4 + p` since `ω ≤ p`
    have hcollapse : (4 : Ordinal) + (p + 5) = p + 5 := by
      calc
        (4 : Ordinal) + (p + 5)
            = ((4 : Ordinal) + p) + 5 := by
                simp [add_assoc]
        _   = p + 5 := by
                have h4 : (4 : Ordinal) + p = p := nat_left_add_absorb (n := 4) (p := p) hinf
                rw [h4]
    simpa [hcollapse] using hR

theorem add_nat_succ_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + Order.succ p ≤ p + (k + 1) := by
  rcases lt_or_ge p omega0 with hfin | hinf
  · rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    have hN : (k + (n + 1) : ℕ) = n + (k + 1) := by
      simp [Nat.add_left_comm]
    have h :
        (k : Ordinal) + ((n : Ordinal) + 1) = (n : Ordinal) + (k + 1) := by
      calc
        (k : Ordinal) + ((n : Ordinal) + 1)
            = ((k + (n + 1) : ℕ) : Ordinal) := by simp
        _   = ((n + (k + 1) : ℕ) : Ordinal) := by
              simpa using (congrArg (fun t : ℕ => (t : Ordinal)) hN)
        _   = (n : Ordinal) + (k + 1) := by simp
    have : (k : Ordinal) + Order.succ (n : Ordinal) = (n : Ordinal) + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using h
    exact le_of_eq this
  ·
    have hk : (k : Ordinal) + p = p := nat_left_add_absorb (n := k) hinf
    have hcollapse :
        (k : Ordinal) + Order.succ p = Order.succ p := by
      simpa [Ordinal.add_succ] using congrArg Order.succ hk
    have hkNat : (1 : ℕ) ≤ k + 1 := Nat.succ_le_succ (Nat.zero_le k)
    have h1k : (1 : Ordinal) ≤ (k + 1 : Ordinal) := by
      simpa using (natCast_le.mpr hkNat)
    have hstep0 : p + 1 ≤ p + (k + 1) := add_le_add_left h1k p
    have hstep : Order.succ p ≤ p + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using hstep0
    exact (le_of_eq hcollapse).trans hstep

theorem add_nat_plus1_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + (p + 1) ≤ p + (k + 1) := by
  simpa [Ordinal.add_one_eq_succ] using add_nat_succ_le_plus_succ k p

theorem add3_succ_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + Order.succ p ≤ p + 4 := by
  simpa using add_nat_succ_le_plus_succ 3 p

theorem add2_succ_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + Order.succ p ≤ p + 3 := by
  simpa using add_nat_succ_le_plus_succ 2 p

theorem add3_plus1_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + (p + 1) ≤ p + 4 := by
  simpa [Ordinal.add_one_eq_succ] using add3_succ_le_plus4 p

theorem add2_plus1_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + (p + 1) ≤ p + 3 := by
  simpa [Ordinal.add_one_eq_succ] using add2_succ_le_plus3 p

theorem lt_add_one (x : Ordinal) : x < x + 1 := lt_add_one_of_le (le_rfl)

theorem mul_succ (a b : Ordinal) : a * (b + 1) = a * b + a := by
  simpa [mul_one, add_comm, add_left_comm, add_assoc] using
    (mul_add a b (1 : Ordinal))

/-- **Strict** monotone: `b < c → ω^b < ω^c`. -/
theorem opow_lt_opow_ω {b c : Ordinal} (h : b < c) :
    omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

theorem opow_le_opow_ω {p q : Ordinal} (h : p ≤ q) :
    omega0 ^ p ≤ omega0 ^ q := by
  exact Ordinal.opow_le_opow_right omega0_pos h   -- library lemma

theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
   omega0 ^ b < omega0 ^ c := by
  simpa using
   ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos
  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [Ordinal.opow_add] using (Ordinal.opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁
  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    Ordinal.opow_le_opow_right omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂

private lemma two_lt_three : (2 : Ordinal) < 3 := by
  have : (2 : ℕ) < 3 := by decide
  simpa using (Nat.cast_lt).2 this

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by

  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')

---

## 17. ERROR PATTERN LOG (VERBATIM INCIDENT FORMS)

Each entry: (Code / Symptom / Minimal Reproducer / Resolution Pattern)

EP1  Universe polymorphism cascade / `invalid universe level assignment` / `mu : Trace → Ordinal` / redefine as `mu : Trace → Ordinal.{0}`; recompile
EP2  Generic multiplication lemma misuse / goal `c * a ≤ c * b` with ordinals / attempted `mul_le_mul_left` / replace with `mul_le_mul_left'` or `Ordinal.mul_le_mul_iff_left`
EP3  Lost strictness after right addition / transformed `h : x < y` into `h' : x + z < y + z` / ordinal addition not strictly right‑monotone / restructure inequality via exponent lift then absorb finite tail
EP4  Unsound structural assumption / inserted `have : mu s ≤ mu (delta n)` / counterexample (double delta vs void) refutes; delete assumption and isolate needed dominance via auxiliary measure κ
EP5  Deprecated lemma name / used `Ordinal.opow_lt_opow_right` (removed) / error unknown identifier / introduce local `opow_lt_opow_right` via `isNormal_opow.strictMono`
EP6  Name hallucination / `Ordinal.isAdditivePrincipal_omega_pow` / rename to `Ordinal.principal_add_omega0_opow`
EP7  Absorption applied without infinitude proof / rewrote `(3 : Ordinal) + p` to `p` / missing `omega0 ≤ p` / first prove finite part < ω ≤ p; then apply `nat_left_add_absorb`
EP8  Over‑aggressive simp flattening / `simp [add_assoc, add_comm, add_left_comm]` removed tower grouping needed for `opow_add` alignment / limit simp scope (avoid comm/assoc when matching structured pattern)
EP9  Wrong orientation of multiplication / replaced `ω^k * X` with `X * ω^k` / ordinal multiplication non‑commutative / keep canonical left factor power for monotone lemmas
EP10 Misuse of `ring` on exponent goal / attempted `ring` on `omega0 ^ (a + b + 1)` equality / `ring` handles semiring arithmetic (ℕ/ℤ), not ordinal exponent formulas / use `opow_add` rewriting
EP11 Missing qualification / bare `opow_le_opow_right` ambiguous import path / fully qualify: `Ordinal.opow_le_opow_right`
EP12 Incorrect finite padding reasoning / attempted to force `μ a + 4 < μ a + 5` inside tail sum after rearrangement that lost left alignment / recover by explicit lemma `add_lt_add_left (by norm_num)`
EP13 Stalled search for strict chain / no progress `lt_of_le_of_lt` due to wrong order / reorder: derive `x ≤ y` then `y < z` not vice versa
EP14 Case split omission / handling `(void, void)` inside general eqW inequality produced stuck exponent comparison / perform `by_cases (a = void ∧ b = void)` first
EP15 Duplicate local lemma collision / redefining `omega_pow_add3_lt` second time / rename or reference existing definition; avoid shadowing for provenance clarity

## 18. SUCCESSFUL PATTERN SEQUENCES (CANONICAL TEMPLATES)

SP1  Head–Tail Merge Bounding:
  Input goal: `mu (merge a b) + 1 < ω^(C + 5)` with `C = μa + μb`
  Steps: termA_le → termB_le → exponent < (C+5) proofs → two opow monotonic lifts → combine via `omega_pow_add3_lt` including finite tail → rewrite μ definition

SP2  Integrate + Merge Elevation (eqW path):
  Start: `mu (integrate (merge a b))`
  Expansion: rewrite integrate layer `ω^4 * (...) + 1`; apply merge inner bound; multiply inequality by `ω^4`; use `opow_add`; absorption of finite 4 via `nat_left_add_absorb` using `ω ≤ μa + μb`; exponent bump from `C+5` to `C+9` with finite chain `(5 < 9)`; final add-one chain via `Order.add_one_le_of_lt`

SP3  Recursor Tail Isolation (legacy parameterized):
  Input inequality parameter `h_mu_recΔ_bound`
  Derive: tail_lt_A from termB_le + exponent chain; head_lt_A from termA_le; combine with additive principal triple sum; compare to expanded `μ(recΔ ...)`

SP4  Exponent Strictness Promotion:
  Known: `α < β`
  Derive: `omega0 ^ α < omega0 ^ β` via local `opow_lt_opow_right`; extend chain with `lt_of_le_of_lt` after an initial `≤` produced by product or additive estimates

SP5  Finite Absorption Safe Application:
  Show: `omega0 ≤ P`
  Then: use `nat_left_add_absorb (h := ‹omega0 ≤ P›)` to fold `(n : Ordinal) + P` to `P`

SP6  Two‑Stage Sum Comparison:
  Goal: `μb + k ≤ μa + μb + k`
  Use: `add_le_add_right (le_add_of_nonneg_left (zero_le _)) k` then follow with strict bump `add_lt_add_left (by norm_num)`

SP7  Triple Additive Principal Folding:
  Given three summands each `< ω^κ` plus finite tail `< ω^κ`
  Sequence: first combine two via `omega_pow_add_lt`; reapply with third; final associativity normalization `simpa [add_assoc]`

SP8  Finite → Exponent Positivity:
  Show `(0 : Ordinal) < m` for finite numeral `m`; then `lt_of_lt_of_le` to embed into larger expression like `μ(δ n) + μ s + m`

SP9  Product Left‑Strict Lift:
  With `γ < ω` and base positivity: derive `ω^β * γ < ω^β * ω`; rewrite right side to `ω^(β+1)` with `opow_add`; cascade to larger exponent with `opow_le_opow_right`

SP10 Merge Measure Reassociation:
  Normalize `mu (merge a b)` to `ω^3*(μa+1) + (ω^2*(μb+1) + 1)` using `simp [mu, add_assoc]` to align with additive principal template

## 19. ABSORPTION PRECONDITION CATALOGUE

AP1  `(n : Ordinal) + p = p` requires `omega0 ≤ p` (establish via exponent tower positivity or prior inequality)  
AP2  `(1 : Ordinal) + p = p` same requirement (use `one_left_add_absorb` wrapper)  
AP3  Folding `(k : Ordinal) + (p + m)` to `p + m` requires `omega0 ≤ p` not merely `ω ≤ p + m`  
AP4  Inside exponent adjustment `(c : Ordinal) + (C + d) = C + d` needs `(c : Ordinal) + C = C`; prove absorption first then reassociate  
AP5  Avoid absorption inside a product: cannot simplify `ω^n * ((m : Ordinal) + p)` by absorption; expand addition after multiplication not before

## 20. EXPONENT COMPARISON INVENTORY

EC1  Bumping finite suffix: `(C + k) < (C + m)` via `add_lt_add_left (by norm_num)` (k < m)  
EC2  Prefix insertion: `x ≤ y` implies `x + k ≤ y + k` (left additive monotone)  
EC3  Chaining: `α < β ≤ γ` becomes `α < γ` using `lt_of_lt_of_le`  
EC4  From strict to successor: `α < β` gives `α + 1 ≤ β` via `Order.add_one_le_of_lt`  
EC5  Exponent lift (≤): `h : a ≤ b` → `ω^a ≤ ω^b` via `Ordinal.opow_le_opow_right omega0_pos h`  
EC6  Exponent lift (<): `h : a < b` → `ω^a < ω^b` via local strictMono lemma  
EC7  Composite: `ω^a * (b+1)` bound by first bounding `(b+1)` then applying multiplication monotonicity then exponent comparison  
EC8  Finite stacking: `ω^(n) * ω^(m) = ω^(n+m)` using symmetry of `opow_add` orientation `(opow_add _ _ _).symm`

## 21. DEPRECATED / CORRECT NAME MAP

| Deprecated / Incorrect | Correct | Context |
|------------------------|---------|---------|
| `Ordinal.opow_lt_opow_right` | local `opow_lt_opow_right` | Removed upstream strict lemma |
| `isAdditivePrincipal_omega_pow` | `principal_add_omega0_opow` | Additive principal ordinal lemma |
| `Ordinal.nat_add_of_omega_le` | `Ordinal.natCast_add_of_omega0_le` | API rename variant (observed mismatch) |
| `one_add_of_omega_le` | `one_add_of_omega0_le` | Ensure explicit ω₀ subscript |
| `le_of_not_lt` | `le_of_not_gt` | Modern replacement |

## 22. TACTIC USAGE MATRIX

| Tactic | Allowed | Typical Scope | Prohibited Uses |
|--------|---------|---------------|-----------------|
| `simp` | Yes | Reassociating additions, unfolding μ constructors selectively | Blanket over entire large goal that removes stratification |
| `linarith` | Yes | Finite numeral comparisons inside exponent deltas | On ordinal exponentials (`omega0 ^ α`) directly |
| `ring` | Yes | Simplify finite Nat subgoals generated by casts | On ordinal multiplications/exponentiations |
| `norm_num` | Yes | Proving finite inequalities like `(3 : Ordinal) < 6` | Outside pure numeral contexts |
| `rewrite` | Yes | Applying specific `opow_add`, absorption equalities | Chasing equalities that increase size without progress |
| `library_search` | Caution | Discover admissible lemmas (green channel) | Accepting lemma without qualification/prefix audit |

## 23. SEARCH PROTOCOL EXEMPLAR

Example (looking for additive principal lemma):
  SEARCH(principal_add_omega0_opow) → Found 1 match
  Output permitted; lemma inserted verbatim.
Missing name example: SEARCH(isAdditivePrincipal_omega_pow) → 0 results – rename to `principal_add_omega0_opow` and record mapping (see §21).

## 24. PENDING GREEN‑CHANNEL CANDIDATES (Not Yet Used)

List placeholders (must search before first usage):
GC1  `Ordinal.mul_lt_mul_of_pos_right` (evaluate strictness side conditions)  
GC2  `Ordinal.add_right_cancel` (check applicability; beware non‑cancellation in some ordinal forms)  
GC3  `Ordinal.inductionOn` variants for structured recursion proofs  
GC4  `Ordinal.principal_mul_omega0_opow` (if upstream introduces multiplicative principal families)  

## 25. LEMMA USAGE LOCATION INDEX (LEGACY μ)

| Lemma | First Recorded Line (Termination_Legacy) | Purpose |
|-------|-------------------------------------------|---------|
| termA_le | ~290 | Bound ω³ head payload |
| termB_le | ~312 | Bound ω² tail payload |
| payload_bound_merge | ~330 | Combine head+tail+1 under ω^(x+5) |
| omega_pow_add3_lt | ~520 / ~700 | Triple additive principal composition |
| merge_inner_bound_simple | ~1030 | Inner bound for eqW chain |
| mu_lt_eq_diff_both_void | ~1080 | Corner case eqW inequality |
| mu_lt_eq_diff | ~1120 | General eqW inequality |
| tail_lt_A | ~860 | Recursor tail < dominant A tower |
| head_lt_A | ~650 | Recursor head < dominant A tower |

## 26. COUNTEREXAMPLES LIBRARY

CE1  False right‑add strictness:
  Let `a := omega0`, `b := omega0 + 1`, `c := omega0^2`. Then `a < b` but `a + c = c = b + c`.
CE2  Invalid μ parameter relation:
  `s := delta (delta void)`; `n := void`; then `mu s > mu (delta n)`.
CE3  Finite padding insufficiency:
  For large `t : Trace` with `mu t ≥ ω^(μ n + μ s + 6)`, inequality using only +4/+6 fails to separate exponents.
CE4  Multiplication commutativity assumption:
  `ω^2 * (ω^3 + 1) ≠ (ω^3 + 1) * ω^2` (structures differ in Cantor normal form ordering).
CE5  Absorption without infinitude:
  `(3 : Ordinal) + (5 : Ordinal) ≠ 5` though `(3 : Ordinal) + ω = ω`.

## 27. MINIMAL REWRITE ORDERING GUIDELINES

R1  Expand products after establishing additive bounds; do not expand early if it hides factorization needed for `opow_add`.
R2  Apply exponent comparisons before absorption to avoid losing monotonic structure.
R3  Preserve left‑nested additive shape for principal applications: `A + (B + C)` is acceptable; flatten only when lemma requires `A + B + C`.
R4  Avoid commuting finite and transfinite summands unless infinite right operand already proven (`omega0 ≤ p`).

## 28. FUTURE ORDINAL TOOLING TODO (FACTUAL BACKLOG)

T1  Catalogue every instance of `omega0 ^ (k : Ordinal)` usage with k ∈ {2,3,4,5,6,9} across μ lemmas (pending automated grep table)
T2  Record potential generalization of `omega_pow_add3_lt` to n‑ary list fold (requires recursive principal closure proof)
T3  Introduce explicit lemma: `finite_lt_power` : `(n : Ordinal) < omega0 ^ (k + 1)` for all finite k (derive via `nat_lt_omega0` + exponent monotonicity) — not yet formalized here
T4  Audit all absorptions to ensure each has proximal proof of `omega0 ≤ target` line above (scriptable lint)
T5  Provide CNF (Cantor normal form) commentary mapping for each μ constructor exponent tier (draft placeholder)

---

````
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp


  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')
```

END FILE: C:\Users\Moses\OpComp\MUST_Review\2.Expanded_Ordinal_Toolkit.md

BEGIN FILE: C:\Users\Moses\OpComp\MUST_Review\chats\2.Expanded_Ordinal_Toolkit.md
LAST WRITE UTC: 2025-08-18T15:53:28.6506219Z
SIZE BYTES: 44755

This file has moved. Please use the canonical copy in Submission_Material/md.

New location:
- Submission_Material/md/2.Expanded_Ordinal_Toolkit.md

Rationale: All paper-related Markdown is centralized under Submission_Material/md for the submission bundle. This stub exists to avoid broken links.

**Minimal import prelude (copy‑paste):**

```lean
import Init.WF
import Mathlib.Data.Prod.Lex
import Mathlib.SetTheory.Ordinal.Basic
import Mathlib.SetTheory.Ordinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Exponential
import Mathlib.Algebra.Order.SuccPred
import Mathlib.Data.Nat.Cast.Order.Basic
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Ring
open Ordinal
```

**Additional Import (for additive principal ordinals):**
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

## 2. QUALIFICATION RULES (Must appear verbatim at call‑sites)

- **Exponent (≤‑mono):** call `Ordinal.opow_le_opow_right` (never the bare name).
- **Exponent (<‑monotone at base ω):** use the **local** theorem `opow_lt_opow_right` defined in §5.
- **Products:** prefer `Ordinal.mul_lt_mul_of_pos_left` and `Ordinal.mul_le_mul_iff_left` (or `mul_le_mul_left'`/`mul_le_mul_right'`) — these are the **ordinal** APIs.
- **Successor bridge:** call `Order.lt_add_one_iff` / `Order.add_one_le_of_lt` with the `Order.` prefix.

## 3. LEMMA CATALOGUE (Names, Signatures, Modules)

### 3.1 Basics & Positivity

- `omega0_pos : 0 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `one_lt_omega0 : 1 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `lt_omega0 : o < omega0 ↔ ∃ n : ℕ, o = n`  — *module:* `SetTheory.Ordinal.Basic`
- `nat_lt_omega0 : ∀ n : ℕ, (n : Ordinal) < omega0`  — *module:* `SetTheory.Ordinal.Basic`

### 3.2 Addition & Successor

- `add_lt_add_left  : a < b → c + a < c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_lt_add_right : a < b → a + c < b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_left  : a ≤ b → c + a ≤ c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_right : a ≤ b → a + c ≤ b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`  — *module:* `Algebra.Order.SuccPred`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`  — *module:* `Algebra.Order.SuccPred`

**Absorption on infinite right addends:**
- `Ordinal.one_add_of_omega_le : omega0 ≤ p → (1 : Ordinal) + p = p`
- `Ordinal.natCast_add_of_omega_le : omega0 ≤ p → (n : Ordinal) + p = p`

**Absorption shorthands:**
```lean
theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) : (1 : Ordinal) + p = p :=
  by simpa using (Ordinal.one_add_of_omega_le (p := p) h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) : (n : Ordinal) + p = p :=
  by simpa using (Ordinal.nat_add_of_omega_le (p := p) (n := n) h)
```

### 3.3 Multiplication (Ordinal‑specific)

- `Ordinal.mul_lt_mul_of_pos_left : a < b → 0 < c → c * a < c * b`
- `Ordinal.mul_le_mul_iff_left   : c * a ≤ c * b ↔ a ≤ b`
- Primed monotone helpers: `mul_le_mul_left'`, `mul_le_mul_right'` (convenient rewriting forms).
- `le_mul_right : 0 < b → a ≤ b * a`.


> **Note:** `mul_le_mul_left` without a trailing apostrophe comes from `Algebra.Order.Monoid.Defs` and is **generic** (ordered monoids). Do **not** use it to reason about ordinal multiplication.

**Two‑sided product monotonicity (derived helper):**
```lean
/-- Two–sided monotonicity of `(*)` for ordinals, built from one–sided lemmas. -/
 theorem ord_mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left'  h₂ c)
  exact le_trans h₁' h₂'
```

### 3.4 Exponentiation (ω‑powers & normality)

- `opow_add : a ^ (b + c) = a ^ b * a ^ c` — split exponents.
- `opow_pos : 0 < a → 0 < a ^ b` — positivity of powers.
- `Ordinal.opow_le_opow_right : 0 < a → b ≤ c → a ^ b ≤ a ^ c` — **use fully‑qualified**.
- DOES NOT EXIST: `opow_mul_lt_of_exp_lt`
- The closest theorem in mathlib is `Ordinal.opow_mul_add_lt_opow_succ`: {b u v w : Ordinal} (hvb : v < b) (hw : w < b^u) : b^u * v + w < b^(Order.succ u)

### 3.5 Cast bridges (ℕ ↔ Ordinal)

```lean
@[simp] theorem natCast_le {m n : ℕ} : ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le
@[simp] theorem natCast_lt {m n : ℕ} : ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt
```

### 3.6 Finite vs. infinite split helper

```lean
theorem eq_nat_or_omega0_le (p : Ordinal) : (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  => rcases (lt_omega0).1 h with ⟨n, rfl⟩; exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h
```

### 3.7 Additive Principal Ordinals

```lean
lemma omega_pow_add3_lt {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  have h1 := hprin hα hβ  -- α + β < ω^κ
  exact hprin h1 hγ       -- (α + β) + γ < ω^κ
```

## 4. TRAFFIC LIGHT SYSTEM FOR LEMMAS

| Colour    | Rule of thumb                                           | Examples                                                                             |
| --------- | ------------------------------------------------------- | -------------------------------------------------------------------------------------|
| **Green** | Ordinal-specific or left-monotone lemmas                | `add_lt_add_left`, `mul_lt_mul_of_pos_left`, `le_mul_right`                          |
| **Amber** | Generic lemmas that satisfy the 4-point rule            | `mul_le_mul_left'`, `add_lt_add_of_lt_of_le`                                         |
| **Red**   | Breaks rule 2 (needs right-strict mono / commutativity) | `add_lt_add_right`, `mul_lt_mul_of_pos_right`                                        |

## 5. LOCAL BRIDGES & PATTERNS

**Local strict‑mono for ω‑powers (replacement for deprecated upstream lemma):**
```lean
/-- Strict‑mono of ω‑powers in the exponent (base `omega0`). --/
@[simp] theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
  omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)
```

*Why this is correct:* `isNormal_opow` states that, for `a > 1`, the map `b ↦ a ^ b` is normal (continuous, strictly increasing). With `a := omega0` and `one_lt_omega0`, `strictMono` yields exactly `<` from `<` in the exponent, which is what we need in μ‑decrease proofs.

## 6. μ‑MEASURE PLAYBOOK (Used across all rule proofs)

**Goal form:** for each kernel rule `Step t u`, show `mu u < mu t`. Typical shape reduces to chains like:

```
ω^κ * (x + 1) ≤ ω^(x + κ')
```

**Standard ladder (repeatable):**

1. **Assert base positivity:** `have ωpos : 0 < omega0 := omega0_pos`.
2. **Lift inequalities through exponents:** use `Ordinal.opow_le_opow_right ωpos h` for `≤`, and the local `opow_lt_opow_right` for `<`.
3. **Split exponents/products:** `rw [opow_add]` to turn exponent sums into products so product monotonicity applies cleanly.
4. **Move (≤) across products:** use `Ordinal.mul_le_mul_iff_left`, `mul_le_mul_left'`, `mul_le_mul_right'`; for `<` use `Ordinal.mul_lt_mul_of_pos_left` with a positive left factor.
5. **Absorb finite addends:** once `omega0 ≤ p`, rewrite `(n:Ordinal) + p = p` (or `1 + p = p`).
6. **Bridge successor:** convert `x < y + 1` ↔ `x ≤ y` via `Order.lt_add_one_iff`; introduce `x + 1 ≤ y` via `Order.add_one_le_of_lt` when chaining.
7. **Clean arithmetic noise:** `simp` for associativity/neutral elements; `ring` or `linarith` only for integer‑arithmetic side‑conditions (both tactics are whitelisted).

## 7. CRITICAL CORRECTION FOR `recΔ b s n` (μ‑rules)

Do **not** try to relate `mu s` and `mu (delta n)`. They are **independent parameters**; the inequality `mu s ≤ mu (delta n)` is **false in general**. A simple counterexample (compiles in this codebase):

```lean
def s : Trace := delta (delta void)      -- μ s begins with a higher ω‑tower
def n : Trace := void                     -- μ (delta n) is strictly smaller
-- here: mu s > mu (delta n) - assumption is FALSE
```

Structure μ‑decrease proofs without assuming any structural relation between `s` and `n` beyond what the rule's right‑hand side entails.

## 8. UNIVERSE LEVEL INFERENCE FIXES

**Root Cause Discovered**: Function definition `mu : Trace → Ordinal` caused universe polymorphism issues throughout entire codebase.

**Solution**: Change to `mu : Trace → Ordinal.{0}` → ALL universe errors eliminated

**Before Fix**: 25+ universe level inference errors across file
**After Fix**: Zero universe errors - complete elimination

```lean
-- Root cause solution:
mu : Trace → Ordinal.{0}  -- NOT mu : Trace → Ordinal

-- Additional pattern when needed:
have κ_pos : (0 : Ordinal) < mu a + mu b + 4 := by
  apply Ordinal.pos_iff_ne_zero.mpr
  intro h
  have : (4 : Ordinal) = 0 := by
    rw [← add_zero (4 : Ordinal), ← h]
    simp [add_assoc]
  norm_num at this
```

## 9. WORKING PROOF PATTERNS

**Universe Level Resolution**:
```lean
-- Pattern from lines 866-867 (WORKING):
have κ_pos : (0 : Ordinal) < A := by
  rw [hA]  -- where A := ω^(μ(δn) + μs + 6)
  exact Ordinal.opow_pos (b := mu (delta n) + mu s + 6) (a0 := omega0_pos)
```

**Omega Power Positivity**:
```lean
-- Pattern from lines 52, 67, 127, 151, 867 (WORKING):
have hb : 0 < (omega0 ^ (5 : Ordinal)) :=
  (Ordinal.opow_pos (b := (5 : Ordinal)) (a0 := omega0_pos))
```

**Power Monotonicity**:
```lean
-- Pattern from line 565 (WORKING):
exact Ordinal.opow_le_opow_right omega0_pos h

-- Pattern from line 693 (WORKING):
exact opow_lt_opow_right h_exp
```

**Ordinal Arithmetic**:
```lean
-- Pattern from lines 400, 407, 422 (WORKING):
simp [add_assoc, add_comm, add_left_comm]
```

**Ordinal Commutativity Solutions**:
```lean
-- Direct monotonicity approach (avoids commutativity):
have h_bound : mu b + 3 ≤ mu a + mu b + 3 := by
  apply add_le_add_right; exact zero_le _ 
have h_final : mu a + mu b + 3 < mu a + mu b + 4 := by
  apply add_lt_add_left; norm_num
exact le_trans h_bound (le_of_lt h_final)
```

## 10. ORDER.succ vs `+ 1` (Bridge & Hygiene)

Lean will often rewrite `p + 1` to `Order.succ p` in goals. Work with the `Order` lemmas:

- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`

Keep the `Order.` prefix to avoid name resolution issues. Avoid inventing `succ_eq_add_one`—rely on these bridges instead.

## 11. Additive Principal Ordinals (Extended)

Verbatim consolidation (Additive_Principal_Ordinals report):

Required import:
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

Authoritative lemma:
```lean
theorem Ordinal.principal_add_omega0_opow (o : Ordinal) :
  Principal (fun (x1 x2 : Ordinal) => x1 + x2) (omega0 ^ o)
```

Meaning:
```
Principal (fun x1 x2 => x1 + x2) (omega0 ^ κ)
≡ ∀ {a b}, a < omega0 ^ κ → b < omega0 ^ κ → a + b < omega0 ^ κ
```

Direct usage pattern:
```lean
lemma omega_pow_add_lt {κ α β : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ
```

Three‑term chaining (already in §3.7): leverages closure of additive principal ordinal under repeated application.

Related absorption lemmas (Mathlib; ensure import present):
`Ordinal.add_absorp`, `Ordinal.principal_add_omega0` (ω itself is additive principal).

## 12. Failure & Anti‑Pattern Catalogue

| Category | Bad Pattern | Why Invalid / Fix |
|----------|-------------|-------------------|
| Generic mul | `mul_le_mul_left` (unqualified) | Generic ordered monoid; use `mul_le_mul_left'` or ordinal‑specific lemmas |
| Missing qual | `opow_le_opow_right` (bare) | Must use `Ordinal.opow_le_opow_right` for clarity & rule adherence |
| Deprecated | `Ordinal.opow_lt_opow_right` (old upstream) | Replaced by local `opow_lt_opow_right` bridging `isNormal_opow` |
| Right monotonicity | `a < b → a + c < b + c` (strict) | Ordinal addition not strictly right‑monotone; restructure via left additions or exponent lift |
| Hidden assumption | `μ s ≤ μ (delta n)` | False (see §7 counterexample); remove from reasoning |
| Universe drift | `mu : Trace → Ordinal` | Causes polymorphism cascade; fix to `Ordinal.{0}` |
| Name hallucination | `Ordinal.isAdditivePrincipal_omega_pow` | Correct name: `Ordinal.principal_add_omega0_opow` |
| Silent absorption | Using `(n : Ordinal) + p = p` without `omega0 ≤ p` | Must establish infinitude precondition, often via exponent bound |

## 13. Extended Red / Amber Lists

Red (forbidden):
- Unqualified critical lemmas (`opow_add`, `mul_lt_mul_of_pos_left` without `Ordinal.`)
- Generic right‑monotone additive inequalities
- Any unsourced new lemma (absent from search & toolkit)
- Introduction of `sorry` to bypass ordinal arithmetic.

Amber (caution):
- `add_lt_add_right` (allowed but watch right‑add context precedence)
- `add_comm` / `add_left_comm` (use only where commutativity is mathematically harmless; ordinal addition non‑commutativity at higher structure remains)

Green (preferred patterns):
- Qualified exponent/multiplication lemmas
- Local `opow_lt_opow_right`
- Additive principal chaining with `principal_add_omega0_opow`
- Structured μ‑ladder (see §6) with explicit positivity & absorption steps.

## 14. Lexicographic Measure Interfaces (Preview Pointer)

While full termination chronology belongs to the termination consolidation, ordinal tooling must support lexicographic measures `(κ, μ)`:

```lean
def LexNatOrd : (ℕ × Ordinal) → (ℕ × Ordinal) → Prop :=
  Prod.Lex (· < ·) ((· < ·) : Ordinal → Ordinal → Prop)

lemma μ_to_μκ {t t'} (hμ : mu t' < mu t) (hk : kappa t' = kappa t) :
  LexNatOrd (μκ t') (μκ t) := by
  unfold LexNatOrd μκ
  apply Prod.Lex.right
  simpa [hk]
```

Key constructor patterns (must copy verbatim): `Prod.Lex.left` and `Prod.Lex.right`.

## 15. Provenance Index

| Section | Sources |
|---------|---------|
| 1–6 | ordinal-toolkit.md; agent.md; Project Bible |
| 7 | ordinal-toolkit.md; termination companion notes |
| 8 | Project Bible universe fix section |
| 9 | TerminationBase / Termination_C pattern extraction logs |
| 10 | ordinal-toolkit.md |
| 11 | Additive_Principal_Ordinals (1).txt |
| 12 | Mathematical_Lemma_Usage_Analysis.md; Additive_Principal_Ordinals report |
| 13 | Consolidated red/amber lists (project docs) |
| 14 | Termination_Companion*.md (lexicographic snippets) |
| 15 | Aggregated mapping |

## 16. Open Ordinal Tasks / Research Threads

| Topic | Description | Status |
|-------|-------------|--------|
| Pure μ rec_succ strict decrease | Replace lexicographic fallback with single ordinal measure | Research (blocked by right-add strictness) |
| Automation DSL (`OrdinalDominates`) | Early proposal to catch impossible inequalities | Design stage (Termination_Companion) |
| Additive principal generalization | Broader principal families beyond ω^κ usage | Optional enhancement |
| Absorption lemma catalog | Systematic capture of all `add_absorp` variants | Pending |


## 11. ADMISSIBLE LEMMA RULE-SET ("Green channel")

**Completeness note** — The lemma catalogue is intentionally minimal.  
- Any mathlib lemma that satisfies the **four-point rule-set below** *may* be used **even if** not yet listed, as long as the first use appends a one-liner to `ordinal-toolkit.md`.

1. **No new axioms:** the file introducing it adds no axioms (`#print axioms` CI-check).
2. **Correct structures:** its type-class constraints are satisfied by `Ordinal`
   (⇝ no hidden commutativity / `AddRightStrictMono`, etc.).
3. **Tidy import footprint:** the file pulls in ≤ 100 new declarations, or is
   already in the project dep-graph.
4. **Kernel-safe proof:** the lemma is not `unsafe` and contains no `meta`
   code.

The first use of an admissible lemma **must** append it (one-liner) to
*ordinal-toolkit.md*; later uses need no paperwork.

## 12. DO‑NOT‑USE / DEPRECATED IN THIS PROJECT

- **Generic** `mul_le_mul_left` (from `Algebra.Order.Monoid.Defs`) on ordinal goals. Use `Ordinal.mul_*` APIs instead.
- Old paths `Mathlib.Data.Ordinal.*` — replaced by `Mathlib.SetTheory.Ordinal.*`.
- `Ordinal.opow_lt_opow_right` (upstream removed). Use the **local** `opow_lt_opow_right` defined in §5.
- `le_of_not_lt` (deprecated) — use `le_of_not_gt`.

## 13. READY‑MADE SNIPPETS

**Nat‑sized measure (optional helper):**
```lean
@[simp] def size : Trace → Nat
| void => 1
| delta t => size t + 1
| integrate t => size t + 1
| merge a b => size a + size b + 1
| recΔ b s n => size b + size s + size n + 1
| eqW a b => size a + size b + 1

theorem step_size_decrease {t u : Trace} (h : Step t u) : size u < size t := by
  cases h <;> simp [size]; linarith
```

**WF via ordinal μ:**
```lean
def StepRev : Trace → Trace → Prop := fun a b => Step b a

theorem strong_normalization_forward
  (dec : ∀ {a b}, Step a b → mu b < mu a) : WellFounded (StepRev Step) := by
  have wfμ : WellFounded (fun x y : Trace => mu x < mu y) := InvImage.wf (f := mu) Ordinal.lt_wf
  have sub : Subrelation (StepRev Step) (fun x y => mu x < mu y) := by intro x y h; exact dec h
  exact Subrelation.wf sub wfμ
```

## 14. HELPER LEMMAS FROM TERMINATION_LEGACY.LEAN

```lean
theorem lt_add_one_of_le {x y : Ordinal} (h : x ≤ y) : x < y + 1 :=
  (Order.lt_add_one_iff (x := x) (y := y)).2 h

theorem le_of_lt_add_one {x y : Ordinal} (h : x < y + 1) : x ≤ y :=
  (Order.lt_add_one_iff (x := x) (y := y)).1 h

private lemma le_omega_pow (x : Ordinal) : x ≤ omega0 ^ x :=
  right_le_opow (a := omega0) (b := x) one_lt_omega0

theorem add_one_le_of_lt {x y : Ordinal} (h : x < y) : x + 1 ≤ y := by
  simpa [Ordinal.add_one_eq_succ] using (Order.add_one_le_of_lt h)

private lemma nat_coeff_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ (omega0 ^ (n : Ordinal)) := by
  classical
  cases' n with n
  · -- `n = 0`: `1 ≤ ω^0 = 1`
    simp
  · -- `n = n.succ`

    have hfin : (n.succ : Ordinal) < omega0 := by

      simpa using (Ordinal.nat_lt_omega0 (n.succ))
    have hleft : (n.succ : Ordinal) + 1 ≤ omega0 :=
      Order.add_one_le_of_lt hfin

    have hpos : (0 : Ordinal) < (n.succ : Ordinal) := by
      simpa using (Nat.cast_pos.mpr (Nat.succ_pos n))
    have hmono : (omega0 : Ordinal) ≤ (omega0 ^ (n.succ : Ordinal)) := by
      -- `left_le_opow` has type: `0 < b → a ≤ a ^ b`
      simpa using (Ordinal.left_le_opow (a := omega0) (b := (n.succ : Ordinal)) hpos)

    exact hleft.trans hmono

private lemma coeff_fin_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ omega0 ^ (n : Ordinal) := nat_coeff_le_omega_pow n

@[simp] theorem natCast_le {m n : ℕ} :
  ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le

@[simp] theorem natCast_lt {m n : ℕ} :
  ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt

theorem eq_nat_or_omega0_le (p : Ordinal) :
  (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  =>
      rcases (lt_omega0).1 h with ⟨n, rfl⟩
      exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h

theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) :
  (1 : Ordinal) + p = p := by
  simpa using (Ordinal.one_add_of_omega0_le h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) :
  (n : Ordinal) + p = p := by
  simpa using (Ordinal.natCast_add_of_omega0_le (n := n) h)

@[simp] theorem add_natCast_left (m n : ℕ) :
  (m : Ordinal) + (n : Ordinal) = ((m + n : ℕ) : Ordinal) := by
  induction n with
  | zero =>
      simp
  | succ n ih =>
      simp [Nat.cast_succ]

theorem mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)        -- mono in left factor
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left' h₂ c)         -- mono in right factor
  exact le_trans h₁' h₂'

theorem add4_plus5_le_plus9 (p : Ordinal) :
  (4 : Ordinal) + (p + 5) ≤ p + 9 := by
  classical
  rcases lt_or_ge p omega0 with hfin | hinf
  · -- finite case: `p = n : ℕ`
    rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    -- compute on ℕ first
    have hEqNat : (4 + (n + 5) : ℕ) = (n + 9 : ℕ) := by
      -- both sides reduce to `n + 9`
      simp [Nat.add_left_comm]
    have hEq :
        (4 : Ordinal) + ((n : Ordinal) + 5) = (n : Ordinal) + 9 := by
      calc
        (4 : Ordinal) + ((n : Ordinal) + 5)
            = (4 : Ordinal) + (((n + 5 : ℕ) : Ordinal)) := by
                simp
        _   = ((4 + (n + 5) : ℕ) : Ordinal) := by
                simp
        _   = ((n + 9 : ℕ) : Ordinal) := by
                simpa using (congrArg (fun k : ℕ => (k : Ordinal)) hEqNat)
        _   = (n : Ordinal) + 9 := by
                simp
    exact le_of_eq hEq
  · -- infinite-or-larger case: the finite prefix on the left collapses
    -- `5 ≤ 9` as ordinals
    have h59 : (5 : Ordinal) ≤ (9 : Ordinal) := by
      simpa using (natCast_le.mpr (by decide : (5 : ℕ) ≤ 9))
    -- monotonicity in the right argument
    have hR : p + 5 ≤ p + 9 := by
      simpa using add_le_add_left h59 p
    -- collapse `4 + p` since `ω ≤ p`
    have hcollapse : (4 : Ordinal) + (p + 5) = p + 5 := by
      calc
        (4 : Ordinal) + (p + 5)
            = ((4 : Ordinal) + p) + 5 := by
                simp [add_assoc]
        _   = p + 5 := by
                have h4 : (4 : Ordinal) + p = p := nat_left_add_absorb (n := 4) (p := p) hinf
                rw [h4]
    simpa [hcollapse] using hR

theorem add_nat_succ_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + Order.succ p ≤ p + (k + 1) := by
  rcases lt_or_ge p omega0 with hfin | hinf
  · rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    have hN : (k + (n + 1) : ℕ) = n + (k + 1) := by
      simp [Nat.add_left_comm]
    have h :
        (k : Ordinal) + ((n : Ordinal) + 1) = (n : Ordinal) + (k + 1) := by
      calc
        (k : Ordinal) + ((n : Ordinal) + 1)
            = ((k + (n + 1) : ℕ) : Ordinal) := by simp
        _   = ((n + (k + 1) : ℕ) : Ordinal) := by
              simpa using (congrArg (fun t : ℕ => (t : Ordinal)) hN)
        _   = (n : Ordinal) + (k + 1) := by simp
    have : (k : Ordinal) + Order.succ (n : Ordinal) = (n : Ordinal) + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using h
    exact le_of_eq this
  ·
    have hk : (k : Ordinal) + p = p := nat_left_add_absorb (n := k) hinf
    have hcollapse :
        (k : Ordinal) + Order.succ p = Order.succ p := by
      simpa [Ordinal.add_succ] using congrArg Order.succ hk
    have hkNat : (1 : ℕ) ≤ k + 1 := Nat.succ_le_succ (Nat.zero_le k)
    have h1k : (1 : Ordinal) ≤ (k + 1 : Ordinal) := by
      simpa using (natCast_le.mpr hkNat)
    have hstep0 : p + 1 ≤ p + (k + 1) := add_le_add_left h1k p
    have hstep : Order.succ p ≤ p + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using hstep0
    exact (le_of_eq hcollapse).trans hstep

theorem add_nat_plus1_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + (p + 1) ≤ p + (k + 1) := by
  simpa [Ordinal.add_one_eq_succ] using add_nat_succ_le_plus_succ k p

theorem add3_succ_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + Order.succ p ≤ p + 4 := by
  simpa using add_nat_succ_le_plus_succ 3 p

theorem add2_succ_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + Order.succ p ≤ p + 3 := by
  simpa using add_nat_succ_le_plus_succ 2 p

theorem add3_plus1_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + (p + 1) ≤ p + 4 := by
  simpa [Ordinal.add_one_eq_succ] using add3_succ_le_plus4 p

theorem add2_plus1_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + (p + 1) ≤ p + 3 := by
  simpa [Ordinal.add_one_eq_succ] using add2_succ_le_plus3 p

theorem lt_add_one (x : Ordinal) : x < x + 1 := lt_add_one_of_le (le_rfl)

theorem mul_succ (a b : Ordinal) : a * (b + 1) = a * b + a := by
  simpa [mul_one, add_comm, add_left_comm, add_assoc] using
    (mul_add a b (1 : Ordinal))

/-- **Strict** monotone: `b < c → ω^b < ω^c`. -/
theorem opow_lt_opow_ω {b c : Ordinal} (h : b < c) :
    omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

theorem opow_le_opow_ω {p q : Ordinal} (h : p ≤ q) :
    omega0 ^ p ≤ omega0 ^ q := by
  exact Ordinal.opow_le_opow_right omega0_pos h   -- library lemma

theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
   omega0 ^ b < omega0 ^ c := by
  simpa using
   ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos
  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [Ordinal.opow_add] using (Ordinal.opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁
  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    Ordinal.opow_le_opow_right omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂

private lemma two_lt_three : (2 : Ordinal) < 3 := by
  have : (2 : ℕ) < 3 := by decide
  simpa using (Nat.cast_lt).2 this

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by

  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')

---

## 17. ERROR PATTERN LOG (VERBATIM INCIDENT FORMS)

Each entry: (Code / Symptom / Minimal Reproducer / Resolution Pattern)

EP1  Universe polymorphism cascade / `invalid universe level assignment` / `mu : Trace → Ordinal` / redefine as `mu : Trace → Ordinal.{0}`; recompile
EP2  Generic multiplication lemma misuse / goal `c * a ≤ c * b` with ordinals / attempted `mul_le_mul_left` / replace with `mul_le_mul_left'` or `Ordinal.mul_le_mul_iff_left`
EP3  Lost strictness after right addition / transformed `h : x < y` into `h' : x + z < y + z` / ordinal addition not strictly right‑monotone / restructure inequality via exponent lift then absorb finite tail
EP4  Unsound structural assumption / inserted `have : mu s ≤ mu (delta n)` / counterexample (double delta vs void) refutes; delete assumption and isolate needed dominance via auxiliary measure κ
EP5  Deprecated lemma name / used `Ordinal.opow_lt_opow_right` (removed) / error unknown identifier / introduce local `opow_lt_opow_right` via `isNormal_opow.strictMono`
EP6  Name hallucination / `Ordinal.isAdditivePrincipal_omega_pow` / rename to `Ordinal.principal_add_omega0_opow`
EP7  Absorption applied without infinitude proof / rewrote `(3 : Ordinal) + p` to `p` / missing `omega0 ≤ p` / first prove finite part < ω ≤ p; then apply `nat_left_add_absorb`
EP8  Over‑aggressive simp flattening / `simp [add_assoc, add_comm, add_left_comm]` removed tower grouping needed for `opow_add` alignment / limit simp scope (avoid comm/assoc when matching structured pattern)
EP9  Wrong orientation of multiplication / replaced `ω^k * X` with `X * ω^k` / ordinal multiplication non‑commutative / keep canonical left factor power for monotone lemmas
EP10 Misuse of `ring` on exponent goal / attempted `ring` on `omega0 ^ (a + b + 1)` equality / `ring` handles semiring arithmetic (ℕ/ℤ), not ordinal exponent formulas / use `opow_add` rewriting
EP11 Missing qualification / bare `opow_le_opow_right` ambiguous import path / fully qualify: `Ordinal.opow_le_opow_right`
EP12 Incorrect finite padding reasoning / attempted to force `μ a + 4 < μ a + 5` inside tail sum after rearrangement that lost left alignment / recover by explicit lemma `add_lt_add_left (by norm_num)`
EP13 Stalled search for strict chain / no progress `lt_of_le_of_lt` due to wrong order / reorder: derive `x ≤ y` then `y < z` not vice versa
EP14 Case split omission / handling `(void, void)` inside general eqW inequality produced stuck exponent comparison / perform `by_cases (a = void ∧ b = void)` first
EP15 Duplicate local lemma collision / redefining `omega_pow_add3_lt` second time / rename or reference existing definition; avoid shadowing for provenance clarity

## 18. SUCCESSFUL PATTERN SEQUENCES (CANONICAL TEMPLATES)

SP1  Head–Tail Merge Bounding:
  Input goal: `mu (merge a b) + 1 < ω^(C + 5)` with `C = μa + μb`
  Steps: termA_le → termB_le → exponent < (C+5) proofs → two opow monotonic lifts → combine via `omega_pow_add3_lt` including finite tail → rewrite μ definition

SP2  Integrate + Merge Elevation (eqW path):
  Start: `mu (integrate (merge a b))`
  Expansion: rewrite integrate layer `ω^4 * (...) + 1`; apply merge inner bound; multiply inequality by `ω^4`; use `opow_add`; absorption of finite 4 via `nat_left_add_absorb` using `ω ≤ μa + μb`; exponent bump from `C+5` to `C+9` with finite chain `(5 < 9)`; final add-one chain via `Order.add_one_le_of_lt`

SP3  Recursor Tail Isolation (legacy parameterized):
  Input inequality parameter `h_mu_recΔ_bound`
  Derive: tail_lt_A from termB_le + exponent chain; head_lt_A from termA_le; combine with additive principal triple sum; compare to expanded `μ(recΔ ...)`

SP4  Exponent Strictness Promotion:
  Known: `α < β`
  Derive: `omega0 ^ α < omega0 ^ β` via local `opow_lt_opow_right`; extend chain with `lt_of_le_of_lt` after an initial `≤` produced by product or additive estimates

SP5  Finite Absorption Safe Application:
  Show: `omega0 ≤ P`
  Then: use `nat_left_add_absorb (h := ‹omega0 ≤ P›)` to fold `(n : Ordinal) + P` to `P`

SP6  Two‑Stage Sum Comparison:
  Goal: `μb + k ≤ μa + μb + k`
  Use: `add_le_add_right (le_add_of_nonneg_left (zero_le _)) k` then follow with strict bump `add_lt_add_left (by norm_num)`

SP7  Triple Additive Principal Folding:
  Given three summands each `< ω^κ` plus finite tail `< ω^κ`
  Sequence: first combine two via `omega_pow_add_lt`; reapply with third; final associativity normalization `simpa [add_assoc]`

SP8  Finite → Exponent Positivity:
  Show `(0 : Ordinal) < m` for finite numeral `m`; then `lt_of_lt_of_le` to embed into larger expression like `μ(δ n) + μ s + m`

SP9  Product Left‑Strict Lift:
  With `γ < ω` and base positivity: derive `ω^β * γ < ω^β * ω`; rewrite right side to `ω^(β+1)` with `opow_add`; cascade to larger exponent with `opow_le_opow_right`

SP10 Merge Measure Reassociation:
  Normalize `mu (merge a b)` to `ω^3*(μa+1) + (ω^2*(μb+1) + 1)` using `simp [mu, add_assoc]` to align with additive principal template

## 19. ABSORPTION PRECONDITION CATALOGUE

AP1  `(n : Ordinal) + p = p` requires `omega0 ≤ p` (establish via exponent tower positivity or prior inequality)  
AP2  `(1 : Ordinal) + p = p` same requirement (use `one_left_add_absorb` wrapper)  
AP3  Folding `(k : Ordinal) + (p + m)` to `p + m` requires `omega0 ≤ p` not merely `ω ≤ p + m`  
AP4  Inside exponent adjustment `(c : Ordinal) + (C + d) = C + d` needs `(c : Ordinal) + C = C`; prove absorption first then reassociate  
AP5  Avoid absorption inside a product: cannot simplify `ω^n * ((m : Ordinal) + p)` by absorption; expand addition after multiplication not before

## 20. EXPONENT COMPARISON INVENTORY

EC1  Bumping finite suffix: `(C + k) < (C + m)` via `add_lt_add_left (by norm_num)` (k < m)  
EC2  Prefix insertion: `x ≤ y` implies `x + k ≤ y + k` (left additive monotone)  
EC3  Chaining: `α < β ≤ γ` becomes `α < γ` using `lt_of_lt_of_le`  
EC4  From strict to successor: `α < β` gives `α + 1 ≤ β` via `Order.add_one_le_of_lt`  
EC5  Exponent lift (≤): `h : a ≤ b` → `ω^a ≤ ω^b` via `Ordinal.opow_le_opow_right omega0_pos h`  
EC6  Exponent lift (<): `h : a < b` → `ω^a < ω^b` via local strictMono lemma  
EC7  Composite: `ω^a * (b+1)` bound by first bounding `(b+1)` then applying multiplication monotonicity then exponent comparison  
EC8  Finite stacking: `ω^(n) * ω^(m) = ω^(n+m)` using symmetry of `opow_add` orientation `(opow_add _ _ _).symm`

## 21. DEPRECATED / CORRECT NAME MAP

| Deprecated / Incorrect | Correct | Context |
|------------------------|---------|---------|
| `Ordinal.opow_lt_opow_right` | local `opow_lt_opow_right` | Removed upstream strict lemma |
| `isAdditivePrincipal_omega_pow` | `principal_add_omega0_opow` | Additive principal ordinal lemma |
| `Ordinal.nat_add_of_omega_le` | `Ordinal.natCast_add_of_omega0_le` | API rename variant (observed mismatch) |
| `one_add_of_omega_le` | `one_add_of_omega0_le` | Ensure explicit ω₀ subscript |
| `le_of_not_lt` | `le_of_not_gt` | Modern replacement |

## 22. TACTIC USAGE MATRIX

| Tactic | Allowed | Typical Scope | Prohibited Uses |
|--------|---------|---------------|-----------------|
| `simp` | Yes | Reassociating additions, unfolding μ constructors selectively | Blanket over entire large goal that removes stratification |
| `linarith` | Yes | Finite numeral comparisons inside exponent deltas | On ordinal exponentials (`omega0 ^ α`) directly |
| `ring` | Yes | Simplify finite Nat subgoals generated by casts | On ordinal multiplications/exponentiations |
| `norm_num` | Yes | Proving finite inequalities like `(3 : Ordinal) < 6` | Outside pure numeral contexts |
| `rewrite` | Yes | Applying specific `opow_add`, absorption equalities | Chasing equalities that increase size without progress |
| `library_search` | Caution | Discover admissible lemmas (green channel) | Accepting lemma without qualification/prefix audit |

## 23. SEARCH PROTOCOL EXEMPLAR

Example (looking for additive principal lemma):
  SEARCH(principal_add_omega0_opow) → Found 1 match
  Output permitted; lemma inserted verbatim.
Missing name example: SEARCH(isAdditivePrincipal_omega_pow) → 0 results – rename to `principal_add_omega0_opow` and record mapping (see §21).

## 24. PENDING GREEN‑CHANNEL CANDIDATES (Not Yet Used)

List placeholders (must search before first usage):
GC1  `Ordinal.mul_lt_mul_of_pos_right` (evaluate strictness side conditions)  
GC2  `Ordinal.add_right_cancel` (check applicability; beware non‑cancellation in some ordinal forms)  
GC3  `Ordinal.inductionOn` variants for structured recursion proofs  
GC4  `Ordinal.principal_mul_omega0_opow` (if upstream introduces multiplicative principal families)  

## 25. LEMMA USAGE LOCATION INDEX (LEGACY μ)

| Lemma | First Recorded Line (Termination_Legacy) | Purpose |
|-------|-------------------------------------------|---------|
| termA_le | ~290 | Bound ω³ head payload |
| termB_le | ~312 | Bound ω² tail payload |
| payload_bound_merge | ~330 | Combine head+tail+1 under ω^(x+5) |
| omega_pow_add3_lt | ~520 / ~700 | Triple additive principal composition |
| merge_inner_bound_simple | ~1030 | Inner bound for eqW chain |
| mu_lt_eq_diff_both_void | ~1080 | Corner case eqW inequality |
| mu_lt_eq_diff | ~1120 | General eqW inequality |
| tail_lt_A | ~860 | Recursor tail < dominant A tower |
| head_lt_A | ~650 | Recursor head < dominant A tower |

## 26. COUNTEREXAMPLES LIBRARY

CE1  False right‑add strictness:
  Let `a := omega0`, `b := omega0 + 1`, `c := omega0^2`. Then `a < b` but `a + c = c = b + c`.
CE2  Invalid μ parameter relation:
  `s := delta (delta void)`; `n := void`; then `mu s > mu (delta n)`.
CE3  Finite padding insufficiency:
  For large `t : Trace` with `mu t ≥ ω^(μ n + μ s + 6)`, inequality using only +4/+6 fails to separate exponents.
CE4  Multiplication commutativity assumption:
  `ω^2 * (ω^3 + 1) ≠ (ω^3 + 1) * ω^2` (structures differ in Cantor normal form ordering).
CE5  Absorption without infinitude:
  `(3 : Ordinal) + (5 : Ordinal) ≠ 5` though `(3 : Ordinal) + ω = ω`.

## 27. MINIMAL REWRITE ORDERING GUIDELINES

R1  Expand products after establishing additive bounds; do not expand early if it hides factorization needed for `opow_add`.
R2  Apply exponent comparisons before absorption to avoid losing monotonic structure.
R3  Preserve left‑nested additive shape for principal applications: `A + (B + C)` is acceptable; flatten only when lemma requires `A + B + C`.
R4  Avoid commuting finite and transfinite summands unless infinite right operand already proven (`omega0 ≤ p`).

## 28. FUTURE ORDINAL TOOLING TODO (FACTUAL BACKLOG)

T1  Catalogue every instance of `omega0 ^ (k : Ordinal)` usage with k ∈ {2,3,4,5,6,9} across μ lemmas (pending automated grep table)
T2  Record potential generalization of `omega_pow_add3_lt` to n‑ary list fold (requires recursive principal closure proof)
T3  Introduce explicit lemma: `finite_lt_power` : `(n : Ordinal) < omega0 ^ (k + 1)` for all finite k (derive via `nat_lt_omega0` + exponent monotonicity) — not yet formalized here
T4  Audit all absorptions to ensure each has proximal proof of `omega0 ≤ target` line above (scriptable lint)
T5  Provide CNF (Cantor normal form) commentary mapping for each μ constructor exponent tier (draft placeholder)

---

````
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp


  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')
```

END FILE: C:\Users\Moses\OpComp\MUST_Review\chats\2.Expanded_Ordinal_Toolkit.md

BEGIN FILE: C:\Users\Moses\OpComp\MUST_Review\important_2\2.Expanded_Ordinal_Toolkit.md
LAST WRITE UTC: 2025-08-18T15:53:28.6506219Z
SIZE BYTES: 44755

This file has moved. Please use the canonical copy in Submission_Material/md.

New location:
- Submission_Material/md/2.Expanded_Ordinal_Toolkit.md

Rationale: All paper-related Markdown is centralized under Submission_Material/md for the submission bundle. This stub exists to avoid broken links.

**Minimal import prelude (copy‑paste):**

```lean
import Init.WF
import Mathlib.Data.Prod.Lex
import Mathlib.SetTheory.Ordinal.Basic
import Mathlib.SetTheory.Ordinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Exponential
import Mathlib.Algebra.Order.SuccPred
import Mathlib.Data.Nat.Cast.Order.Basic
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Ring
open Ordinal
```

**Additional Import (for additive principal ordinals):**
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

## 2. QUALIFICATION RULES (Must appear verbatim at call‑sites)

- **Exponent (≤‑mono):** call `Ordinal.opow_le_opow_right` (never the bare name).
- **Exponent (<‑monotone at base ω):** use the **local** theorem `opow_lt_opow_right` defined in §5.
- **Products:** prefer `Ordinal.mul_lt_mul_of_pos_left` and `Ordinal.mul_le_mul_iff_left` (or `mul_le_mul_left'`/`mul_le_mul_right'`) — these are the **ordinal** APIs.
- **Successor bridge:** call `Order.lt_add_one_iff` / `Order.add_one_le_of_lt` with the `Order.` prefix.

## 3. LEMMA CATALOGUE (Names, Signatures, Modules)

### 3.1 Basics & Positivity

- `omega0_pos : 0 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `one_lt_omega0 : 1 < omega0`  — *module:* `SetTheory.Ordinal.Basic`
- `lt_omega0 : o < omega0 ↔ ∃ n : ℕ, o = n`  — *module:* `SetTheory.Ordinal.Basic`
- `nat_lt_omega0 : ∀ n : ℕ, (n : Ordinal) < omega0`  — *module:* `SetTheory.Ordinal.Basic`

### 3.2 Addition & Successor

- `add_lt_add_left  : a < b → c + a < c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_lt_add_right : a < b → a + c < b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_left  : a ≤ b → c + a ≤ c + b`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `add_le_add_right : a ≤ b → a + c ≤ b + c`  — *module:* `SetTheory.Ordinal.Arithmetic`
- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`  — *module:* `Algebra.Order.SuccPred`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`  — *module:* `Algebra.Order.SuccPred`

**Absorption on infinite right addends:**
- `Ordinal.one_add_of_omega_le : omega0 ≤ p → (1 : Ordinal) + p = p`
- `Ordinal.natCast_add_of_omega_le : omega0 ≤ p → (n : Ordinal) + p = p`

**Absorption shorthands:**
```lean
theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) : (1 : Ordinal) + p = p :=
  by simpa using (Ordinal.one_add_of_omega_le (p := p) h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) : (n : Ordinal) + p = p :=
  by simpa using (Ordinal.nat_add_of_omega_le (p := p) (n := n) h)
```

### 3.3 Multiplication (Ordinal‑specific)

- `Ordinal.mul_lt_mul_of_pos_left : a < b → 0 < c → c * a < c * b`
- `Ordinal.mul_le_mul_iff_left   : c * a ≤ c * b ↔ a ≤ b`
- Primed monotone helpers: `mul_le_mul_left'`, `mul_le_mul_right'` (convenient rewriting forms).
- `le_mul_right : 0 < b → a ≤ b * a`.


> **Note:** `mul_le_mul_left` without a trailing apostrophe comes from `Algebra.Order.Monoid.Defs` and is **generic** (ordered monoids). Do **not** use it to reason about ordinal multiplication.

**Two‑sided product monotonicity (derived helper):**
```lean
/-- Two–sided monotonicity of `(*)` for ordinals, built from one–sided lemmas. -/
 theorem ord_mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left'  h₂ c)
  exact le_trans h₁' h₂'
```

### 3.4 Exponentiation (ω‑powers & normality)

- `opow_add : a ^ (b + c) = a ^ b * a ^ c` — split exponents.
- `opow_pos : 0 < a → 0 < a ^ b` — positivity of powers.
- `Ordinal.opow_le_opow_right : 0 < a → b ≤ c → a ^ b ≤ a ^ c` — **use fully‑qualified**.
- DOES NOT EXIST: `opow_mul_lt_of_exp_lt`
- The closest theorem in mathlib is `Ordinal.opow_mul_add_lt_opow_succ`: {b u v w : Ordinal} (hvb : v < b) (hw : w < b^u) : b^u * v + w < b^(Order.succ u)

### 3.5 Cast bridges (ℕ ↔ Ordinal)

```lean
@[simp] theorem natCast_le {m n : ℕ} : ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le
@[simp] theorem natCast_lt {m n : ℕ} : ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt
```

### 3.6 Finite vs. infinite split helper

```lean
theorem eq_nat_or_omega0_le (p : Ordinal) : (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  => rcases (lt_omega0).1 h with ⟨n, rfl⟩; exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h
```

### 3.7 Additive Principal Ordinals

```lean
lemma omega_pow_add3_lt {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  have h1 := hprin hα hβ  -- α + β < ω^κ
  exact hprin h1 hγ       -- (α + β) + γ < ω^κ
```

## 4. TRAFFIC LIGHT SYSTEM FOR LEMMAS

| Colour    | Rule of thumb                                           | Examples                                                                             |
| --------- | ------------------------------------------------------- | -------------------------------------------------------------------------------------|
| **Green** | Ordinal-specific or left-monotone lemmas                | `add_lt_add_left`, `mul_lt_mul_of_pos_left`, `le_mul_right`                          |
| **Amber** | Generic lemmas that satisfy the 4-point rule            | `mul_le_mul_left'`, `add_lt_add_of_lt_of_le`                                         |
| **Red**   | Breaks rule 2 (needs right-strict mono / commutativity) | `add_lt_add_right`, `mul_lt_mul_of_pos_right`                                        |

## 5. LOCAL BRIDGES & PATTERNS

**Local strict‑mono for ω‑powers (replacement for deprecated upstream lemma):**
```lean
/-- Strict‑mono of ω‑powers in the exponent (base `omega0`). --/
@[simp] theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
  omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)
```

*Why this is correct:* `isNormal_opow` states that, for `a > 1`, the map `b ↦ a ^ b` is normal (continuous, strictly increasing). With `a := omega0` and `one_lt_omega0`, `strictMono` yields exactly `<` from `<` in the exponent, which is what we need in μ‑decrease proofs.

## 6. μ‑MEASURE PLAYBOOK (Used across all rule proofs)

**Goal form:** for each kernel rule `Step t u`, show `mu u < mu t`. Typical shape reduces to chains like:

```
ω^κ * (x + 1) ≤ ω^(x + κ')
```

**Standard ladder (repeatable):**

1. **Assert base positivity:** `have ωpos : 0 < omega0 := omega0_pos`.
2. **Lift inequalities through exponents:** use `Ordinal.opow_le_opow_right ωpos h` for `≤`, and the local `opow_lt_opow_right` for `<`.
3. **Split exponents/products:** `rw [opow_add]` to turn exponent sums into products so product monotonicity applies cleanly.
4. **Move (≤) across products:** use `Ordinal.mul_le_mul_iff_left`, `mul_le_mul_left'`, `mul_le_mul_right'`; for `<` use `Ordinal.mul_lt_mul_of_pos_left` with a positive left factor.
5. **Absorb finite addends:** once `omega0 ≤ p`, rewrite `(n:Ordinal) + p = p` (or `1 + p = p`).
6. **Bridge successor:** convert `x < y + 1` ↔ `x ≤ y` via `Order.lt_add_one_iff`; introduce `x + 1 ≤ y` via `Order.add_one_le_of_lt` when chaining.
7. **Clean arithmetic noise:** `simp` for associativity/neutral elements; `ring` or `linarith` only for integer‑arithmetic side‑conditions (both tactics are whitelisted).

## 7. CRITICAL CORRECTION FOR `recΔ b s n` (μ‑rules)

Do **not** try to relate `mu s` and `mu (delta n)`. They are **independent parameters**; the inequality `mu s ≤ mu (delta n)` is **false in general**. A simple counterexample (compiles in this codebase):

```lean
def s : Trace := delta (delta void)      -- μ s begins with a higher ω‑tower
def n : Trace := void                     -- μ (delta n) is strictly smaller
-- here: mu s > mu (delta n) - assumption is FALSE
```

Structure μ‑decrease proofs without assuming any structural relation between `s` and `n` beyond what the rule's right‑hand side entails.

## 8. UNIVERSE LEVEL INFERENCE FIXES

**Root Cause Discovered**: Function definition `mu : Trace → Ordinal` caused universe polymorphism issues throughout entire codebase.

**Solution**: Change to `mu : Trace → Ordinal.{0}` → ALL universe errors eliminated

**Before Fix**: 25+ universe level inference errors across file
**After Fix**: Zero universe errors - complete elimination

```lean
-- Root cause solution:
mu : Trace → Ordinal.{0}  -- NOT mu : Trace → Ordinal

-- Additional pattern when needed:
have κ_pos : (0 : Ordinal) < mu a + mu b + 4 := by
  apply Ordinal.pos_iff_ne_zero.mpr
  intro h
  have : (4 : Ordinal) = 0 := by
    rw [← add_zero (4 : Ordinal), ← h]
    simp [add_assoc]
  norm_num at this
```

## 9. WORKING PROOF PATTERNS

**Universe Level Resolution**:
```lean
-- Pattern from lines 866-867 (WORKING):
have κ_pos : (0 : Ordinal) < A := by
  rw [hA]  -- where A := ω^(μ(δn) + μs + 6)
  exact Ordinal.opow_pos (b := mu (delta n) + mu s + 6) (a0 := omega0_pos)
```

**Omega Power Positivity**:
```lean
-- Pattern from lines 52, 67, 127, 151, 867 (WORKING):
have hb : 0 < (omega0 ^ (5 : Ordinal)) :=
  (Ordinal.opow_pos (b := (5 : Ordinal)) (a0 := omega0_pos))
```

**Power Monotonicity**:
```lean
-- Pattern from line 565 (WORKING):
exact Ordinal.opow_le_opow_right omega0_pos h

-- Pattern from line 693 (WORKING):
exact opow_lt_opow_right h_exp
```

**Ordinal Arithmetic**:
```lean
-- Pattern from lines 400, 407, 422 (WORKING):
simp [add_assoc, add_comm, add_left_comm]
```

**Ordinal Commutativity Solutions**:
```lean
-- Direct monotonicity approach (avoids commutativity):
have h_bound : mu b + 3 ≤ mu a + mu b + 3 := by
  apply add_le_add_right; exact zero_le _ 
have h_final : mu a + mu b + 3 < mu a + mu b + 4 := by
  apply add_lt_add_left; norm_num
exact le_trans h_bound (le_of_lt h_final)
```

## 10. ORDER.succ vs `+ 1` (Bridge & Hygiene)

Lean will often rewrite `p + 1` to `Order.succ p` in goals. Work with the `Order` lemmas:

- `Order.lt_add_one_iff : x < y + 1 ↔ x ≤ y`
- `Order.add_one_le_of_lt : x < y → x + 1 ≤ y`

Keep the `Order.` prefix to avoid name resolution issues. Avoid inventing `succ_eq_add_one`—rely on these bridges instead.

## 11. Additive Principal Ordinals (Extended)

Verbatim consolidation (Additive_Principal_Ordinals report):

Required import:
```lean
import Mathlib.SetTheory.Ordinal.Principal
```

Authoritative lemma:
```lean
theorem Ordinal.principal_add_omega0_opow (o : Ordinal) :
  Principal (fun (x1 x2 : Ordinal) => x1 + x2) (omega0 ^ o)
```

Meaning:
```
Principal (fun x1 x2 => x1 + x2) (omega0 ^ κ)
≡ ∀ {a b}, a < omega0 ^ κ → b < omega0 ^ κ → a + b < omega0 ^ κ
```

Direct usage pattern:
```lean
lemma omega_pow_add_lt {κ α β : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin := Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ
```

Three‑term chaining (already in §3.7): leverages closure of additive principal ordinal under repeated application.

Related absorption lemmas (Mathlib; ensure import present):
`Ordinal.add_absorp`, `Ordinal.principal_add_omega0` (ω itself is additive principal).

## 12. Failure & Anti‑Pattern Catalogue

| Category | Bad Pattern | Why Invalid / Fix |
|----------|-------------|-------------------|
| Generic mul | `mul_le_mul_left` (unqualified) | Generic ordered monoid; use `mul_le_mul_left'` or ordinal‑specific lemmas |
| Missing qual | `opow_le_opow_right` (bare) | Must use `Ordinal.opow_le_opow_right` for clarity & rule adherence |
| Deprecated | `Ordinal.opow_lt_opow_right` (old upstream) | Replaced by local `opow_lt_opow_right` bridging `isNormal_opow` |
| Right monotonicity | `a < b → a + c < b + c` (strict) | Ordinal addition not strictly right‑monotone; restructure via left additions or exponent lift |
| Hidden assumption | `μ s ≤ μ (delta n)` | False (see §7 counterexample); remove from reasoning |
| Universe drift | `mu : Trace → Ordinal` | Causes polymorphism cascade; fix to `Ordinal.{0}` |
| Name hallucination | `Ordinal.isAdditivePrincipal_omega_pow` | Correct name: `Ordinal.principal_add_omega0_opow` |
| Silent absorption | Using `(n : Ordinal) + p = p` without `omega0 ≤ p` | Must establish infinitude precondition, often via exponent bound |

## 13. Extended Red / Amber Lists

Red (forbidden):
- Unqualified critical lemmas (`opow_add`, `mul_lt_mul_of_pos_left` without `Ordinal.`)
- Generic right‑monotone additive inequalities
- Any unsourced new lemma (absent from search & toolkit)
- Introduction of `sorry` to bypass ordinal arithmetic.

Amber (caution):
- `add_lt_add_right` (allowed but watch right‑add context precedence)
- `add_comm` / `add_left_comm` (use only where commutativity is mathematically harmless; ordinal addition non‑commutativity at higher structure remains)

Green (preferred patterns):
- Qualified exponent/multiplication lemmas
- Local `opow_lt_opow_right`
- Additive principal chaining with `principal_add_omega0_opow`
- Structured μ‑ladder (see §6) with explicit positivity & absorption steps.

## 14. Lexicographic Measure Interfaces (Preview Pointer)

While full termination chronology belongs to the termination consolidation, ordinal tooling must support lexicographic measures `(κ, μ)`:

```lean
def LexNatOrd : (ℕ × Ordinal) → (ℕ × Ordinal) → Prop :=
  Prod.Lex (· < ·) ((· < ·) : Ordinal → Ordinal → Prop)

lemma μ_to_μκ {t t'} (hμ : mu t' < mu t) (hk : kappa t' = kappa t) :
  LexNatOrd (μκ t') (μκ t) := by
  unfold LexNatOrd μκ
  apply Prod.Lex.right
  simpa [hk]
```

Key constructor patterns (must copy verbatim): `Prod.Lex.left` and `Prod.Lex.right`.

## 15. Provenance Index

| Section | Sources |
|---------|---------|
| 1–6 | ordinal-toolkit.md; agent.md; Project Bible |
| 7 | ordinal-toolkit.md; termination companion notes |
| 8 | Project Bible universe fix section |
| 9 | TerminationBase / Termination_C pattern extraction logs |
| 10 | ordinal-toolkit.md |
| 11 | Additive_Principal_Ordinals (1).txt |
| 12 | Mathematical_Lemma_Usage_Analysis.md; Additive_Principal_Ordinals report |
| 13 | Consolidated red/amber lists (project docs) |
| 14 | Termination_Companion*.md (lexicographic snippets) |
| 15 | Aggregated mapping |

## 16. Open Ordinal Tasks / Research Threads

| Topic | Description | Status |
|-------|-------------|--------|
| Pure μ rec_succ strict decrease | Replace lexicographic fallback with single ordinal measure | Research (blocked by right-add strictness) |
| Automation DSL (`OrdinalDominates`) | Early proposal to catch impossible inequalities | Design stage (Termination_Companion) |
| Additive principal generalization | Broader principal families beyond ω^κ usage | Optional enhancement |
| Absorption lemma catalog | Systematic capture of all `add_absorp` variants | Pending |


## 11. ADMISSIBLE LEMMA RULE-SET ("Green channel")

**Completeness note** — The lemma catalogue is intentionally minimal.  
- Any mathlib lemma that satisfies the **four-point rule-set below** *may* be used **even if** not yet listed, as long as the first use appends a one-liner to `ordinal-toolkit.md`.

1. **No new axioms:** the file introducing it adds no axioms (`#print axioms` CI-check).
2. **Correct structures:** its type-class constraints are satisfied by `Ordinal`
   (⇝ no hidden commutativity / `AddRightStrictMono`, etc.).
3. **Tidy import footprint:** the file pulls in ≤ 100 new declarations, or is
   already in the project dep-graph.
4. **Kernel-safe proof:** the lemma is not `unsafe` and contains no `meta`
   code.

The first use of an admissible lemma **must** append it (one-liner) to
*ordinal-toolkit.md*; later uses need no paperwork.

## 12. DO‑NOT‑USE / DEPRECATED IN THIS PROJECT

- **Generic** `mul_le_mul_left` (from `Algebra.Order.Monoid.Defs`) on ordinal goals. Use `Ordinal.mul_*` APIs instead.
- Old paths `Mathlib.Data.Ordinal.*` — replaced by `Mathlib.SetTheory.Ordinal.*`.
- `Ordinal.opow_lt_opow_right` (upstream removed). Use the **local** `opow_lt_opow_right` defined in §5.
- `le_of_not_lt` (deprecated) — use `le_of_not_gt`.

## 13. READY‑MADE SNIPPETS

**Nat‑sized measure (optional helper):**
```lean
@[simp] def size : Trace → Nat
| void => 1
| delta t => size t + 1
| integrate t => size t + 1
| merge a b => size a + size b + 1
| recΔ b s n => size b + size s + size n + 1
| eqW a b => size a + size b + 1

theorem step_size_decrease {t u : Trace} (h : Step t u) : size u < size t := by
  cases h <;> simp [size]; linarith
```

**WF via ordinal μ:**
```lean
def StepRev : Trace → Trace → Prop := fun a b => Step b a

theorem strong_normalization_forward
  (dec : ∀ {a b}, Step a b → mu b < mu a) : WellFounded (StepRev Step) := by
  have wfμ : WellFounded (fun x y : Trace => mu x < mu y) := InvImage.wf (f := mu) Ordinal.lt_wf
  have sub : Subrelation (StepRev Step) (fun x y => mu x < mu y) := by intro x y h; exact dec h
  exact Subrelation.wf sub wfμ
```

## 14. HELPER LEMMAS FROM TERMINATION_LEGACY.LEAN

```lean
theorem lt_add_one_of_le {x y : Ordinal} (h : x ≤ y) : x < y + 1 :=
  (Order.lt_add_one_iff (x := x) (y := y)).2 h

theorem le_of_lt_add_one {x y : Ordinal} (h : x < y + 1) : x ≤ y :=
  (Order.lt_add_one_iff (x := x) (y := y)).1 h

private lemma le_omega_pow (x : Ordinal) : x ≤ omega0 ^ x :=
  right_le_opow (a := omega0) (b := x) one_lt_omega0

theorem add_one_le_of_lt {x y : Ordinal} (h : x < y) : x + 1 ≤ y := by
  simpa [Ordinal.add_one_eq_succ] using (Order.add_one_le_of_lt h)

private lemma nat_coeff_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ (omega0 ^ (n : Ordinal)) := by
  classical
  cases' n with n
  · -- `n = 0`: `1 ≤ ω^0 = 1`
    simp
  · -- `n = n.succ`

    have hfin : (n.succ : Ordinal) < omega0 := by

      simpa using (Ordinal.nat_lt_omega0 (n.succ))
    have hleft : (n.succ : Ordinal) + 1 ≤ omega0 :=
      Order.add_one_le_of_lt hfin

    have hpos : (0 : Ordinal) < (n.succ : Ordinal) := by
      simpa using (Nat.cast_pos.mpr (Nat.succ_pos n))
    have hmono : (omega0 : Ordinal) ≤ (omega0 ^ (n.succ : Ordinal)) := by
      -- `left_le_opow` has type: `0 < b → a ≤ a ^ b`
      simpa using (Ordinal.left_le_opow (a := omega0) (b := (n.succ : Ordinal)) hpos)

    exact hleft.trans hmono

private lemma coeff_fin_le_omega_pow (n : ℕ) :
  (n : Ordinal) + 1 ≤ omega0 ^ (n : Ordinal) := nat_coeff_le_omega_pow n

@[simp] theorem natCast_le {m n : ℕ} :
  ((m : Ordinal) ≤ (n : Ordinal)) ↔ m ≤ n := Nat.cast_le

@[simp] theorem natCast_lt {m n : ℕ} :
  ((m : Ordinal) < (n : Ordinal)) ↔ m < n := Nat.cast_lt

theorem eq_nat_or_omega0_le (p : Ordinal) :
  (∃ n : ℕ, p = n) ∨ omega0 ≤ p := by
  classical
  cases lt_or_ge p omega0 with
  | inl h  =>
      rcases (lt_omega0).1 h with ⟨n, rfl⟩
      exact Or.inl ⟨n, rfl⟩
  | inr h  => exact Or.inr h

theorem one_left_add_absorb {p : Ordinal} (h : omega0 ≤ p) :
  (1 : Ordinal) + p = p := by
  simpa using (Ordinal.one_add_of_omega0_le h)

theorem nat_left_add_absorb {n : ℕ} {p : Ordinal} (h : omega0 ≤ p) :
  (n : Ordinal) + p = p := by
  simpa using (Ordinal.natCast_add_of_omega0_le (n := n) h)

@[simp] theorem add_natCast_left (m n : ℕ) :
  (m : Ordinal) + (n : Ordinal) = ((m + n : ℕ) : Ordinal) := by
  induction n with
  | zero =>
      simp
  | succ n ih =>
      simp [Nat.cast_succ]

theorem mul_le_mul {a b c d : Ordinal} (h₁ : a ≤ c) (h₂ : b ≤ d) :
    a * b ≤ c * d := by
  have h₁' : a * b ≤ c * b := by
    simpa using (mul_le_mul_right' h₁ b)        -- mono in left factor
  have h₂' : c * b ≤ c * d := by
    simpa using (mul_le_mul_left' h₂ c)         -- mono in right factor
  exact le_trans h₁' h₂'

theorem add4_plus5_le_plus9 (p : Ordinal) :
  (4 : Ordinal) + (p + 5) ≤ p + 9 := by
  classical
  rcases lt_or_ge p omega0 with hfin | hinf
  · -- finite case: `p = n : ℕ`
    rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    -- compute on ℕ first
    have hEqNat : (4 + (n + 5) : ℕ) = (n + 9 : ℕ) := by
      -- both sides reduce to `n + 9`
      simp [Nat.add_left_comm]
    have hEq :
        (4 : Ordinal) + ((n : Ordinal) + 5) = (n : Ordinal) + 9 := by
      calc
        (4 : Ordinal) + ((n : Ordinal) + 5)
            = (4 : Ordinal) + (((n + 5 : ℕ) : Ordinal)) := by
                simp
        _   = ((4 + (n + 5) : ℕ) : Ordinal) := by
                simp
        _   = ((n + 9 : ℕ) : Ordinal) := by
                simpa using (congrArg (fun k : ℕ => (k : Ordinal)) hEqNat)
        _   = (n : Ordinal) + 9 := by
                simp
    exact le_of_eq hEq
  · -- infinite-or-larger case: the finite prefix on the left collapses
    -- `5 ≤ 9` as ordinals
    have h59 : (5 : Ordinal) ≤ (9 : Ordinal) := by
      simpa using (natCast_le.mpr (by decide : (5 : ℕ) ≤ 9))
    -- monotonicity in the right argument
    have hR : p + 5 ≤ p + 9 := by
      simpa using add_le_add_left h59 p
    -- collapse `4 + p` since `ω ≤ p`
    have hcollapse : (4 : Ordinal) + (p + 5) = p + 5 := by
      calc
        (4 : Ordinal) + (p + 5)
            = ((4 : Ordinal) + p) + 5 := by
                simp [add_assoc]
        _   = p + 5 := by
                have h4 : (4 : Ordinal) + p = p := nat_left_add_absorb (n := 4) (p := p) hinf
                rw [h4]
    simpa [hcollapse] using hR

theorem add_nat_succ_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + Order.succ p ≤ p + (k + 1) := by
  rcases lt_or_ge p omega0 with hfin | hinf
  · rcases (lt_omega0).1 hfin with ⟨n, rfl⟩
    have hN : (k + (n + 1) : ℕ) = n + (k + 1) := by
      simp [Nat.add_left_comm]
    have h :
        (k : Ordinal) + ((n : Ordinal) + 1) = (n : Ordinal) + (k + 1) := by
      calc
        (k : Ordinal) + ((n : Ordinal) + 1)
            = ((k + (n + 1) : ℕ) : Ordinal) := by simp
        _   = ((n + (k + 1) : ℕ) : Ordinal) := by
              simpa using (congrArg (fun t : ℕ => (t : Ordinal)) hN)
        _   = (n : Ordinal) + (k + 1) := by simp
    have : (k : Ordinal) + Order.succ (n : Ordinal) = (n : Ordinal) + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using h
    exact le_of_eq this
  ·
    have hk : (k : Ordinal) + p = p := nat_left_add_absorb (n := k) hinf
    have hcollapse :
        (k : Ordinal) + Order.succ p = Order.succ p := by
      simpa [Ordinal.add_succ] using congrArg Order.succ hk
    have hkNat : (1 : ℕ) ≤ k + 1 := Nat.succ_le_succ (Nat.zero_le k)
    have h1k : (1 : Ordinal) ≤ (k + 1 : Ordinal) := by
      simpa using (natCast_le.mpr hkNat)
    have hstep0 : p + 1 ≤ p + (k + 1) := add_le_add_left h1k p
    have hstep : Order.succ p ≤ p + (k + 1) := by
      simpa [Ordinal.add_one_eq_succ] using hstep0
    exact (le_of_eq hcollapse).trans hstep

theorem add_nat_plus1_le_plus_succ (k : ℕ) (p : Ordinal) :
  (k : Ordinal) + (p + 1) ≤ p + (k + 1) := by
  simpa [Ordinal.add_one_eq_succ] using add_nat_succ_le_plus_succ k p

theorem add3_succ_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + Order.succ p ≤ p + 4 := by
  simpa using add_nat_succ_le_plus_succ 3 p

theorem add2_succ_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + Order.succ p ≤ p + 3 := by
  simpa using add_nat_succ_le_plus_succ 2 p

theorem add3_plus1_le_plus4 (p : Ordinal) :
  (3 : Ordinal) + (p + 1) ≤ p + 4 := by
  simpa [Ordinal.add_one_eq_succ] using add3_succ_le_plus4 p

theorem add2_plus1_le_plus3 (p : Ordinal) :
  (2 : Ordinal) + (p + 1) ≤ p + 3 := by
  simpa [Ordinal.add_one_eq_succ] using add2_succ_le_plus3 p

theorem lt_add_one (x : Ordinal) : x < x + 1 := lt_add_one_of_le (le_rfl)

theorem mul_succ (a b : Ordinal) : a * (b + 1) = a * b + a := by
  simpa [mul_one, add_comm, add_left_comm, add_assoc] using
    (mul_add a b (1 : Ordinal))

/-- **Strict** monotone: `b < c → ω^b < ω^c`. -/
theorem opow_lt_opow_ω {b c : Ordinal} (h : b < c) :
    omega0 ^ b < omega0 ^ c := by
  simpa using
    ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

theorem opow_le_opow_ω {p q : Ordinal} (h : p ≤ q) :
    omega0 ^ p ≤ omega0 ^ q := by
  exact Ordinal.opow_le_opow_right omega0_pos h   -- library lemma

theorem opow_lt_opow_right {b c : Ordinal} (h : b < c) :
   omega0 ^ b < omega0 ^ c := by
  simpa using
   ((Ordinal.isNormal_opow (a := omega0) one_lt_omega0).strictMono h)

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos
  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [Ordinal.opow_add] using (Ordinal.opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁
  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    Ordinal.opow_le_opow_right omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂

private lemma two_lt_three : (2 : Ordinal) < 3 := by
  have : (2 : ℕ) < 3 := by decide
  simpa using (Nat.cast_lt).2 this

@[simp] theorem opow_mul_lt_of_exp_lt
    {β α γ : Ordinal} (hβ : β < α) (hγ : γ < omega0) :
    omega0 ^ β * γ < omega0 ^ α := by

  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp
  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')

---

## 17. ERROR PATTERN LOG (VERBATIM INCIDENT FORMS)

Each entry: (Code / Symptom / Minimal Reproducer / Resolution Pattern)

EP1  Universe polymorphism cascade / `invalid universe level assignment` / `mu : Trace → Ordinal` / redefine as `mu : Trace → Ordinal.{0}`; recompile
EP2  Generic multiplication lemma misuse / goal `c * a ≤ c * b` with ordinals / attempted `mul_le_mul_left` / replace with `mul_le_mul_left'` or `Ordinal.mul_le_mul_iff_left`
EP3  Lost strictness after right addition / transformed `h : x < y` into `h' : x + z < y + z` / ordinal addition not strictly right‑monotone / restructure inequality via exponent lift then absorb finite tail
EP4  Unsound structural assumption / inserted `have : mu s ≤ mu (delta n)` / counterexample (double delta vs void) refutes; delete assumption and isolate needed dominance via auxiliary measure κ
EP5  Deprecated lemma name / used `Ordinal.opow_lt_opow_right` (removed) / error unknown identifier / introduce local `opow_lt_opow_right` via `isNormal_opow.strictMono`
EP6  Name hallucination / `Ordinal.isAdditivePrincipal_omega_pow` / rename to `Ordinal.principal_add_omega0_opow`
EP7  Absorption applied without infinitude proof / rewrote `(3 : Ordinal) + p` to `p` / missing `omega0 ≤ p` / first prove finite part < ω ≤ p; then apply `nat_left_add_absorb`
EP8  Over‑aggressive simp flattening / `simp [add_assoc, add_comm, add_left_comm]` removed tower grouping needed for `opow_add` alignment / limit simp scope (avoid comm/assoc when matching structured pattern)
EP9  Wrong orientation of multiplication / replaced `ω^k * X` with `X * ω^k` / ordinal multiplication non‑commutative / keep canonical left factor power for monotone lemmas
EP10 Misuse of `ring` on exponent goal / attempted `ring` on `omega0 ^ (a + b + 1)` equality / `ring` handles semiring arithmetic (ℕ/ℤ), not ordinal exponent formulas / use `opow_add` rewriting
EP11 Missing qualification / bare `opow_le_opow_right` ambiguous import path / fully qualify: `Ordinal.opow_le_opow_right`
EP12 Incorrect finite padding reasoning / attempted to force `μ a + 4 < μ a + 5` inside tail sum after rearrangement that lost left alignment / recover by explicit lemma `add_lt_add_left (by norm_num)`
EP13 Stalled search for strict chain / no progress `lt_of_le_of_lt` due to wrong order / reorder: derive `x ≤ y` then `y < z` not vice versa
EP14 Case split omission / handling `(void, void)` inside general eqW inequality produced stuck exponent comparison / perform `by_cases (a = void ∧ b = void)` first
EP15 Duplicate local lemma collision / redefining `omega_pow_add3_lt` second time / rename or reference existing definition; avoid shadowing for provenance clarity

## 18. SUCCESSFUL PATTERN SEQUENCES (CANONICAL TEMPLATES)

SP1  Head–Tail Merge Bounding:
  Input goal: `mu (merge a b) + 1 < ω^(C + 5)` with `C = μa + μb`
  Steps: termA_le → termB_le → exponent < (C+5) proofs → two opow monotonic lifts → combine via `omega_pow_add3_lt` including finite tail → rewrite μ definition

SP2  Integrate + Merge Elevation (eqW path):
  Start: `mu (integrate (merge a b))`
  Expansion: rewrite integrate layer `ω^4 * (...) + 1`; apply merge inner bound; multiply inequality by `ω^4`; use `opow_add`; absorption of finite 4 via `nat_left_add_absorb` using `ω ≤ μa + μb`; exponent bump from `C+5` to `C+9` with finite chain `(5 < 9)`; final add-one chain via `Order.add_one_le_of_lt`

SP3  Recursor Tail Isolation (legacy parameterized):
  Input inequality parameter `h_mu_recΔ_bound`
  Derive: tail_lt_A from termB_le + exponent chain; head_lt_A from termA_le; combine with additive principal triple sum; compare to expanded `μ(recΔ ...)`

SP4  Exponent Strictness Promotion:
  Known: `α < β`
  Derive: `omega0 ^ α < omega0 ^ β` via local `opow_lt_opow_right`; extend chain with `lt_of_le_of_lt` after an initial `≤` produced by product or additive estimates

SP5  Finite Absorption Safe Application:
  Show: `omega0 ≤ P`
  Then: use `nat_left_add_absorb (h := ‹omega0 ≤ P›)` to fold `(n : Ordinal) + P` to `P`

SP6  Two‑Stage Sum Comparison:
  Goal: `μb + k ≤ μa + μb + k`
  Use: `add_le_add_right (le_add_of_nonneg_left (zero_le _)) k` then follow with strict bump `add_lt_add_left (by norm_num)`

SP7  Triple Additive Principal Folding:
  Given three summands each `< ω^κ` plus finite tail `< ω^κ`
  Sequence: first combine two via `omega_pow_add_lt`; reapply with third; final associativity normalization `simpa [add_assoc]`

SP8  Finite → Exponent Positivity:
  Show `(0 : Ordinal) < m` for finite numeral `m`; then `lt_of_lt_of_le` to embed into larger expression like `μ(δ n) + μ s + m`

SP9  Product Left‑Strict Lift:
  With `γ < ω` and base positivity: derive `ω^β * γ < ω^β * ω`; rewrite right side to `ω^(β+1)` with `opow_add`; cascade to larger exponent with `opow_le_opow_right`

SP10 Merge Measure Reassociation:
  Normalize `mu (merge a b)` to `ω^3*(μa+1) + (ω^2*(μb+1) + 1)` using `simp [mu, add_assoc]` to align with additive principal template

## 19. ABSORPTION PRECONDITION CATALOGUE

AP1  `(n : Ordinal) + p = p` requires `omega0 ≤ p` (establish via exponent tower positivity or prior inequality)  
AP2  `(1 : Ordinal) + p = p` same requirement (use `one_left_add_absorb` wrapper)  
AP3  Folding `(k : Ordinal) + (p + m)` to `p + m` requires `omega0 ≤ p` not merely `ω ≤ p + m`  
AP4  Inside exponent adjustment `(c : Ordinal) + (C + d) = C + d` needs `(c : Ordinal) + C = C`; prove absorption first then reassociate  
AP5  Avoid absorption inside a product: cannot simplify `ω^n * ((m : Ordinal) + p)` by absorption; expand addition after multiplication not before

## 20. EXPONENT COMPARISON INVENTORY

EC1  Bumping finite suffix: `(C + k) < (C + m)` via `add_lt_add_left (by norm_num)` (k < m)  
EC2  Prefix insertion: `x ≤ y` implies `x + k ≤ y + k` (left additive monotone)  
EC3  Chaining: `α < β ≤ γ` becomes `α < γ` using `lt_of_lt_of_le`  
EC4  From strict to successor: `α < β` gives `α + 1 ≤ β` via `Order.add_one_le_of_lt`  
EC5  Exponent lift (≤): `h : a ≤ b` → `ω^a ≤ ω^b` via `Ordinal.opow_le_opow_right omega0_pos h`  
EC6  Exponent lift (<): `h : a < b` → `ω^a < ω^b` via local strictMono lemma  
EC7  Composite: `ω^a * (b+1)` bound by first bounding `(b+1)` then applying multiplication monotonicity then exponent comparison  
EC8  Finite stacking: `ω^(n) * ω^(m) = ω^(n+m)` using symmetry of `opow_add` orientation `(opow_add _ _ _).symm`

## 21. DEPRECATED / CORRECT NAME MAP

| Deprecated / Incorrect | Correct | Context |
|------------------------|---------|---------|
| `Ordinal.opow_lt_opow_right` | local `opow_lt_opow_right` | Removed upstream strict lemma |
| `isAdditivePrincipal_omega_pow` | `principal_add_omega0_opow` | Additive principal ordinal lemma |
| `Ordinal.nat_add_of_omega_le` | `Ordinal.natCast_add_of_omega0_le` | API rename variant (observed mismatch) |
| `one_add_of_omega_le` | `one_add_of_omega0_le` | Ensure explicit ω₀ subscript |
| `le_of_not_lt` | `le_of_not_gt` | Modern replacement |

## 22. TACTIC USAGE MATRIX

| Tactic | Allowed | Typical Scope | Prohibited Uses |
|--------|---------|---------------|-----------------|
| `simp` | Yes | Reassociating additions, unfolding μ constructors selectively | Blanket over entire large goal that removes stratification |
| `linarith` | Yes | Finite numeral comparisons inside exponent deltas | On ordinal exponentials (`omega0 ^ α`) directly |
| `ring` | Yes | Simplify finite Nat subgoals generated by casts | On ordinal multiplications/exponentiations |
| `norm_num` | Yes | Proving finite inequalities like `(3 : Ordinal) < 6` | Outside pure numeral contexts |
| `rewrite` | Yes | Applying specific `opow_add`, absorption equalities | Chasing equalities that increase size without progress |
| `library_search` | Caution | Discover admissible lemmas (green channel) | Accepting lemma without qualification/prefix audit |

## 23. SEARCH PROTOCOL EXEMPLAR

Example (looking for additive principal lemma):
  SEARCH(principal_add_omega0_opow) → Found 1 match
  Output permitted; lemma inserted verbatim.
Missing name example: SEARCH(isAdditivePrincipal_omega_pow) → 0 results – rename to `principal_add_omega0_opow` and record mapping (see §21).

## 24. PENDING GREEN‑CHANNEL CANDIDATES (Not Yet Used)

List placeholders (must search before first usage):
GC1  `Ordinal.mul_lt_mul_of_pos_right` (evaluate strictness side conditions)  
GC2  `Ordinal.add_right_cancel` (check applicability; beware non‑cancellation in some ordinal forms)  
GC3  `Ordinal.inductionOn` variants for structured recursion proofs  
GC4  `Ordinal.principal_mul_omega0_opow` (if upstream introduces multiplicative principal families)  

## 25. LEMMA USAGE LOCATION INDEX (LEGACY μ)

| Lemma | First Recorded Line (Termination_Legacy) | Purpose |
|-------|-------------------------------------------|---------|
| termA_le | ~290 | Bound ω³ head payload |
| termB_le | ~312 | Bound ω² tail payload |
| payload_bound_merge | ~330 | Combine head+tail+1 under ω^(x+5) |
| omega_pow_add3_lt | ~520 / ~700 | Triple additive principal composition |
| merge_inner_bound_simple | ~1030 | Inner bound for eqW chain |
| mu_lt_eq_diff_both_void | ~1080 | Corner case eqW inequality |
| mu_lt_eq_diff | ~1120 | General eqW inequality |
| tail_lt_A | ~860 | Recursor tail < dominant A tower |
| head_lt_A | ~650 | Recursor head < dominant A tower |

## 26. COUNTEREXAMPLES LIBRARY

CE1  False right‑add strictness:
  Let `a := omega0`, `b := omega0 + 1`, `c := omega0^2`. Then `a < b` but `a + c = c = b + c`.
CE2  Invalid μ parameter relation:
  `s := delta (delta void)`; `n := void`; then `mu s > mu (delta n)`.
CE3  Finite padding insufficiency:
  For large `t : Trace` with `mu t ≥ ω^(μ n + μ s + 6)`, inequality using only +4/+6 fails to separate exponents.
CE4  Multiplication commutativity assumption:
  `ω^2 * (ω^3 + 1) ≠ (ω^3 + 1) * ω^2` (structures differ in Cantor normal form ordering).
CE5  Absorption without infinitude:
  `(3 : Ordinal) + (5 : Ordinal) ≠ 5` though `(3 : Ordinal) + ω = ω`.

## 27. MINIMAL REWRITE ORDERING GUIDELINES

R1  Expand products after establishing additive bounds; do not expand early if it hides factorization needed for `opow_add`.
R2  Apply exponent comparisons before absorption to avoid losing monotonic structure.
R3  Preserve left‑nested additive shape for principal applications: `A + (B + C)` is acceptable; flatten only when lemma requires `A + B + C`.
R4  Avoid commuting finite and transfinite summands unless infinite right operand already proven (`omega0 ≤ p`).

## 28. FUTURE ORDINAL TOOLING TODO (FACTUAL BACKLOG)

T1  Catalogue every instance of `omega0 ^ (k : Ordinal)` usage with k ∈ {2,3,4,5,6,9} across μ lemmas (pending automated grep table)
T2  Record potential generalization of `omega_pow_add3_lt` to n‑ary list fold (requires recursive principal closure proof)
T3  Introduce explicit lemma: `finite_lt_power` : `(n : Ordinal) < omega0 ^ (k + 1)` for all finite k (derive via `nat_lt_omega0` + exponent monotonicity) — not yet formalized here
T4  Audit all absorptions to ensure each has proximal proof of `omega0 ≤ target` line above (scriptable lint)
T5  Provide CNF (Cantor normal form) commentary mapping for each μ constructor exponent tier (draft placeholder)

---

````
  have hpos : (0 : Ordinal) < omega0 ^ β :=
    Ordinal.opow_pos (a := omega0) (b := β) omega0_pos
  have h₁ : omega0 ^ β * γ < omega0 ^ β * omega0 :=
    Ordinal.mul_lt_mul_of_pos_left hγ hpos


  have h_eq : omega0 ^ β * omega0 = omega0 ^ (β + 1) := by
    simpa [opow_add] using (opow_add omega0 β 1).symm
  have h₁' : omega0 ^ β * γ < omega0 ^ (β + 1) := by
    simpa [h_eq, -opow_succ] using h₁


  have h_exp : β + 1 ≤ α := Order.add_one_le_of_lt hβ  -- FIXED: Use Order.add_one_le_of_lt instead
  have h₂ : omega0 ^ (β + 1) ≤ omega0 ^ α :=
    opow_le_opow_right (a := omega0) omega0_pos h_exp


  exact lt_of_lt_of_le h₁' h₂


lemma omega_pow_add_lt
    {κ α β : Ordinal} (_ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) :
    α + β < omega0 ^ κ := by
  have hprin : Principal (fun x y : Ordinal => x + y) (omega0 ^ κ) :=
    Ordinal.principal_add_omega0_opow κ
  exact hprin hα hβ


lemma omega_pow_add3_lt
    {κ α β γ : Ordinal} (hκ : 0 < κ)
    (hα : α < omega0 ^ κ) (hβ : β < omega0 ^ κ) (hγ : γ < omega0 ^ κ) :
    α + β + γ < omega0 ^ κ := by
  have hsum : α + β < omega0 ^ κ :=
    omega_pow_add_lt hκ hα hβ
  have hsum' : α + β + γ < omega0 ^ κ :=
    omega_pow_add_lt hκ (by simpa using hsum) hγ
  simpa [add_assoc] using hsum'

@[simp] lemma add_one_lt_omega0 (k : ℕ) :
    ((k : Ordinal) + 1) < omega0 := by
  -- `k.succ < ω`
  have : ((k.succ : ℕ) : Ordinal) < omega0 := by
    simpa using (nat_lt_omega0 k.succ)
  simpa [Nat.cast_succ, add_comm, add_left_comm, add_assoc,
         add_one_eq_succ] using this

@[simp] lemma one_le_omega0 : (1 : Ordinal) ≤ omega0 :=
  (le_of_lt (by
    have : ((1 : ℕ) : Ordinal) < omega0 := by
      simpa using (nat_lt_omega0 1)
    simpa using this))


lemma add_le_add_of_le_of_nonneg {a b c : Ordinal}
    (h : a ≤ b) (_ : (0 : Ordinal) ≤ c := by exact Ordinal.zero_le _)
    : a + c ≤ b + c :=
  add_le_add_right h c

@[simp] lemma lt_succ (a : Ordinal) : a < Order.succ a := by
  have : a < a + 1 := lt_add_of_pos_right _ zero_lt_one
  simpa [Order.succ] using this

alias le_of_not_gt := le_of_not_lt

attribute [simp] Ordinal.IsNormal.strictMono

-- Helper lemma for positivity arguments in ordinal arithmetic
lemma zero_lt_one : (0 : Ordinal) < 1 := by norm_num

-- Helper for successor positivity
lemma succ_pos (a : Ordinal) : (0 : Ordinal) < Order.succ a := by
  -- Order.succ a = a + 1, and we need 0 < a + 1
  -- This is true because 0 < 1 and a ≥ 0
  have h1 : (0 : Ordinal) ≤ a := Ordinal.zero_le a
  have h2 : (0 : Ordinal) < 1 := zero_lt_one
  -- Since Order.succ a = a + 1
  rw [Order.succ]
  -- 0 < a + 1 follows from 0 ≤ a and 0 < 1
  exact lt_of_lt_of_le h2 (le_add_of_nonneg_left h1)

@[simp] lemma succ_succ (a : Ordinal) :
    Order.succ (Order.succ a) = a + 2 := by
  have h1 : Order.succ a = a + 1 := rfl
  rw [h1]
  have h2 : Order.succ (a + 1) = (a + 1) + 1 := rfl
  rw [h2, add_assoc]
  norm_num

lemma add_two (a : Ordinal) :
    a + 2 = Order.succ (Order.succ a) := (succ_succ a).symm


@[simp] theorem opow_lt_opow_right_iff {a b : Ordinal} :
    (omega0 ^ a < omega0 ^ b) ↔ a < b := by
  constructor
  · intro hlt
    by_contra hnb          -- assume ¬ a < b, hence b ≤ a
    have hle : b ≤ a := le_of_not_gt hnb
    have hle' : omega0 ^ b ≤ omega0 ^ a := opow_le_opow_ω hle
    exact (not_le_of_gt hlt) hle'
  · intro hlt
    exact opow_lt_opow_ω hlt

@[simp] theorem le_of_lt_add_of_pos {a c : Ordinal} (hc : (0 : Ordinal) < c) :
    a ≤ a + c := by
  have hc' : (0 : Ordinal) ≤ c := le_of_lt hc
  simpa using (le_add_of_nonneg_right (a := a) hc')
```

END FILE: C:\Users\Moses\OpComp\MUST_Review\important_2\2.Expanded_Ordinal_Toolkit.md

