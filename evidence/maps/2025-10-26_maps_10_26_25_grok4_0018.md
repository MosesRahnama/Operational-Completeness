# Exploring ordinal approach for strong normalization
_Exported on 11/1/2025 at 16:21:10 EDT from Cursor (2.0.34)_

---

**User**

I'm thinking of ordinal approach to prove strong normalization here. What do you think? I don't want to use any external. Axioms, helpers. This is gonna be a computational system. This is my kernel. It's on object level. But to make my life easier, I'm gonna. Build the proofs on the meta level And only use the essential standard lemmas. I am thinking of ordinal approach. But I don't have much math experience. I've heard about these methods recently. 

---

**Cursor**

The ordinal approach is a solid and classic way to prove strong normalization (SN) in systems like this—essentially showing that every reduction sequence (via `Step` and `StepStar` in your Lean kernel) terminates in a finite number of steps, with no infinite descending chains. It's particularly useful for recursive or higher-order systems where simpler measures (like term size) might not suffice, as ordinals can handle transfinite induction. From what I can see in your `basic.lean` file, your `Trace` inductive type and reduction rules (especially the recursion in `recΔ` mimicking natural number recursion, and operations like `merge` and `eqW` that could potentially create complex reductions) could benefit from this, as it provides a well-founded ordering that decreases with each `Step`.

That said, since you mentioned limited experience with ordinals and a desire to keep everything internal to your kernel (no external axioms or heavy helpers), here's my take on feasibility and how to approach it—drawing from standard methods in type theory and rewriting systems (validated via web searches on proofs using ordinals for SN):

### Pros of the Ordinal Approach for Your System
- **Fits Your Constraints**: You can define ordinals inductively within Lean at the object level, without extra axioms. For example, use an inductive type for ordinals in Cantor normal form (like `Ordinal := zero | succ Ordinal | limit (Nat → Ordinal)`), which mirrors how Lean handles inductive definitions natively. This keeps it computational and part of your kernel.
- **Handles Your Reductions Well**: Assign an ordinal "rank" or "norm" to each `Trace`:
  - Simple terms like `void` get ordinal 0.
  - `delta t` could be succ of the ordinal of `t`.
  - `recΔ b s n` could use a higher ordinal based on `n` (e.g., ω times something if `n` is like a natural).
  - `merge` or `app` could take the maximum or sum of operands' ordinals, plus some factor to account for cancellation rules like `R_merge_cancel`.
  - Prove that each `Step` strictly decreases this ordinal (e.g., `R_rec_succ` reduces a succ-like structure, dropping the ordinal).
- **Proves SN via Well-Foundedness**: Once you show the assignment decreases and ordinals are well-founded (via induction on your ordinal type), SN follows by contradiction—no infinite chains possible.
- **Meta-Level Proofs**: As you planned, keep the ordinal definitions and assignment function at the object level (in your kernel), but prove the decrease and well-foundedness lemmas at the meta level using Lean's tactics and standard induction principles. Essential lemmas like transitivity or comparison for ordinals can be proven without extras.

### Potential Cons and Challenges
- **Learning Curve**: Ordinals involve concepts like successor, limit ordinals, and arithmetic (e.g., ω as the first infinite ordinal for recursion depth). If you're new to this, it might feel abstract—SN proofs with ordinals often draw from proof theory (e.g., assigning ordinals to terms in lambda calculus to show termination). Your system seems simpler than full System F, so ordinals might be overkill; a natural-number-based measure (e.g., a size function on `Trace`) or structural induction on `Trace` could work first, and you could escalate to ordinals if loops appear.
- **Complexity in Assignment**: Getting the ordinal assignment right for rules like `R_merge_cancel` or `R_eq_diff` (which introduces `integrate` and `merge`) might require careful tuning to ensure strict decrease without infinite ascent. If not, you might need to refine it (e.g., using lexicographic orders).
- **No Externals**: Sticking to internal definitions is great for a pure kernel, but ensure your ordinal type is computable—Lean excels at this with inductives.

### Suggested Steps to Get Started
Since you want to build this yourself with minimal helpers:
1. **Define Ordinals Inductively**: Add to your kernel something like:
   ```
   inductive Ordinal
   | zero : Ordinal
   | succ : Ordinal → Ordinal
   | limit : (Nat → Ordinal) → Ordinal  -- For limits like ω
   ```
   Prove basic properties (e.g., less-than relation, well-foundedness) using induction.

2. **Assign Ordinals to Traces**: Define a function `norm : Trace → Ordinal` that recursively computes based on structure, ensuring it decreases on `Step`.

3. **Prove Decrease**: For each constructor in `Step`, show `norm (new) < norm (old)`.

4. **Induce SN**: Use meta-level induction over ordinals to show no infinite `StepStar` chains.

If this feels too steep, alternatives like Tait-style reducibility (defining a set of "normalizable" terms and showing closure under reductions) might be easier to implement with your existing inductives, and they're standard for SN without ordinals.

What specific part of your system worries you most about normalization (e.g., the recursion in `recΔ`)? I can help sketch a minimal ordinal definition or check a size-based proof first if you'd like.

```plaintext
   inductive Ordinal
   | zero : Ordinal
   | succ : Ordinal → Ordinal
   | limit : (Nat → Ordinal) → Ordinal  -- For limits like ω
   ```
   Prove basic properties (e.g., less-than relation, well-foundedness) using induction.

2. **Assign Ordinals to Traces**: Define a function `norm : Trace → Ordinal` that recursively computes based on structure, ensuring it decreases on `Step`.

3. **Prove Decrease**: For each constructor in `Step`, show `norm (new) < norm (old)`.

4. **Induce SN**: Use meta-level induction over ordinals to show no infinite `StepStar` chains.

If this feels too steep, alternatives like Tait-style reducibility (defining a set of "normalizable" terms and showing closure under reductions) might be easier to implement with your existing inductives, and they're standard for SN without ordinals.

What specific part of your system worries you most about normalization (e.g., the recursion in `recΔ`)? I can help sketch a minimal ordinal definition or check a size-based proof first if you'd like.
```

