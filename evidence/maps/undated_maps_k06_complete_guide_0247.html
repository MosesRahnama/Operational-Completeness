<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>K06_Complete_Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        table td, table th {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        strong {
            color: #2c3e50;
        }
        @media print {
            body {
                max-width: none;
                margin: 0;
                padding: 20px;
            }
            h1 {
                page-break-before: always;
            }
            pre {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
# Termination Companion — Full Mathematical & Algorithmic Dossier<br>
<br>
Version: 2025-08-09 (WORKING DRAFT – exhaustive exposition)  <br>
Scope: Strong Normalization (SN) + structural termination strategy for the OperatorKernelO6 rewrite system.  <br>
Audience: Authors, reviewers, automated agents.  <br>
Prime Directive: No kernel alteration. All reasoning meta-level, axiom‑free (no <code>sorry</code>).<br>
<br>
---<br>
<br>
## 0. Executive Abstract<br>
<br>
We study strong normalization of the rewrite system generated by the 8 kernel rules on the inductive type <code>Trace</code>. We aim to construct a <em>single</em>, well‑founded, ordinal‑valued measure <code>μ : Trace → Ordinal</code> such that for every rewrite step <code>t → u</code> we have <code>μ u < μ t</code>. This ensures termination via <code>InvImage.wf</code>. Confluence (normalize–join) and higher constructions (arithmetic, equality, provability encodings) depend on a canonical normalizing <em>geometry</em>, hence SN is foundational.<br>
<br>
Current status: All rules except the <code>recΔ</code> successor (<code>R_rec_succ</code>) have established strict <code>μ</code> decrease lemmas (or sketches very close to final form). The blocker is an unconditional, non‑circular, ordinal decrease for:<br>
<br>
<pre><code><br>
recΔ b s (delta n)  →  merge s (recΔ b s n)<br>
</code></pre><br>
<br>
We <em>can</em> show decrease for tailored lexicographic measures <code>(κ, μ)</code> where <code>κ</code> counts <code>delta</code> height, but we are pursuing a refined pure‑μ account. The crux: transporting strict inequality through potentially <em>large right additions</em> (ordinal addition non‑strict on the right) without extraneous structural constraints between parameters <code>s</code> and <code>n</code>.<br>
<br>
---<br>
<br>
# OperatorKernelO6 (SSOT-aware)<br>
<br>
## Search-First Development (MANDATORY)<br>
<br>
<strong>Path priority (must search in this order):</strong><br>
1) <code>core_docs/ko6_guide.md</code>  ← <strong>SSOT</strong><br>
2) <code>OperatorKernelO6/**.lean</code><br>
3) Stubs: <code>core_docs/agent.md</code>, <code>core_docs/ordinal-toolkit.md</code> (pointers only)<br>
<br>
<strong>Protocol (before suggesting ANY identifier/tactic/lemma):</strong><br>
- Run a search (ripgrep / #search / #leansearch) over (1)-(2).<br>
- Then <strong>echo</strong> one of:<br>
  - <code>Found N matches (SSOT/code).</code><br>
  - <code>0 results — using GREEN-CHANNEL.</code><br>
- If ≥1 hit → you may use the identifier exactly as found.<br>
- If 0 hits → propose a GREEN-CHANNEL stub:<br>
<br>
<br>
lemma <choose_a_name> : _ := by<br>
  "FULL PROOF RIGHT TEHRE"  -- NOT A SINGLE LINE ALLOWED UNTIL FULL PROOF FOR THE HELPER<br>
Enforcement Gates (don’t skip)<br>
Never invent lemma names. Verify first; copy exact spelling and qualification.<br>
<br>
Use only the ordinal API and names listed in SSOT §8 (imports, prefixes, do-not-use list).<br>
<br>
No axioms, no admit, no partial stubs left behind.<br>
<br>
Save ⇒ lake build ⇒ fix only the lines that error until Problems panel is clean.<br>
<br>
Ordinal API (summary; full list in SSOT §8)<br>
WF: WellFounded.prod_lex, wellFounded_lt, Ordinal.lt_wf<br>
<br>
ω-powers: opow, opow_add, Ordinal.opow_le_opow_right<br>
<br>
Products: Ordinal.mul_lt_mul_of_pos_left, Ordinal.mul_le_mul_iff_left, mul_le_mul_left'<br>
<br>
Successor bridge: Order.lt_add_one_iff, Order.add_one_le_of_lt<br>
<br>
Forbidden: generic mul_le_mul_left (non-ordinal), unqualified names (opow_add), deprecated lemmas.<br>
<br>
Build-and-Fix Loop<br>
Save file → lake build runs.<br>
<br>
If any error: show “PHASE 1/2/3” header:<br>
<br>
PHASE 1 SCAN: list ordinal ops around the error.<br>
<br>
PHASE 2 CHECK: show where each lemma name was found (path+line) or say “0 results — GREEN-CHANNEL”.<br>
<br>
PHASE 3 COPY: name the template proof you’re copying (file+line).<br>
<br>
Apply smallest change; rebuild; repeat.<br>
<br>
Why SSOT?<br>
All canonical rules, imports, and ordinal usage live in core_docs/ko6_guide.md. Treat it as law. (agent.md and ordinal-toolkit.md are stubs that point back to SSOT.)<br>
<br>
<strong>ALWAYS METHEMATICALLY CHECK YOUR SUGGESTED SOLUTION IS MATHEMATICALLY VALIDATED ALL THE WAY UP TO THE FINAL PROOF. NO MATTER WHERE IN THE PROCESS YOU ARE.</strong><br>
<strong>LEAVE NO STONE UNTURNED.</strong><br>
<strong>LEAVE NO ERRORS BEHIND.</strong><br>
<strong>NO SORRY OR ADMIT LEFT BEHIND.</strong><br>
<br>
---<br>
<br>
<br>
## 1. Kernel Recap (Immutable Substrate)<br>
<br>
Constructors of <code>Trace</code>:<br>
1. <code>void</code><br>
2. <code>delta t</code><br>
3. <code>integrate t</code><br>
4. <code>merge a b</code><br>
5. <code>recΔ b s n</code><br>
6. <code>eqW a b</code><br>
<br>
Rewrite rules (<code>Step</code>):<br>
- (Int‑Δ) <code>integrate (delta t) → void</code><br>
- (M‑0L) <code>merge void t → t</code><br>
- (M‑0R) <code>merge t void → t</code><br>
- (M‑C)  <code>merge t t → t</code><br>
- (Rec‑0) <code>recΔ b s void → b</code><br>
- (Rec‑S) <code>recΔ b s (delta n) → merge s (recΔ b s n)</code><br>
- (Eq‑Refl) <code>eqW a a → void</code><br>
- (Eq‑Diff) <code>eqW a b → integrate (merge a b)</code> (always fires; reflexive case already catches equality)<br>
<br>
<code>StepStar</code> is the reflexive–transitive closure used for normalization and confluence arguments.<br>
<br>
---<br>
<br>
## 2. Strategic Design of the Ordinal Measure μ<br>
<br>
### 2.1 Architecture Principles<br>
We build <code>μ</code> as a <em>Cantor normal form inspired</em> composite whose leading exponents isolate constructor <em>strata</em>. The ordinal growth tiers strictly separate constructors, ensuring no ambiguity in dominance comparisons:<br>
<br>
<pre><code><br>
μ void              := 0<br>
μ (delta t)         := ω^(5) * (μ t + 1) + 1<br>
μ (integrate t)     := ω^(4) * (μ t + 1) + 1<br>
μ (merge a b)       := ω^(3) <em> (μ a + 1) + ω^(2) </em> (μ b + 1) + 1<br>
μ (recΔ b s n)      := ω^( μ n + μ s + 6 ) + ω * (μ b + 1) + 1<br>
μ (eqW a b)         := ω^( μ a + μ b + 9 ) + 1<br>
</code></pre><br>
<br>
### 2.2 Rationale for Exponent Slots<br>
| Constructor | Leading Component | Justification |<br>
|-------------|-------------------|---------------|<br>
| <code>delta</code>     | <code>ω^5</code>             | Fixed high finite exponent reserved for unary growth steps |<br>
| <code>integrate</code> | <code>ω^4</code>             | Below delta to ensure integrate∘delta collapses massively |<br>
| <code>merge</code>     | <code>ω^3</code>, <code>ω^2</code>      | Binary layering; left operand prioritized over right |<br>
| <code>recΔ</code>      | <code>ω^(μ n + μ s + 6)</code> | Dynamic tower capturing recursive depth parameter interplay |<br>
| <code>eqW</code>       | <code>ω^(μ a + μ b + 9)</code> | High tier bounding combination before reduction via merge/integrate |<br>
<br>
Finite offsets (<code>+1</code>, <code>+6</code>, <code>+9</code>) ensure separation margins and space for arithmetic safety lemmas (e.g., successor bridging and exponent bumping).<br>
<br>
### 2.3 Design Invariants<br>
1. <strong>Constructor Stratification:</strong> Any dynamic exponent (<code>μ n + μ s + 6</code>) strictly dominates all <em>fixed finite</em> exponent shells (≤ 5) whenever either <code>μ n</code> or <code>μ s</code> grows beyond finite ranges, thereby giving room for recursion descent.<br>
2. <strong>Additive Principal Usage:</strong> <code>ω^κ</code> with <code>κ ≥ 1</code> is additive principal. Used to absorb finite and lower‑order sums and maintain canonical dominance ordering.<br>
3. <strong>Payload Normalization:</strong> Each non-leading summand is controlled (e.g., <code>ω*(μ b + 1)</code> subordinate to preceding tower) ensuring additive absorption lemmas apply uniformly.<br>
<br>
---<br>
<br>
## 3. Proof Skeleton for Strong Normalization<br>
<br>
### 3.1 Goal<br>
Show: <code>∀ t u, Step t u → μ u < μ t</code>. Then <code>WellFounded (StepRev)</code> where <code>StepRev a b := Step b a</code> follows from <code>InvImage.wf</code> of <code><</code> on ordinals.<br>
<br>
### 3.2 Rule‑By‑Rule Decrease Concepts<br>
| Rule | Structural Effect | Decrease Mechanism Sketch (Current Status) |<br>
|------|-------------------|--------------------------------------------|<br>
| Int‑Δ | Eliminates a full <code>delta</code> layer via <code>integrate</code> | Proven strict μ drop (<code>μ(integrate δ t) > μ void</code>). |<br>
| Merge‑Void (L/R) | Erases leading merge shell | Proven: added ω³/ω² head dominates payload; inverse step strictly decreases μ. |<br>
| Merge‑Cancel | Collapses duplicate symmetric merge | Proven: removal of duplicated ω² block. |<br>
| Rec‑0 | Base case of recursion | Proven μ increase from <code>b</code> to <code>recΔ b s void</code>; inverse decreases. |<br>
| Rec‑S | Moves one delta inward, reorganizes as merge | BLOCKED for pure μ (needs impossible (★)); lexicographic strategy under redesign (simple κ rejected; multiset κ pending). |<br>
| Eq‑Refl | Eliminates equality wrapper | Proven: large ω^(…+9) tower removed. |<br>
| Eq‑Diff | Converts equality to integrate(merge …) | Proven: ω^(…+9)+1 strictly dominates integrate+merge expansion. |<br>
<br>
### 3.3 Typical Lemma Pattern<br>
1. <strong>Local Growth Fact:</strong> Show payload subcomponents <code>< ω^κ</code> individually.<br>
2. <strong>Principal Absorption:</strong> Use additive principal property to fold finite or subordinate sums into <code>ω^κ</code>.<br>
3. <strong>Exponent Lift:</strong> Convert product of towers via <code>opow_add</code> to unify exponent arithmetic.<br>
4. <strong>Strict Gap:</strong> Use arithmetic offset (e.g., <code>+4</code>, <code>+6</code>, <code>+9</code>) to secure strict inequality on exponents.<br>
<br>
---<br>
<br>
## 4. Established Lemmas (Conceptual Summaries)<br>
<br>
NOTE: Some referenced lemmas exist in <code>Termination_C.lean</code> or the legacy <code>Termination.lean</code>. Names may vary but conceptual content is stabilized.<br>
<br>
| Lemma | Intent | Status |<br>
|-------|--------|--------|<br>
| <code>mu_void_lt_integrate_delta</code> | <code>μ void < μ (integrate (delta t))</code> | Proven |<br>
| <code>mu_void_lt_eq_refl</code> | Reflexive equality adds large tower | Proven |<br>
| <code>mu_lt_merge_void_left/right</code> | Merge with void dominates original | Proven |<br>
| <code>mu_lt_merge_cancel</code> | Idempotent merge strictly larger | Proven |<br>
| <code>mu_n_add_two_le_mu_delta</code> | Finite padding below δ tower | Needs refinement (orientation fixes) |<br>
| <code>mu_lt_mu_delta</code> | Strict growth from <code>n</code> to <code>delta n</code> | In progress (orientation cleanup) |<br>
| <code>mu_ns_lt_mu_delta_ns</code> | Exponent bump transport over tail | BLOCKED (ordinal right-add non‑strict) |<br>
| <code>termA_le</code> | <code>ω^3*(x+1) ≤ ω^(x+4)</code> | Proven |<br>
| <code>termB_le</code> | <code>ω^2*(x+1) ≤ ω^(x+3)</code> | Proven (legacy file) |<br>
| <code>merge_inner_bound_simple</code> | Merge payload <code>< ω^(μ a + μ b + 5)</code> | Proven (earlier phase) |<br>
| <code>mu_lt_eq_diff_both_void</code> | Corner reduction void/void | Proven |<br>
| <code>omega_pow_fin_mul_cnf_lt</code> | Finite left factor absorption | Partially simplified |<br>
| <code>rec_tail_block_lt</code> | Tail bounding for Rec‑S | Incomplete; depends on additive transport |<br>
| <code>mu_lt_rec_succ_uncond</code> | Core Rec‑S decrease | Draft (relies on incomplete tail lemma) |<br>
<br>
---<br>
<br>
## 5. The Rec‑Successor Bottleneck<br>
<br>
### 5.1 Desired Inequality<br>
Need: <code>μ (merge s (recΔ b s n)) < μ (recΔ b s (delta n))</code>.<br>
<br>
Expansions (RHS vs LHS major parts):<br>
<br>
<pre><code><br>
μ (recΔ b s (delta n)) = ω^( μ (delta n) + μ s + 6 ) + ω*(μ b + 1) + 1<br>
μ (recΔ b s n)         = ω^( μ n + μ s + 6 ) + ω*(μ b + 1) + 1<br>
μ (merge s (recΔ b s n))<br>
	= ω^3<em>(μ s + 1) + ω^2</em>(μ (recΔ b s n) + 1) + 1<br>
</code></pre><br>
<br>
So it suffices to place both <code>ω^3<em>(μ s + 1)</code> and <code>ω^2</em>(μ (recΔ b s n) + 1)</code> <em>strictly below</em> the dominant tower <code>A := ω^( μ (delta n) + μ s + 6 )</code>, then show RHS adds a <em>new positive tail</em> after <code>A</code>, giving strict growth.<br>
<br>
### 5.2 Obstruction<br>
To prove <code>ω^2*(μ (recΔ b s n) + 1) < A</code>, we reduce to showing <code>μ (recΔ b s n) + 1 < A</code>. By additive principal normality of <code>ω^(...)</code>, we need the leading part <code>ω^( μ n + μ s + 6 )</code> strictly below <code>A</code>. That reduces to the exponent inequality:<br>
<br>
<pre><code><br>
μ n + μ s + 6 < μ (delta n) + μ s + 6  (⋆)<br>
</code></pre><br>
<br>
But <code>(⋆)</code> is <em>not derivable just from</em> <code>μ n < μ (delta n)</code> because ordinal right addition can erase strictness if the right summand eclipses the left difference. Without constraints on <code>μ s</code>, <code>(⋆)</code> may fail—hence attempts using <code>add_lt_add_right</code> or syntactic shift tactics are invalid.<br>
<br>
### 5.2.1 Formal Counterexample Pattern (Explicit Construction)<br>
<br>
Let <code>n</code> be any trace and set <code>α := μ n</code>. Then by definition<br>
<code>μ (delta n) = ω^5 * (α + 1) + 1</code>.<br>
<br>
Choose a trace <code>s := recΔ b' s' n'</code> such that <code>μ s</code> has leading term<br>
<code>ω^( μ n' + μ s' + 6 )</code> with exponent <code>μ n' + μ s' + 6  ≥ ω^5 * (α + 1) + 1</code> (possible by nesting a recΔ whose internal <code>μ n'</code> already dominates the finite shell 5). Then<br>
<br>
<pre><code><br>
μ n + μ s + 6  = μ s + (μ n + 6)   (absorbed by leading tower of μ s)<br>
μ (delta n) + μ s + 6 = μ s + (ω^5*(α+1)+1 + 6) = μ s   (same absorption)<br>
</code></pre><br>
<br>
Hence <code>μ n + μ s + 6 = μ (delta n) + μ s + 6</code>, falsifying <code>(⋆)</code> and therefore the pure μ decrease needed for <code>Rec‑S</code>.<br>
<br>
### 5.3 Standard Workarounds Considered<br>
1. <strong>Lexicographic Pair <code>(kappa, μ)</code>:</strong> Works (kappa counts <code>delta</code> height so <code>Rec‑S</code> strictly decreases first component) but sacrifices the elegance of pure ordinal synthesis.<br>
2. <strong>Strengthen μ’s δ Layer:</strong> Modify δ exponent (e.g., escalate to an inaccessible offset) to dominate any <code>μ s</code>. Disruptive: forces sweeping revalidation of previously proved decreases.<br>
3. <strong>Structural Restriction:</strong> Enforce semantic relation tying <code>s</code> to <code>n</code> (not allowed; kernel semantics treat them independent parameters).<br>
4. <strong>Tail‑Dominance Lemma (Option A Chosen):</strong> Explicit side conditions capturing that the <em>specific</em> tail we add is finite / controlled relative to new leading tower. Requires a <em>provable</em> bound on <code>μ s</code> in terms of <code>μ n</code>—not available; thus we must encode a <em>conditional</em> lemma with a domination hypothesis.<br>
<br>
### 5.4 Formal Shape for the Needed New Lemma<br>
We propose introducing a <em>conditional</em> transport lemma:<br>
<br>
<pre><code><br>
lemma add_tail_strict<br>
	{a b t : Ordinal}<br>
	(h : a < b)<br>
	(finite_tail : t < ω^(5) * (a + 1)) : a + t < b + t<br>
</code></pre><br>
<br>
Then instantiate with <code>a := μ n</code>, <code>b := μ (delta n)</code> and <code>t := μ s + 6</code> <strong>if</strong> we can ensure <code>μ s + 6 < ω^5*(μ n + 1)</code>. This is exactly the missing domination hypothesis.<br>
<br>
### 5.5 Why Domination Hypothesis is Non‑Trivial<br>
<code>μ s</code> can itself contain a <code>recΔ</code> term with exponent <code>ω^( μ n' + μ s' + 6 )</code>, potentially arbitrarily large; there is no a priori bound by a fixed finite tower over <code>μ n</code> unless we track <code>delta</code> depth separately.<br>
<br>
Thus unconditional Option A fails unless we augment the measure or reintroduce an auxiliary component capturing a well‑founded <em>delta depth bound</em> to ensure finite transport safety.<br>
<br>
---<br>
<br>
## 6. Current Mathematical Blocker — Precise Statement<br>
<br>
We cannot (presently) prove, <em>for arbitrary traces</em>, the strict inequality:<br>
<br>
<code>μ n + μ s + 6 < μ (delta n) + μ s + 6</code>.<br>
<br>
Reason: Need <code>μ s</code> constrained to avoid swallowing the δ‑bump. Ordinal arithmetic only guarantees left‑addition strictness (<code>add_lt_add_left</code>), not right‑addition strictness in general. Right summand may be a limit dominating the added difference.<br>
<br>
---<br>
<br>
## 7. Resolution Paths & Tradeoffs<br>
<br>
| Path | Action | Pros | Cons |<br>
|------|--------|------|------|<br>
| P1 | Reinstate lexicographic measure <code>(κ, μ)</code> (original "simple κ") | REJECTED: naive κ designs fail (see §7.1) | Would have been immediate if κ existed |<br>
| P2 | Redefine μ with higher δ tier (e.g., elevate base exponent tier separation) | Single measure vision preserved | Cascading re‑proof for all earlier lemmas |<br>
| P3 | Add semantic restriction linking <code>s</code> and <code>n</code> | Light patch | Violates kernel abstraction / generality |<br>
| P4 | Hybrid measure (μ plus bounded auxiliary ordinal counter) | Balanced compromise | New infrastructure & proofs |<br>
<br>
Preferred pragmatic step: <strong>P1 (lexicographic fallback)</strong> to obtain a green SN theorem, then pursue P2 experimentally on a feature branch.<br>
<br>
### 7.1 Post‑Analysis: Why the Earlier “Path A / Simple κ” Claim Was Retracted<br>
<br>
Earlier iterations indicated a <em>validated</em> Path A (simple natural counter) on the assumption that counting top‑level or delta depths would strictly decrease on <code>Rec‑S</code> while staying unchanged on other rules. Subsequent formal scrutiny (see §7.2) exposed duplication effects of <code>s</code> in the <code>Rec‑S</code> rule invalidating every such Nat‑valued κ variant. The prior claim conflated <em>local decrease along the n‑spine</em> with <em>global monotonicity under context duplication</em>. This correction supersedes any previous “validated” status for simple κ.<br>
<br>
### 7.2 Impossibility Proofs for Naive κ Variants<br>
<br>
We show representative natural‑valued κ schemes cannot yield a lexicographic decrease for all rules when paired with μ.<br>
<br>
#### 7.2.1 κ₀: Top‑Level Flag<br>
Definition: <code>κ₀(t)=1</code> iff <code>t</code> is <code>recΔ _ _ _</code>, else 0.<br>
<code>Rec‑S</code>: <code>recΔ b s (delta n) → merge s (recΔ b s n)</code>. If RHS retains an inner top‑level <code>recΔ</code> (it does) the flag stays 1; κ₀ unchanged ⇒ must rely on μ which is not proven strictly decreasing (needs (⋆)). Fail.<br>
<br>
#### 7.2.2 κ₁: Total Number of recΔ Nodes<br>
<code>Rec‑S</code> duplicates <code>s</code> outside the existing <code>recΔ</code>, potentially increasing the total count if <code>s</code> itself contains any <code>recΔ</code>. Since lex order requires <code>κ</code> non‑increasing (or strictly decreasing at target rule), monotonic decrease fails in those cases. Fail.<br>
<br>
#### 7.2.3 κ₂: Depth of the n‑Spine Only<br>
Let <code>κ₂(recΔ b s n)=κ₂(n)+1</code>, otherwise 0. Then <code>Rec‑S</code> changes depth from <code>κ₂(delta n)+1 = κ₂(n)+2</code> on LHS to <code>max(κ₂(s), κ₂(recΔ b s n))</code> hidden inside a merge on RHS. If <code>κ₂(s) ≥ κ₂(n)+2</code> the depth does not strictly drop. Worse, merge wrapper can hide multiple deep spines without lowering κ₂. Fail.<br>
<br>
#### 7.2.4 κ₃: Sum of Heights of All recΔ Arguments<br>
Heights are natural numbers; replacing <code>delta n</code> by <code>n</code> reduces one summand by 1, but duplicating <code>s</code> adds an additional summand equal to height(s). Net effect can increase the sum. Fail (counterexample: choose <code>s</code> with height > 1).<br>
<br>
#### 7.2.5 κ₄: Maximum recΔ Argument Height<br>
<code>Rec‑S</code> may reduce the height contributed by the specific <code>delta n</code> → <code>n</code>, but if <code>s</code> already attains the maximum, the max is unchanged. Again must rely on μ (blocked by (⋆)). Fail.<br>
<br>
#### 7.2.6 κ₅: Pair (Number of recΔ, Maximum Height)<br>
Lex on these still inherits failures: first component may increase (duplication) or stay; second stays when <code>s</code> dominates. No guaranteed strict decrease on primary component; secondary μ blocked. Fail.<br>
<br>
#### 7.2.7 General Schema Argument<br>
Any Nat‑valued κ that:<br>
1. Reads only finitely many structural summaries (counts, maxima, depths), and<br>
2. Treats disjoint subtrees additively or via max,<br>
will be non‑decreasing under a duplication context transformation <code>t ↦ merge s t</code> whenever <code>κ(s) ≥ κ(component_of t)</code>; the <code>Rec‑S</code> rule is exactly such a duplication. Therefore no such κ enforces strict decrease at <code>Rec‑S</code> while remaining non‑increasing on merge rules.<br>
<br>
### 7.3 Consequence<br>
All simple Nat counters are ruled out. A <em>structured</em> multiset (or measure over labeled positions suppressing duplicate contribution) is required. Path A is <strong>officially deprecated</strong>; advancement proceeds with multiset κ design (§19.7) or μ redesign.<br>
<br>
---<br>
<br>
## 8. Tactics & Ordinal API Usage (Meta Layer)<br>
<br>
| Category | Tool / Lemma | Role |<br>
|----------|--------------|------|<br>
| Positivity | <code>Ordinal.opow_pos</code> | Show tower > 0 for multiplicative monotonicity |<br>
| Exponent Monotone | <code>Ordinal.opow_le_opow_right</code>, local <code>opow_lt_opow_right</code> | Lift (≤ / <) through ω‑powers |<br>
| Additive Principal | <code>Ordinal.principal_add_omega0_opow</code> | Absorb subordinate finite / smaller tower sums |<br>
| Finite Absorption | <code>omega_pow_fin_mul_cnf_lt</code> (project lemma) | Embed <code>ω^k * X</code> under higher tower |<br>
| Structural Rewrites | <code>opow_add</code> | Collapse tower products |<br>
| Successor Bridge | <code>Order.lt_add_one_iff</code>, <code>Order.add_one_le_of_lt</code> | Normalize +1 / succ manipulations |<br>
<br>
Simp strategy: restrict to associativity/commutativity and the μ definition expansions; avoid aggressive normalization that could collapse intended ordinal stratification.<br>
<br>
---<br>
<br>
## 9. Roadmap to Green Build (If Choosing P1 Now)<br>
<br>
REVISED (Simple κ Removed — Multiset κ Planned):<br>
1. Specify multiset κ_spine capturing δ‑heights of <em>active</em> recursion arguments (design document pending codification).<br>
2. Prove <code>Rec‑Zero</code> removes one spine element; <code>Rec‑Succ</code> replaces a height <code>h+1</code> by <code>h</code> without introducing larger new elements (requires definition of “active” forbidding double counting of duplicated <code>s</code>).<br>
3. All other rules: κ_spine unchanged (merge duplication must be shown not to add new <em>active</em> spine entries — structural projection needed).<br>
4. Define <code>μκ t := (κ_spine t, μ t)</code> with lex using multiset extension <code><ₘ</code> on the first component.<br>
5. Establish well‑foundedness: multiset extension well‑founded + ordinal well‑founded ⇒ lex well‑founded.<br>
6. Integrate existing μ decrease lemmas for rules where κ_spine unchanged.<br>
7. Isolate pure μ rec‑successor research in a guarded section; document dependency on impossible (⋆).<br>
8. After green SN with multiset κ_spine, proceed to normalization & confluence.<br>
<br>
---<br>
<br>
## 10. Future Pure‑μ Research Track (P2)<br>
<br>
Objective: Refactor μ so that δ promotion produces a <em>guaranteed</em> exponent jump dominating any context <code>μ s</code> that could appear simultaneously in a <code>recΔ</code>. Candidate strategies:<br>
<br>
1. <strong>Introduce Tier Parameter:</strong> Replace <code>ω^(5)</code> with <code>ω^(Ω · (μ t + 1) + c)</code> for some higher‑order ordinal <code>Ω = ω^(ω)</code> to isolate δ growth.<br>
2. <strong>Use Multiplicative Tower Elevation:</strong> Encode constructor levels as iterated exponent layers (<code>ω^(ω^(level + payload))</code>) ensuring that δ always injects a higher tower tier than any merge/rec composition using previous payloads.<br>
3. <strong>Ordinal Collapsing Function:</strong> Apply a collapsing function <code>ψ</code> to shape complexity; heavy machinery—may exceed project minimalism goals.<br>
<br>
Risks: Each redesign demands re‑establishing all monotonicity and strictness lemmas with expanded algebraic overhead.<br>
<br>
---<br>
<br>
## 11. Confluence & Downstream Dependencies<br>
<br>
Once SN is secured (via lex pair if necessary), confluence follows the normalize–join plan:<br>
1. Define deterministic normalizer <code>normalize : Trace → Trace</code> folding by exhaustive Step reduction guided by the well‑founded measure.<br>
2. Show every trace reduces to its normal form.<br>
3. Show uniqueness of normal forms ⇒ Church–Rosser (confluent rewrite system).<br>
<br>
Subsequent arithmetic & equality developments assume canonical evaluation, so expediting SN (even via lexicographic fallback) unlocks progress in those modules without waiting for a perfected one‑measure architecture.<br>
<br>
---<br>
<br>
## 12. Summary of Blocked vs Ready Components<br>
<br>
| Component | Status | Action |<br>
|-----------|--------|--------|<br>
| Non‑rec rules μ decrease | READY | Minor polishing only |<br>
| Rec‑Zero μ decrease | READY | — |<br>
| Rec‑Succ pure μ | BLOCKED | Needs domination or alternative measure |<br>
| Lexicographic SN | AVAILABLE | Re‑activate and finalize |<br>
| Confluence pipeline | PENDING | Await finalized SN theorem |<br>
| Pure μ research branch | FUTURE | Design alternate μ tiering |<br>
<br>
---<br>
<br>
## 13. Actionable Next Steps (Immediate Implementation Plan)<br>
<br>
1. Formalize definition of “active recursion spine” and implement κ_spine.<br>
2. Implement spine extraction + examples; prove auxiliary lemmas (spine_merge, spine_rec_zero, spine_rec_succ).<br>
3. Prove <code>Rec‑Zero</code> / <code>Rec‑Succ</code> κ_spine strict decrease (multiset removal / reduction lemma).<br>
4. Prove invariance of κ_spine under other rules (or controlled non‑increase via projection).<br>
5. Assemble lexicographic SN using κ_spine + μ.<br>
6. Add fuzz harness to check (κ_spine, μ) decreases empirically for random steps.<br>
7. Preserve and annotate pure μ sandbox; reference (⋆) impossibility.<br>
8. Move on to normalization & confluence once build green.<br>
<br>
---<br>
<br>
## 14. Appendix: Notational & Lemma Glossary<br>
<br>
| Symbol | Meaning |<br>
|--------|---------|<br>
| <code>μ t</code> | Ordinal measure of trace <code>t</code> |<br>
| <code>κ t</code> (<code>kappa</code>) | Delta depth (number of nested <code>recΔ</code> argument deltas peeled) |<br>
| <code>Step</code> | One-step rewrite relation |<br>
| <code>StepStar</code> | Reflexive–transitive closure of <code>Step</code> |<br>
| <code>A</code> | Shorthand <code>ω^( μ (delta n) + μ s + 6 )</code> in rec successor reasoning |<br>
| <code>principal_add_omega0_opow</code> | Additive principal lemma for <code>ω^κ</code> |<br>
| <code>opow_lt_opow_right</code> | Strict monotonicity of exponentiation in exponent |<br>
| <code>termA_le</code>, <code>termB_le</code> | Bounding lemmas raising fixed tower tiers |<br>
<br>
---<br>
<br>
## 15. Precise Mathematical Blocker Statement (For Tracking)<br>
<br>
> Open Problem (Pure μ SN Rec‑Succ): Prove for arbitrary traces <code>n s</code>:<br>
> <code>μ n + μ s + 6 < μ (delta n) + μ s + 6</code>.<br>
><br>
> This is equivalent to demonstrating that the ordinal difference <code>μ (delta n) − μ n</code> remains observable after right addition of <code>μ s + 6</code>. Ordinal arithmetic shows counterexamples unless a structural dominance on the added right summand is imposed.<br>
<br>
Mitigation: Lexicographic fallback <code>(kappa, μ)</code> avoids needing this inequality.<br>
<br>
---<br>
<br>
## 16. Roadmap Milestones Table<br>
<br>
| Milestone | Description | ETA (Relative) |<br>
|-----------|-------------|----------------|<br>
| M1 | Lexicographic SN proof re‑enabled & green | Short |<br>
| M2 | Confluence proof (normalize–join) | After M1 |<br>
| M3 | Arithmetic layer finalized using SN engine | After M2 |<br>
| M4 | Equality canonicalization via normalization | Parallel M3 |<br>
| M5 | Pure μ research branch created | Post M1 baseline |<br>
| M6 | Domination lemma or μ redesign evaluated | Research |<br>
<br>
---<br>
<br>
## 17. Closing<br>
<br>
This companion consolidates the theoretical blueprint, identifies the precise obstruction to a monolithic <code>μ</code> termination argument, and delineates pragmatic and research trajectories. The recommended immediate path to unblock downstream development is the lexicographic measure finalization, while preserving an annotated sandbox for the pure <code>μ</code> refinement.<br>
<br>
End of Document.<br>
<br>
---<br>
<br>
## 18. Catalogue of Unsuccessful / Abandoned SN Approaches (For Avoidance)<br>
<br>
This section records concrete strategies that were attempted and <em>why</em> they failed, to prevent rerunning the same dead ends.<br>
<br>
| Attempt Code | Short Name | Core Idea | Failure Mode | Lesson |<br>
|--------------|------------|----------|--------------|--------|<br>
| A1 | Raw Right-Add Transport | Derive <code>(μ n < μ (delta n)) ⇒ μ n + μ s + c < μ (delta n) + μ s + c</code> for arbitrary <code>s</code> | Ordinal right addition not strictly monotone; counterexamples where <code>μ s</code> is large limit obliterate strictness | Cannot recover strictness on the left by adding an uncontrolled right tail. Need dominance or lex tier |<br>
| A2 | <code>add_lt_add_right</code> Overuse | Force strictness by rewriting goals to fit <code>add_lt_add_right</code> | Lemma requires <em>same</em> addend; we have differing complex tails; attempted coercions produced ill-typed or circular goals | Do not coerce goal shapes into generic lemmas when structural asymmetry exists |<br>
| A3 | Finite Padding Escalation | Increase finite offsets (<code>+6</code>, <code>+9</code>, etc.) hoping gaps survive right-add | Finite bumps drown under large limit <code>μ s</code>; does not influence principal part absorption | Finite offsets only help inside already bounded contexts, not against arbitrary large added summands |<br>
| A4 | Tower Multiplication Reorientation | Swap ordering <code>(ω^k)<em>(μ n + 1)</code> vs <code>(μ n + 1)</em>ω^k</code> to mine monotonicity | Ordinal multiplication non‑commutative; reorientation invalid; required unsupported equalities | Respect directionality; avoid heuristic commutations not justified by lemmas |<br>
| A5 | Collapsing via <code>simp</code> Aggression | Heavy <code>simp</code> hoping to expose trivial inequalities | Over-simplification erased stratification markers, generating harder mixed goals or timeouts | Keep controlled rewriting; preserve tower structure for principal lemmas |<br>
| A6 | Inject Synthetic Bound <code>μ s ≤ μ (delta n)</code> | Assume (false) ordering to push inequality through sum | Demonstrably false (constructed counterexample with deeper <code>s</code>) | Never posit cross‑parameter bounds without structural invariants |<br>
| A7 | Unconditional Tail Domination Lemma | Propose <code>μ s + c < ω^5*(μ n + 1)</code> universally | Fails when <code>μ s</code> itself introduces higher dynamic tower (e.g. nested recΔ) | Tail domination must be conditional or tracked via auxiliary measure |<br>
| A8 | Recursive Unfolding Loop | Expand both sides of Rec‑S repeatedly to compare exponents | Leads to infinite expansion pattern; no well‑founded metric for closure | Avoid unfolding that increases syntactic size without pathway to principal comparison |<br>
| A9 | Mixed Tactic Brute Force (<code>linarith</code>, <code>ring</code>) | Numeric tactic attempts on ordinal goals | Tactics tuned for semirings over ℕ/ℤ; ordinal non‑commutativity & non‑cancellation defeat them | Use ordinal‑specific lemmas; numeric tactics only for finite sub‑arithmetics |<br>
| A10 | Direct Exponent Difference Encoding | Introduce δΔ := <code>(μ (delta n) + μ s + 6) - (μ n + μ s + 6)</code> and show δΔ > 0 | Ordinals lack subtraction behaving like naturals; difference not constructive for strictness under addition | Avoid pseudo‑subtractive encodings; rely on monotonicity lemmas |<br>
| A11 | Simple κ (Nat counter) | Count depth / occurrences / maxima to drive lex decrease | <code>Rec‑S</code> duplicates context <code>s</code>; κ can increase or stay while μ undecided (needs (⋆)) | Requires richer multiset or projection structure (§7.2) |<br>
| A12 | Mixed Pair κ (count,max) | Pair of simple counters | Either component can stagnate or increase under duplication; no strict primary drop | Same obstruction as A11 |<br>
<br>
### Consolidated Lessons<br>
1. <strong>Right Addition Hazard:</strong> Strict inequalities cannot be safely transported to the left of an uncontrolled right addend in ordinals.<br>
2. <strong>Finite Offsets Are Insufficient:</strong> Offsets help only within dominated segments; they do not enforce global dominance.<br>
3. <strong>Structure Preservation:</strong> Over-aggressive simplification obscures the hierarchical tower layout essential for principal absorption.<br>
4. <strong>Auxiliary Measures Are Legitimate:</strong> Lexicographic augmentation (e.g., <code>(κ, μ)</code>) is not a defeat but a structured encapsulation of hidden complexity.<br>
5. <strong>Local vs Global:</strong> Lemmas must state explicit domination hypotheses; assuming universality where only locality holds leads to unsalvageable proof branches.<br>
<br>
### Positive Guidance (Do Instead)<br>
* Use lexicographic <code>(κ, μ)</code> to conclude SN, then refactor measure architecture offline.<br>
<em> When seeking pure μ refinements, design δ exponent tiers so their </em>constructor level* cannot be matched by any <code>s</code> appearing in the same rule instance.<br>
* Encapsulate any future domination assumption as a clearly parameterized lemma, never inline.<br>
<br>
---<br>
<br>
## 19. THE WALL — Exhaustive Blocker Dossier (Deep Dive - This List Is Not Exclusive - Always Add New Blockers With Full Context and Mathematical Verification)<br>
<br>
This section is an intensified, formalized codification of the precise mathematical barrier (“the wall”) obstructing a <em>pure</em> ordinal <code>μ</code> proof for the <code>Rec‑Succ</code> rule, together with certified counterexamples and a taxonomy of failed mitigation attempts. It is meant to be definitive: future agents must consult this before proposing any new pure‑μ maneuver.<br>
<br>
### 19.1 Canonical Problem Statement<br>
Goal (unconditional): prove for all traces <code>b s n</code>:<br>
<br>
<pre><code><br>
μ (merge s (recΔ b s n)) < μ (recΔ b s (delta n))<br>
</code></pre><br>
<br>
After expansion and elimination of strictly subordinate tails this reduces to needing:<br>
<br>
<pre><code><br>
(★)   μ n + μ s + 6 < μ (delta n) + μ s + 6<br>
</code></pre><br>
<br>
The only source of strictness is <code>μ n < μ (delta n)</code>; right addition by <code>μ s + 6</code> must <em>preserve</em> strictness. Ordinal arithmetic does <strong>not</strong> guarantee this preservation absent a dominance constraint on the right summand.<br>
<br>
### 19.2 Formal Non‑Derivability of (★)<br>
Let <code>d := μ (delta n)</code>. We always have <code>μ n < d</code>. We seek <code>μ n + T < d + T</code> with <code>T := μ s + 6</code> arbitrary. In ordinals, strictness is preserved on the <strong>left</strong>: <code>a < b ⇒ T + a < T + b</code> (via <code>add_lt_add_left</code>), but <strong>not</strong> on the right. Counterexamples exist when <code>T</code> is a (large) limit ordinal absorbing the difference <code>d - μ n</code>.<br>
<br>
### 19.3 Concrete Counterexample Schema<br>
Choose traces inducing:<br>
- <code>μ n = α</code> (some ordinal)<br>
- <code>μ (delta n) = ω^5*(α + 1) + 1</code> (by definition)<br>
- Let <code>s</code> contain a nested <code>recΔ</code> whose leading tower exponent strictly exceeds the finite <code>ω^5</code> layer gap, e.g. pick <code>s := recΔ b' s' n'</code> where <code>μ s</code> includes a top component <code>ω^(μ n' + μ s' + 6)</code> with exponent <code>μ n' + μ s' + 6</code> ≫ <code>(5 : Ordinal)</code>.<br>
<br>
Then <code>T = μ s + 6</code> is already ≥ a tower dwarfing the additive difference between <code>μ (delta n)</code> and <code>μ n</code>. Absorption yields:<br>
<pre><code><br>
μ (delta n) + T = T          (limit absorption)<br>
μ n + T        = T<br>
</code></pre><br>
Therefore <code>μ n + T = μ (delta n) + T</code>, falsifying (★).<br>
<br>
Hence (★) is <strong>false</strong> in general.<br>
<br>
### 19.4 Invalid Rescue Patterns (with Diagnostics)<br>
| Code | Pattern | Why It Fails |<br>
|------|---------|-------------|<br>
| R1 | Blind use of <code>add_lt_add_right</code> | Requires <em>same</em> right addend; equality degenerates under absorption when addend dominates difference |<br>
| R2 | Inflate finite offsets (<code>+6 → +10 → +k</code>) | Finite increments are annihilated by unbounded tower in <code>μ s</code> |<br>
| R3 | Assert fabricated dominance <code>μ s ≤ ω^5*(μ n + 1)</code> | Not an invariant of the system; disproven by constructing large nested <code>recΔ</code> in <code>s</code> |<br>
| R4 | Rewrite via commutativity to left-add form | Ordinal addition non‑commutative; goal shape invalidates lemma preconditions |<br>
| R5 | Subtraction surrogate <code>(μ (delta n) + μ s + 6) - (μ n + μ s + 6)</code> | Ordinal “subtraction” not cancellative; no lean lemma produces needed strictness |<br>
| R6 | Aggressive <code>simp</code> to flatten towers | Destroys stratification; loses access to principal ordinal lemmas |<br>
| R7 | Tactic brute force (<code>linarith</code>, <code>ring</code>) | Numeric tactics unsuited for ordinal non‑commutative, non‑cancellative context |<br>
<br>
### 19.5 Exhausted κ (Lex) Variants and Counterexamples<br>
| κ Variant | Definition Sketch | Failing Rule | Failure Mechanism |<br>
|-----------|-------------------|--------------|-------------------|<br>
| κ₁ depth | Counts total structural depth | <code>merge</code> rules | Depth preserved; no strict drop guarantees |<br>
| κ₂ root flag (<code>recΔ</code> root = 1 else 0) | Binary flag | <code>Rec‑Zero</code> / non‑rec rules | Flag can increase when rewriting inside subterms, breaking monotonic descent |<br>
| κ₃ sum of all <code>recΔ</code> occurrences + δ depth | Structural sum | <code>Rec‑Succ</code> | <code>merge s (...)</code> can duplicate contexts preserving or increasing sum |<br>
| κ₄ proposed <code>κ(recΔ b s n) = succ (κ n)</code> else 0 | Tail‑focused | <code>Rec‑Zero</code> | Base erases <code>recΔ</code> shell exposing possibly higher κ in <code>b</code> (no guaranteed decrease) |<br>
| κ₅ mixed flag + depth hybrid | Ad hoc combination | Multiple | Lacked global monotone behavior under <code>merge</code> duplication |<br>
<br>
Conclusion: naïve κ formulations ignoring <em>positional interaction</em> between <code>s</code> and <code>n</code> fail to strictly decrease on at least one recursive rule.<br>
<br>
### 19.6 Minimal Requirements for a Successful Auxiliary Component<br>
An auxiliary measure <code>κ</code> suitable for lex ordering must satisfy:<br>
1. <code>Rec‑Succ</code>: <code>κ (recΔ b s (delta n)) > κ (merge s (recΔ b s n))</code>.<br>
2. <code>Rec‑Zero</code>: <code>κ (recΔ b s void) > κ b</code>.<br>
3. Non‑rec rules: <code>κ</code> non‑increasing (preferably unchanged) to let proven μ decreases discharge the pairwise lex descent.<br>
4. Computable structurally without inspecting transitive closures or normalization results.<br>
<br>
### 19.7 Viable Direction for κ Design<br>
Introduce a <em>fuel on the recursion spine</em> representing the multiset of δ‑heights of active <code>recΔ</code> arguments. Then:<br>
- <code>Rec‑Succ</code>: replaces <code>delta n</code> by <code>n</code>, strictly decreasing the multiset under the multiset extension of <code><</code> on natural heights.<br>
- <code>Rec‑Zero</code>: removes one spine element entirely.<br>
This suggests modeling κ as a multiset measure and using the well‑founded multiset extension (available in Mathlib). Tradeoff: increased infrastructure vs immediate correctness.<br>
<br>
### 19.8 Decision Matrix Update<br>
| Approach | Status | Effort | Confidence | Notes |<br>
|----------|--------|--------|------------|-------|<br>
| Pure μ (current) | Blocked | High | Low (until redesign) | Needs structural dominance redesign |<br>
| Simple κ (nat depth) | Invalid | Low | Low | Counterexamples exist |<br>
| Multiset κ (δ spine) | Open | Medium | High | Aligns with standard termination proofs |<br>
| μ Redesign (tier elevation) | Research | High | Medium | Requires re‑proving 7 rules |<br>
<br>
### 19.9 Policy Mandate<br>
No further pure μ attempts may proceed unless accompanied by:<br>
1. A formal lemma template explicitly stating a <em>dominance invariant</em> linking <code>μ s</code> to <code>μ n</code>.<br>
2. A proof sketch showing that invariant is preserved by <em>all</em> 8 rules.<br>
3. A compartmentalized experimental file (not replacing the stable lex SN path) until validated.<br>
<br>
### 19.10 Engineering Guidance for Implementation<br>
If pursuing the multiset path:<br>
1. Define <code>deltaHeight : Trace → Nat</code> (height of outermost δ chain).<br>
2. Define <code>recSpine : Trace → Multiset Nat</code> collecting heights of all <code>n</code> arguments in <em>active</em> <code>recΔ</code> nodes (active = not under another constructor except nested in the structure—design choice must be fixed and documented).<br>
3. κ := <code>recSpine t</code> ordered by multiset extension <code><ₘ</code> (well‑founded).<br>
4. Prove each rule decreases either κ or μ (when κ unchanged) under lex <code>( <ₘ , < )</code>.<br>
5. Export WellFounded via product of well-founded relations (multiset + ordinal).<br>
<br>
### 19.11 Rationale for Archiving This Section<br>
Having an immutable, citation‑ready articulation prevents cyclical rediscovery and rationalizes future design pivots (e.g., adopting multiset κ). It also supplies reviewers with a single authoritative narrative for <em>why</em> the pure μ aspiration was deferred.<br>
<br>
---<br>
<br>
<br>
<br>

</body>
</html>
