<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizing the Complex Amplitude</title>
    <style>
        body {
            background-color: #050505;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 1px solid #333;
            background-color: #000;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #444;
            max-width: 300px;
        }
        h1 { font-size: 16px; margin-top: 0; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 12px; line-height: 1.4; color: #aaa; }
        .controls {
            display: flex;
            gap: 10px;
            padding: 20px;
            background: #111;
            width: 100%;
            justify-content: center;
            border-top: 1px solid #333;
        }
        button {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }
        button:hover { background: #333; border-color: #666; }
        button.active { background: #004400; border-color: #00ff00; }
        
        .stat-display {
            margin-top: 10px;
            font-size: 10px;
            color: #666;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
        <div id="ui-layer">
            <h1 id="module-title">Module 0: Initialization</h1>
            <p id="module-desc">Loading logical primitives...</p>
            <div class="stat-display" id="stats"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="setModule(1)" id="btn1">1. The Unit</button>
        <button onclick="setModule(2)" id="btn2">2. The Field</button>
        <button onclick="setModule(3)" id="btn3">3. Momentum</button>
        <button onclick="setModule(4)" id="btn4">4. Interference</button>
        <button onclick="setModule(5)" id="btn5">5. Measure</button>
    </div>

<script>
    // --- LOGICAL PRIMITIVES ---

    class Complex {
        constructor(re, im) {
            this.re = re;
            this.im = im;
        }
        
        add(c) { return new Complex(this.re + c.re, this.im + c.im); }
        multiply(c) { return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re); }
        scale(s) { return new Complex(this.re * s, this.im * s); }
        mag() { return Math.sqrt(this.re * this.re + this.im * this.im); }
        phase() { return Math.atan2(this.im, this.re); }
        
        static fromPolar(r, theta) {
            return new Complex(r * Math.cos(theta), r * Math.sin(theta));
        }
    }

    // --- SIMULATION ENGINE ---

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let grid = [];
    let rows = 20;
    let cols = 30;
    let spacing = 40;
    let time = 0;
    let activeModule = 1;
    let isCollapsed = false;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight - 80; // Space for controls
        canvas.width = width;
        canvas.height = height;
        cols = Math.floor(width / spacing);
        rows = Math.floor(height / spacing);
        initGrid();
    }

    function initGrid() {
        grid = [];
        for(let y=0; y<rows; y++) {
            let row = [];
            for(let x=0; x<cols; x++) {
                row.push(new Complex(0,0));
            }
            grid.push(row);
        }
    }

    // --- PHYSICS LOGIC ---

    function update() {
        time += 0.05;
        
        if (isCollapsed) {
            // Thermodynamics: Entropy maximization in the environment, frozen state in the system
            return; 
        }

        for(let y=0; y<rows; y++) {
            for(let x=0; x<cols; x++) {
                // Normalized coordinates (-1 to 1)
                let nx = (x - cols/2) / (cols/2);
                let ny = (y - rows/2) / (rows/2);
                let dist = Math.sqrt(nx*nx + ny*ny);

                let val = new Complex(0,0);

                switch(activeModule) {
                    case 1: // The Unit
                        if (x === Math.floor(cols/2) && y === Math.floor(rows/2)) {
                            val = Complex.fromPolar(1.5, time); // Rotating phasor
                        }
                        break;
                    case 2: // The Field
                        // A uniform field, slight variation
                        val = Complex.fromPolar(0.5, time + dist * 2); 
                        break;
                    case 3: // Momentum
                        // Plane wave: phase changes linearly with position
                        // k = 4 (wavenumber)
                        val = Complex.fromPolar(0.8, time + nx * 5); 
                        break;
                    case 4: // Interference
                        // Source 1 (Left)
                        let d1 = Math.sqrt(Math.pow(nx + 0.5, 2) + Math.pow(ny, 2));
                        let w1 = Complex.fromPolar(0.6, time - d1 * 15);
                        
                        // Source 2 (Right)
                        let d2 = Math.sqrt(Math.pow(nx - 0.5, 2) + Math.pow(ny, 2));
                        let w2 = Complex.fromPolar(0.6, time - d2 * 15);
                        
                        // Superposition
                        val = w1.add(w2);
                        break;
                    case 5: // Measurement Prep
                        // Gaussian packet
                        let gaussian = Math.exp(-(dist*dist)*5);
                        val = Complex.fromPolar(gaussian, time - dist * 10);
                        break;
                }
                grid[y][x] = val;
            }
        }
    }

    // --- RENDER LOGIC ---

    function drawPhasor(ctx, x, y, size, complex) {
        let mag = complex.mag();
        let ang = complex.phase();
        
        if (mag < 0.01) return;

        // Visual: Magnitude = Opacity/Brightness
        let intensity = Math.min(1, mag);
        let colorHue = (ang * 180 / Math.PI + 360) % 360; // Phase = Color
        
        ctx.strokeStyle = `hsl(${colorHue}, 100%, 50%)`;
        ctx.fillStyle = `hsl(${colorHue}, 100%, 50%)`;
        ctx.lineWidth = 2;

        // Draw Clock Face (faint)
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,255, ${0.1 * intensity})`;
        ctx.arc(x, y, size * mag, 0, Math.PI * 2);
        ctx.stroke();

        // Draw Hand
        let tipX = x + Math.cos(ang) * size * mag;
        let tipY = y + Math.sin(ang) * size * mag;
        
        ctx.beginPath();
        ctx.strokeStyle = `hsl(${colorHue}, 80%, ${50 + 40*intensity}%)`;
        ctx.moveTo(x, y);
        ctx.lineTo(tipX, tipY);
        ctx.stroke();
        
        // Draw Tip
        ctx.beginPath();
        ctx.arc(tipX, tipY, 2, 0, Math.PI*2);
        ctx.fill();
    }

    function draw() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Trail effect
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let cellW = canvas.width / cols;
        let cellH = canvas.height / rows;
        let radius = Math.min(cellW, cellH) * 0.4;

        for(let y=0; y<rows; y++) {
            for(let x=0; x<cols; x++) {
                let cx = x * cellW + cellW/2;
                let cy = y * cellH + cellH/2;
                drawPhasor(ctx, cx, cy, radius * 3, grid[y][x]); // Scale up slightly for visibility
            }
        }
        
        requestAnimationFrame(loop);
    }

    function loop() {
        update();
        draw();
    }

    // --- UI LOGIC ---

    const descriptions = {
        1: {
            title: "Module 1: The Chronometer (Phasor)",
            desc: "The fundamental unit of quantum logic is not a number, but a rotating vector. <br><br><b>Radius</b> = Amplitude (Probability weight)<br><b>Angle</b> = Phase (Timing)<br><br>Observe the single 'clock' in the center."
        },
        2: {
            title: "Module 2: The Carpet (Field)",
            desc: "Space is a grid of potential. Every point in the vacuum contains a phasor.<br><br>Here, the field has uniform amplitude, but the phase varies gently across space."
        },
        3: {
            title: "Module 3: Geometry of Momentum",
            desc: "<b>Momentum is a Twist.</b><br><br>Observe the spiral pattern. The faster the phase twists from one neighbor to the next, the higher the momentum (energy).<br>p = Ä§k"
        },
        4: {
            title: "Module 4: Interference",
            desc: "<b>Logic of Superposition.</b><br><br>Two sources emit waves. Where arrows point the same way, they add up (Bright). Where they oppose, they cancel (Dark).<br><br>This is not probability adding; this is amplitude adding."
        },
        5: {
            title: "Module 5: Measurement (Thermodynamics)",
            desc: "<b>The Collapse.</b><br><br>The wave is a probability distribution. To find the particle, we must interact with it.<br><br><b>CLICK ANYWHERE</b> on the grid to perform a measurement."
        }
    };

    function setModule(n) {
        activeModule = n;
        isCollapsed = false;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn${n}`).classList.add('active');
        
        document.getElementById('module-title').innerHTML = descriptions[n].title;
        document.getElementById('module-desc').innerHTML = descriptions[n].desc;

        // Reset time for consistent phases on switch
        if(n === 1 || n === 2) time = 0;
    }

    canvas.addEventListener('mousedown', (e) => {
        if(activeModule === 5 && !isCollapsed) {
            isCollapsed = true;
            
            // Thermodynamic Collapse Logic
            let rect = canvas.getBoundingClientRect();
            let clickX = e.clientX - rect.left;
            let clickY = e.clientY - rect.top;
            
            // Map to grid
            let cellW = canvas.width / cols;
            let cellH = canvas.height / rows;
            let gx = Math.floor(clickX / cellW);
            let gy = Math.floor(clickY / cellH);
            
            // Zero out everything
            for(let y=0; y<rows; y++) {
                for(let x=0; x<cols; x++) {
                    grid[y][x] = new Complex(0,0);
                }
            }
            
            // Spike the measured location
            // In reality, this is the selection of an eigenstate
            grid[gy][gx] = new Complex(10, 0); // Massive real amplitude
            
            document.getElementById('module-desc').innerHTML += "<br><br><span style='color:#f55'>SYSTEM COLLAPSED. ENTROPY INCREASED. EIGENSTATE SELECTED.</span>";
        }
    });

    // Init
    window.addEventListener('resize', resize);
    resize();
    setModule(1);
    loop();

</script>
</body>
</html>